## 6.7 Arrays
Bash는 1차원 순차, 연상 배열 변수를 제공합니다. 어떤 변수라도 순차 배열로 사용할 수 있습니다. `declare` 빌트인을 사용해서 명시적으로 배열을 선언할 수 있습니다. 배열의 크기에는 제한이 없으며, 요소가 순서대로 또는 인접하게 대입해야한다는 제약사항도 없습니다. 순차 배열은 정수(산술 표현식을 포함합니다. [Shell Arithmetic](chapter_6_5.html)을 참조하세요)를 사용해 참조하며 0부터 시작합니다. 연상 배열은 임의의 문자열을 사용합니다. 따로 언급하지 않는다면 순차 배열의 인덱스는 음의 정수가 아닌 정수입니다.

순차 배열은 다음 문법을 통해 대입하면 자동으로 생성됩니다.

```sh
name[subscript]=value
```

*subscript*는 반드시 숫자로 평가되어야하는 산술 표현식으로 처리됩니다. 명시적으로 배열을 선언하고 싶다면 다음을 사용하세요.

```sh
declare -a name
```

다음 문법도 사용할 수 있습니다. *subscript*는 무시됩니다.

```sh
declare -a name[subscript]
```

연상 배열은 다음 문법으로 생성할 수 있습니다.

```sh
declare -A name
```

배열 변수를 위한 속성은 `declare`와 `readonly` 빌트인을 사용해서 지정할 수 있습니다. 각 속성은 배열의 모든 요소에 적용됩니다.

배열은 다음 형식의 복합 대입으로 값을 대입합니다.

```sh
name=(value1 value2 … )
```

각 *value*는 `[subscript]=string`의 형식일 수 있습니다. 순차 배열 대입에는 *string*만 있어도 됩니다. 순차 배열에 대입할 때 임의의 첨자를 넘기면 해당 인덱스에 대입됩니다. 그렇지 않으면 해당 대입문이 대입한 마지막 인덱스 값에 1을 더한 인덱스에 요소를 대입합니다. 인덱스는 0부터 시작합니다.

리스트에 있는 각 *value*는 이전에 설명한 모든 셸 전개의 적용을 받습니다([Shell Expansions](chapter_3_5.html)를 참조).

연상 배열에 값을 대입할 때 복합 대입에 있는 단어는 첨자를 요구하는 대입문이거나 키와 값 나열로 해석되는 단어 리스트 *name=(key1 value1 key2 value2 … )* 입니다. 이는 *name=( [key1]=value1 [key2]=value2 … )* 와 동일하게 취급됩니다. 리스트의 첫번째 단어가 나머지 단어를 어떻게 처리할지 결정합니다. 리스트의 모든 대입은 모두 같은 타입이어야 합니다. 키/값 쌍을 사용할 때 키가 존재하지 않거나 비어있을 수 없습니다. 찾지 못한 마지막 값은 빈 문자열로 처리됩니다.

이 문법은 `declare` 빌트인에서도 사용할 수 있습니다. 개별 배열 요소는 위에서 소개한 *name[subscript]=value* 문법을 사용해 대입할 수 있습니다.

순차 배열에 대입할 때 *name*에 음수 첨자를 사용했다면 해당 숫자는 *name*의 최대 인덱스보다 1 큰 값의 상대값으로 처리되므로 음수 인덱스는 배열의 뒷머리부터 셉니다. 인덱스 -1은 마지막 요소를 가리킵니다.

배열의 요소는 `${name[subscript]}`를 사용해서 참조할 수 있습니다. 셸의 파일명 전개 연산자와의 충돌을 피하기 위해서 중괄호는 필수입니다. *subscript*가 '@'나 '\*'라면, 단어는 배열 *name*의 모든 요소로 전개됩니다. 이 첨자들은 단어가 큰따옴표 사이에 나타날 경우에만 동작이 다릅니다. 만약 단어를 큰따옴표로 감쌌다면 `${name[*]}`는 각 배열 요소가 `IFS` 변수의 첫번째 문자로 구분된 단일 단어로 전개되며, `${name[@]}`는 *name*의 각 요소를 다른 단어로 전개합니다. 만약 배열에 요소가 없다면, `${name[@]}`는 아무것도 없는 상태로 전개됩니다. 큰따옴표 전개가 단어 내부에서 일어나면 첫번째 매개변수의 전개 결과가 원래 단어의 앞 부분과 연결되며 마지막 매개변수의 전개 결과가 원래 단어의 마지막 부분과 연결됩니다. 이는 특수 매개변수 '@', '*'의 전개와 유사합니다. `${#name[subscript]}`는 `${name[subscript]}`의 길이로 전개됩니다. 만약 *subscript*가 '@'나 '*'라면 전개 결과는 배열에 있는 요소의 개수입니다. 순차 배열의 요소를 참조하기 위해 사용된 *subscript*의 평가 결과가 0보다 작다면, 배열의 최대 인덱스보다 1 큰 값의 상대 값으로 처리되므로 음수 인덱스는 배열의 뒷머리부터 셉니다. 인덱스 -1은 마지막 요소를 가리킵니다.

첨자 없이 배열 변수를 참조하는 것은 0번째 요소를 가리키는 것과 같습니다. 모든 유효한 첨자를 사용하는 변수에 대한 참조는 정상이며 `bash`는 필요하다면 배열을 생성합니다.

첨자에 값을 대입했다면 배열 변수가 설정되어 있다고 판단합니다. 널 문자열은 유효한 값입니다.

배열의 키(인덱스)와 값을 얻을 수 있습니다. `${!name[@]}`와 `${!name[*]}`는 배열 변수 *name*에 대입된 인덱스로 전개됩니다. 큰따옴표 사이에 있을 때의 처리는 큰따옴표 사이의 특수 매개변수 '@', '*'의 전개와 유사합니다.

`unset` 빌트인은 배열을 제거할 때 사용합니다. `unset name[subscript]`은 인덱스 *subscript*에 있는 배열 요소를 제거합니다. 순차 배열에 음수 첨자를 넘기면 위에서 설명한 방식대로 처리됩니다. 배열 변수의 마지막 요소를 제거하더라도 배열이 제거되지 않습니다. `unset name`은 *name*이 배열이라면 전체 배열을 제거합니다. '*', '@' 첨자를 사용하면 전체 배열을 제거합니다.

예를 들어 `unset`처럼 위에서 설명한 단어 전개 문법을 사용하지 않고 명령어의 인수로 첨자와 함께 배열 이름을 사용하면 인수는 셸의 파일명 확장의 적용을 받습니다. 파일명 전개를 원하지 않는다면 인수를 따옴표로 감싸야 합니다.

`declare`, `local`, `readonly` 빌트인은 각각 순차 배열을 지정하는 `-a` 옵션, 연상 배열을 지정하는 `-A` 옵션을 받습니다. 두 옵션을 같이 넘기면 `-A`가 우선됩니다. `read` 빌트인은 `-a` 옵션을 받아 표준 입력으로부터 단어 리스트를 읽어서 배열에 대입하거나 표준 입력으로부터 값을 읽어 개별 배열 요소로 대입할 수 있습니다. `set`과 `declare` 빌트인은 입력으로 재활용 가능한 형식으로 배열의 값을 출력합니다.
