### 8.4.3 Commands For Changing Text
**end-of-file (일반적으로는 C-d)**

`stty` 등에서 설정되어있는 파일의 끝을 알리는 문자입니다. 줄에 아무 문자가 없고 줄의 첫 머리에 포인트가 있을 때 이 문자를 읽으면 Readline은 이를 입력 종료로 해석하고 EOF를 반환합니다.

**delete-char (C-d)**

포인트에 있는 문자를 지웁니다. 이 함수가 tty EOF 문자와 같은 문자에 바인딩 되어 있다면(보통 *C-d*가 그렇습니다) 위의 효과를 확인해두세요.

**backward-delete-char (Rubout)**

커서 뒤의 문자를 지웁니다. 숫자 인수는 문자를 단순히 지우는 대신 잘라냅니다.

**forward-backward-delete-char ()**

커서가 줄의 끝이 아니라면 커서가 올려져 있는 문자를 지웁니다. 커서가 줄의 끝에 있다면 커서 앞의 문자를 지웁니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**quoted-insert (C-q or C-v)**

다음 문자를 입력한 그대로의 문자로 추가합니다. 이 명령어를 통해 *C-q*와 같은 키 나열을 삽입할 수 있습니다.

**self-insert (a, b, A, 1, !, …)**

자기 자신을 삽입합니다.

**bracketed-paste-begin ()**

이 함수는 몇몇 터미널이 전송하는 "대괄호로 감싼 붙여넣기" 이스케이프 나열을 바인딩하는 것을 목적으로 하며, 이러한 바인딩은 기본값이 설정되어 있습니다. 이를 통해 Readline은 붙여넣은 텍스트를 각 문자를 키보드로부터 읽은 것처럼 처리하지 않고 하나의 단위로 삽입할 수 있습니다. 문자는 편집 명령어를 실행하는 대신 각각 *self-insert*로 바인딩 된 것처럼 삽입됩니다.

대괄호로 감싼 붙여넣기는 삽입한 텍스트에 선택 영역(포인트와 마크 사이의 문자열)을 설정합니다. 이는 *활성화된* 마크 개념을 사용합니다. 마크가 활성화되어 있다면 Readline의 재표시는 선택 영역을 나타내기 위해 터미널의 스탠드아웃 모드를 사용합니다.

**transpose-chars (C-t)**

커서 앞의 문자를 커서가 있는 위치로 끌어오고, 커서도 한 칸 움직입니다. 삽입 포인트가 줄의 끝이라면 명령어는 줄의 마지막 두 문자를 뒤바꿉니다. 음수 인수는 아무런 효과가 없습니다.

**transpose-words (M-t)**

포인트 앞의 단어를 포인트 뒤의 단어의 뒤로 끌어오고, 커서도 끌어온 자리로 움직입니다. 삽입 포인트가 줄의 끝이라면 명령어는 줄의 마지막 두 단어를 뒤바꿉니다.

**upcase-word (M-u)**

현재(또는 다음) 단어를 대문자로 변환합니다. 음수 인수를 넘기면 이전 단어를 대문자로 변환하지만 커서는 움직이지 않습니다.

**downcase-word (M-l)**

현재(또는 다음) 단어를 소문자로 변환합니다. 음수 인수를 넘기면 이전 단어를 소문자로 변환하지만 커서는 움직이지 않습니다.

**capitalize-word (M-c)**

현재(또는 다음) 단어의 머리글자를 대문자로 변환합니다. 음수 인수를 넘기면 이전 단어의 머리글자를 대문자로 변환하지만 커서는 움직이지 않습니다.

**overwrite-mode ()**

덮어쓰기 모드를 켜거나 끕니다. 명시적으로 양수 인수를 넘기면 덮어쓰기 모드로 변경합니다. 양수가 아닌 인수를 넘기면 삽입 모드로 변경합니다. 명령어는 `emacs` 모드에서만 동작합니다. `vi` 모드는 다른 방식으로 덮어쓰기 모드를 사용합니다. 각 `readline()` 호출은 삽입 모드에서 시작합니다.

덮어쓰기 모드에서는 `self-insert`에 바인딩된 문자는 포인트가 위치한 문자를 오른쪽으로 밀어내는 대신 자신으로 대체합니다. `backward-delete-char`에 바인딩된 문자는 포인트 앞의 문자를 스페이스로 대체합니다.

기본 설정에서 이 명령어에 바인딩된 키는 없습니다.
