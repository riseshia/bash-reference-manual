## 3.3 Shell Functions

셸 함수는 나중에 실행할 명령어들을 하나의 이름을 사용하여 그룹화하는 방법입니다. 이들은 "평범한" 명령어처럼 실행됩니다. 간단한 다른 명령어처럼 셸 함수의 이름이 사용되면 이와 관련된 명령어들이 실행됩니다. 셸 함수는 현재 셸 컨텍스트에서 실행됩니다. 이를 처리하기 위한 별도의 프로세스는 만들어지지 않습니다.

함수는 다음 문법을 사용해서 선언됩니다.

```sh
fname () compound-command [ redirections ]
```

또는

```sh
function fname [()] compound-command [ redirections ]
```

이는 *fname*이라는 이름의 셸 함수를 정의합니다. `function` 예약어는 생략가능합니다. 만약 `function` 예약어를 사용한다면, 이름 뒤의 소괄호를 생략할 수 있습니다. 함수의 본체는 복합 명령어([Compound Commands](chapter_3_2_5.html) 를 참조)인 *compound-command*입니다. 이 명령은 일반적으로 `{`와 `}`로 감싼 명령어 나열이며, 하나의 예외가 있습니다. 만약 `function` 예약어를 사용하고, 소괄호를 사용하지 않았다면 중괄호가 필수라는 점입니다. *compound-command*는 *fname*이 명령어의 이름으로 처리되었을 때 실행됩니다. 셸이 POSIX 모드에서 실행되는 경우, *fname*은 반드시 POSIX 에 준거한 이름을 가져야하며 특별한 빌트인 명령어들과 이름이 겹칠 수 없습니다. 기본 모드에서는 '$'를 포함하지 않고 따옴표로 감싸지 않은 이름이라면 함수 이름으로 사용할 수 있습니다. 셸 함수에 설정된 리다이렉션은 함수가 실행될 때 이용됩니다. 함수 정의는 `unset` 빌트인 명령어에 `-f` 옵션을 붙여서 삭제할 수 있습니다.

함수 정의 자체의 문법 에러가 발생하거나 같은 이름의 읽기 전용 함수가 이미 존재하지 않는 이상 종료 스테이터스는 0입니다. 실행했을 때 함수의 종료 스테이터스는 내부에서 마지막으로 실행된 명령의 종료 스테이터스입니다.

역사적인 이유로 대부분의 경우, 함수 본체를 감싸는 중괄호는 본체와 공백 또는 개행으로 분리되어야 합니다. 이는 중괄호가 예약어이므로 명령어 목록과 공백 문자 또는 다른 셸 메타문자와 구분되어 있어야만 인식 가능하기 때문입니다. 또한 중괄호를 사용할 때에는 명령어 목록은 반드시 세미콜론, '&', 개행으로 끝나야합니다.

함수가 실행되면 함수에 넘긴 인수는 실행 중에는 위치 매개변수가 됩니다. 위치 매개변수의 개수에 따라 전개되는 특별한 매개변수 '#'은 위치 매개변수의 변경에 따라서 갱신됩니다. 특별한 매개변수인 '0'는 변경되지 않습니다. `FUNCNAME` 변수의 첫번째 요소는 함수가 실행중인 동안 해당 함수의 이름을 반환합니다.

함수와 그 호출자의 셸 실행 환경은 다음 몇몇 예외를 제외하고 동일합니다: `DEBUG`와 `RETURN` 트랩은 `declare` 빌트인 명령어를 사용해 `trace` 속성을 부여하거나 `set` 빌트인 명령어를 통해 `-o functrace` 옵션을 켜지 않았다면, 상속되지 않습니다. 이 두 경우에서는 모든 함수가 `DEBUG`, `RETURN` 트랩을 상속합니다. 그리고 ERR 트랩은 `-o errtrace` 셸 옵션을 켜지 않았다면 상속되지 않습니다. `trap` 빌트인 명령어에 대해서는 [Bourne Shell Builtins](chapter_4_1.html)를 참조하세요.

`FUNCNEST` 변수는 0보다 큰 숫자를 설정했을 경우,  함수의 최대 중첩 횟수를 정의합니다. 이 상한을 초과하는 함수 호출은 명령어 전체를 중지시킵니다.

빌트인 명령어 `return`이 함수에서 실행되면, 함수의 실행은 즉시 완료되고, 함수 호출 다음에 오는 명령어로부터 실행을 재개합니다. `RETURN` 트랩에 연결된 명령어들은 실행을 재개하기 전에 실행됩니다. 함수가 완료될 때, 위치 매개변수와 매개변수 '#'의 값들은 함수 실행 직전에 가지고 있던 값으로 복원됩니다. 만약 `return`에 숫자 인수를 넘기면 이는 함수의 종료 스테이터스로 취급됩니다. 그렇지 않은 경우, 함수의 종료 스테이터스는 `return` 직전에 실행한 마지막 명령어의 종료 스테이터스가 됩니다.

`local` 빌트인 명령어를 사용하면 지역변수를 선언할 수 있습니다. 이 변수들은 선언된 함수와 함수가 호출한 명령어에서만 보입니다. 이는 다른 함수를 호출하는 셸 함수에서 특히 중요합니다.

지역 변수는 이전 스코프에서 선언한 같은 이름의 변수를 가립니다. 예를 들어, 함수에서 선언한 지역 변수가 같은 이름을 가진 전역 변수를 감춥니다. 참조와 대입은 지역 변수에 대해서 이루어지며, 전역 변수는 변경되지 않습니다. 함수가 종료되면 전역 변수가 다시 사용가능해집니다.

셸은 함수에 존재하는 변수의 가시성을 제어하기 위해 다이나믹 스코핑을 사용합니다. 다이나믹 스코핑에서 어떤 함수에서 보이는 변수와 그 값의 목록은 해당 함수가 실행되기까지 실행된 함수들의 호출 결과로 구성됩니다. 함수가 볼 수 있는 변수의 값은 그 호출자의 값에 의존하며, 호출자는 전역 스코프이거나, 다른 셸 함수일 수 있습니다. 또한 지역 변수 선언이 감추거나, 함수가 종료되었을 때 복원되는 값이기도 합니다.

예를 들어 *var*라는 지역 변수가 *func1* 함수에 정의되어 있고, *func1*은  *func2*를 호출한 경우, *func2*에서 참조하는 *var*는  *func1*의 지역 변수로 참조되며, 전역 변수 *var*는 감춰집니다.

다음 스크립트는 이 동작을 설명합니다. 실행이 끝나면 스크립트는 다음을 출력합니다.

```sh
In func2, var = func1 local
```

```sh
func1()
{
    local var='func1 local'
    func2
}

func2()
{
    echo "In func2, var = $var"
}

var=global
func1
```

`unset` 빌트인 명령어도 마찬가지로 다이나믹 스코프를 사용합니다. 만약 현재 스코프에 지역 변수가 존재한다면, `unset`은 이를 제거합니다. 그렇지 않다면 `unset`은 위에서 설명했듯이 호출 스코프를 따라가서 발견한 변수를 참조합니다. 현재 지역 스코프의 변수가 제거되었다면, 변수가 리셋되거나 함수가 반환될 때까지 제거된 상태를 유지합니다. 그 이후 함수가 종료되면 이전 스코프에 있는 변수의 값이 보이게 됩니다. 만약 `unset`이 이전 스코프의 값을 제거했다면, 그 값으로 감춰져있던 변수의 값이(있었다면) 보이게 됩니다.

함수의 이름과 정의는 `declare(typeset)` 빌트인 명령어에 `-f` 옵션을 넘기는 것으로 나열할 수 있습니다. `-F` 옵션은 함수의 이름(그리고 `extdebug` 옵션이 켜져있다면 소스 파일과 줄번호도)만을 출력합니다. 함수들은 `export` 빌트인 명령어에 `-f` 옵션을 넘겨서 서브셸에 자동으로 넘기도록 만들 수 있습니다.

함수는 재귀적일 수 있습니다. `FUNCNEST` 변수는 함수 호출 스택의 깊이를 제한하기 위해 사용될 수 있습니다. 기본 설정은 제한이 없는 상태입니다.
