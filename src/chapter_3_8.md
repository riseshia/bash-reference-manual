## 3.8 Shell Scripts

셸 스크립트는 셸 명령어를 포함하고 있는 텍스트 파일입니다. Bash에서 첫번째 인수로 이러한 파일을 사용하는 경우, `-c`나 `-s` 옵션([Invoking Bash](chapter_6_1.html)를 참조)을 사용하지 않았다면 Bash는 파일으로부터 명령어를 읽고 실행한 뒤 종료합니다. 이 동작은 논-인터랙티브 셸을 생성합니다. 셸은 현재 디렉터리에서 파일을 탐색하며, 만약 발견하지 못했을 경우, `$PATH`의 디렉터리들을 확인합니다.

Bash가 셸 스크립트를 실행할 때, 특수 매개변수 `0`에는 셸의 이름 대신 파일명을 설정하며, 위치 매개변수에는 만약 존재한다면 나머지 인수들을 설정합니다. 추가 인수가 없을 경우, 기존의 위치 매개변수는 제거됩니다.

셸 스크립트는 `chmod` 명령어를 사용해 실행 비트를 변경하여 실행 가능하도록 변경할 수 있습니다. Bash가 명령어를 `$PATH`에서 찾는 동안 그러한 파일을 발견하는 경우, 서브셸을 생성하고 실행합니다. 다시 말해 파일명이 실행가능한 셸 스크립트라면, 이 명령어 실행은 

```sh
filename arguments
```

다음과 동등합니다.

```sh
bash filename arguments
```

이 서브셸은 스크립트를 해석하기 위해 새로운 셸이 호출된 것 처럼 동작하기 위해 자신을 재초기화합니다. 예외사항으로 이 때 부모가 기억하고 있는 명령어의 위치 정보([Bourne Shell Builtins](chapter_4_1.html)의 `hash` 설명을 참조)는 자식에서도 그대로 유지됩니다.

대부분의 유닉스 버전에서는 이를 운영체제의 명령어 실행 구조의 일부로 구현합니다. 명령어의 첫번째 줄이 `#!`라는 문자들로 시작하는 경우, 해당 줄의 나머지 부분은 프로그램을 해석할 인터프리터와 (운영체제에 의존하는) 하나 이상의 인터프리터 옵션을 지정합니다. 그러므로 Bash, `awk`, Perl 또는 그 이외의 인터프리터를 지정하고, 해당 언어로 스크립트의 나머지 부분을 작성할 수 있습니다.

인터프리터의 인수는 스크립트 파일의 첫번째 줄의 인터프리터 이름 뒤에 오는 하나 이상의 인수로 구성됩니다. 이 뒤에는 스크립트 파일명과 스크립트 자신이 사용하는 나머지 인수가 올 수 있습니다. 인터프리터 줄이 어떻게 인터프리터 이름과 인수의 집합으로 분리되는지에 대한 상세한 방식은 시스템마다 다양합니다. Bash는 이 동작을 운영체제에서 실행하도록 두며, 직접 처리하지 않습니다. 몇몇 오래된 유닉스 버전에서는 인터프리터 이름과 인수의 길이를 32글자로 제한하고 있으며 하나의 인수만 사용 가능합니다. 그러므로 2개 이상의 인수를 사용하는 스크립트가 범용적일거라고 생각해서는 안됩니다.

Bash 스크립트를 해석할 때 다른 셸에서 실행되더라도 Bash를 사용하도록 만들기 위해 `#! /bin/bash`(Bash가 `/bin`에 설치되어있다고 가정)로 시작하는 경우가 많습니다. 다른 디렉터리에 설치되어있다고 하더라도 `bash`를 찾아서 실행하기 위해 `env`를 사용하는 방식도 일반적입니다. 예를 들어 `#!/usr/bin/env bash`는 `$PATH`의 디렉토리 목록에서 찾은 첫 번째 `bash`를 사용합니다.
