### 8.3.1 Readline Init File Syntax
Readline 초기화 파일에서는 몇몇 기본적인 구조만 사용할 수 있습니다. 빈 줄은 무시합니다. '#'로 시작하는 줄은 코멘트입니다. '$'로 시작하는 줄은 조건부 구조([Conditional Init Constructs](chapter_8_3_2.html)를 참조)를 나타냅니다. 나머지 줄은 변수 설정과 키 바인딩입니다.

**변수 설정**


초기화 파일에서 `set` 명령어를 사용해 Readline의 변수 값을 변경하여 Readline의 런타임 동작을 변경할 수 있습니다. 문법은 단순합니다.

```sh
set variable value
```

다음은 기본 Emacs 키 바인딩 대신 `vi` 줄 편집 명령어를 사용하도록 변경하는 예제입니다.

```sh
set editing-mode vi
```

변수의 이름과 값은 올바르다면 대소문자 관계 없이 인식됩니다. 인식하지 못한 변수 이름은 무시됩니다.

불린 변수(켜거나 끌 수 있는 변수)는 값이 널, 비어있거나, *on*(대소문자 구별 없음), 1일 때 켜짐입니다. 그 이외의 값은 모두 변수를 꺼짐으로 취급합니다.

`bind -V` 명령어는 현재 Readline 변수 이름과 값을 나열합니다. Bash Builtins를 참조하세요.

런타임 동작의 많은 부분은 다음 변수로 변경할 수 있습니다.
- **bell-style**

  Readline이 터미널 벨을 울리고 싶을 때의 동작을 제어합니다. '`none`'라면 Readline은 벨을 울리지 않습니다. '`visible`'이라면 보이는 벨이 사용 가능하다면, Readline은 이를 사용합니다. '`audible`'(기본값)이라면 Readline은 터미널 벨을 울리려고 시도합니다.
- **bind-tty-special-chars**

  'on'(기본값)이라면 Readline은 커널의 터미널 드라이버에 의해서 특별취급되는 제어 문자를 Readline에서 동등한 문자로 바인딩하려 합니다.
- **blink-matching-paren**

  'on'이라면 Readline은 닫는 소괄호를 삽입했을 때 여는 괄호가 있는 위치로 커서를 이동시키려 합니다. 기본값은 'off'입니다.
- **colored-completion-prefix**

  'on'이라면 완성을 나열할 때, Readline은 완성 후보 집합의 공통 접두사를 다른 색으로 출력합니다. 색 정의는 `LS_COLORS` 환경 변수의 값을 참조합니다. 기본값은 'off'입니다.
- **colored-stats**

  'on'이라면, Readline은 완성 후보를 출력할 때 각각의 파일 타입에 따라 다른 색을 사용합니다. 색 정의는 `LS_COLORS` 환경 변수의값을 참조합니다. 기본값은 'off'입니다.
- **comment-begin**

  `insert-comment` 명령어가 실행되었을 때 줄의 첫 머리에 추가할 문자열. 기본값은 "#"입니다.
- **completion-display-width**

  완성을 실행할 때 일치 후보를 출력할 때 사용할 화면의 열(column) 개수. 0보다 작은 값이나 터미널 화면 너비보다 큰 값은 무시됩니다. 0은 일치 결과를 한 줄 전체를 써서 보여줍니다. 기본값은 -1입니다.
- **completion-ignore-case**

  'on'이라면 Readline은 파일명 일치와 완성을 실행할 때 대소문자를 구분하지 않습니다. 기본값은 'off'입니다.
- **completion-map-case**

  'on'이고 *completion-ignore-case*가 켜져있다면 Readline은 대소문자를 구분하지 않는 파일명 일치와 완성에서 하이픈('-')과 밑줄('_')을 같은 것으로 취급합니다. 기본값은 'off'입니다.
- **completion-prefix-display-length**

  수정 없이 보여줄 완성 후보 리스트의 공통 접두어의 길이. 0보다 큰 값을 지정하면 완성 후보를 보여줄 때 이 값보다 큰 공통 접두사는 생략 부호로 대체됩니다.
- **completion-query-items**

  유저가 완성 후보를 보여달라고 요구할 때 이를 보여줄지 말지 결정할 완성 후보 개수의 상한. 완성 후보의 개수가 이 값보다 크거나 같으면 Readline은 리스트를 보고 싶은지 묻습니다. 이 값보다 적은 경우 단순히 출력됩니다. 이 변수는 0이상의 정수 값을 설정해야 합니다. 음수는 Readline이 묻지 않도록 만듭니다. 기본 제한은 100입니다.
- **convert-meta**

  'on'이라면 Readline은 8비트 집합으로 된 문자들을 8번째 비트를 제거하고 `ESC` 문자를 앞에 끼워 넣어 메타 키로 시작하는 키 나열로 변환합니다. 기본값은 'on'이지만 로케일이 8비트 문자를 포함한다면 'off'가 됩니다.
- **disable-completion**

  'on'이라면 Readline은 단어 완성을 금지합니다. 완성 문자는 `self-insert`에 매핑된 것처럼 줄에 삽입됩니다. 기본값은 'off'입니다.
- **echo-control-characters**

  'on'으로 설정할 때, 운영체제가 지원한다면 Readline은 키보드가 생성한 시그널에 대응하는 문자를 출력합니다. 기본값은 'on'입니다.
- **editing-mode**

  `editing-mode` 변수는 어떤 키 바인딩 집합을 사용할지 제어합니다. 기본 설정에서 Readline은 Emacs와 사용법이 매우 유사한 Emacs 편집 모드로 시작합니다. 이 변수에는 'emacs'나 'vi'를 설정할 수 있습니다.
- **emacs-mode-string**

  *show-mode-in-prompt* 변수가 켜져있다면 emacs 편집 모드가 활성화되어 있을 때 주 프롬프트의 마지막 줄 앞에 이 문자열이 출력됩니다. 값은 키 바인딩처럼 전개되므로 메타 키, Control 키로 시작하는 표준 집합과 백슬래시 이스케이프 나열을 사용할 수 있습니다. '\\1'과 '\\2'로 출력 불가 문자 나열의 시작과 끝을 이스케이프할 수 있으며, 이는 터미널 제어 나열을 모드 문자열에 끼워넣을 때에도 사용할 수 있습니다. 기본값은 '@'입니다.
- **enable-bracketed-paste**

  'on'으로 설정할 때, Readline은 터미널에서 편집 버퍼에 문자열을 붙여넣을 때 키보드로부터 각 문자를 입력한 것처럼 취급하는 대신, 하나의 문자열로써 다루도록 만듭니다. 이는 붙여넣은 문자들이 편집 명령어로 해석되는 것을 방지합니다. 기본값은 'on'입니다.
- **enable-keypad**

  'on'으로 설정할 때, Readline은 애플리케이션 키패드를 호출할 때 이를 활성화하려고 시도합니다. 몇몇 시스템은 화살표 키를 활성화하기 위해서 이 기능이 필요합니다. 기본값은 'off'입니다. 
- **enable-meta-key**

  'on'으로 설정할 때, Readline이 호출되었을 때 터미널이 지원하고 있다고 주장하는 메타 수식 키를 유효화하려고 시도합니다. 많은 터미널에서 메타 키는 8비트 문자를 전송할 때 사용합니다. 기본값은 'on'입니다.
- **expand-tilde**

  'on'이라면 Readline이 단어 완성을 시도할 때 물결줄표 전개가 실행됩니다. 기본값은 'off'입니다.
- **history-preserve-point**

  'on'이라면 이력 코드는 점(현재 커서 위치)을 `previous-history`나 `next-history`로 가져온 각 이력 줄의 같은 위치에 옮기려고 시도합니다. 기본값은 'off'입니다.
- **history-size**

  이력 리스트에 저장하고 있는 이력의 최대 개수를 설정합니다. 0을 설정하면 존재하는 모든 이력이 제거되고 새 이력은 저장되지 않습니다. 0보다 작은 값을 설정하면 무제한으로 저장합니다. 이력 리스트에 저장할 최대 개수의 기본 설정은 무제한입니다. *history-size*에 숫자가 아닌 값을 설정하려고 시도하면 500이 설정됩니다.
- **horizontal-scroll-mode**

  이 변수는 'on' 또는 'off'를 설정할 수 있습니다. 'on'은 편집중인 줄의 텍스트가 화면의 너비보다 길어졌을 때 이를 새 줄로 감싸기보다 한 줄로 두고 수직 스크롤을 사용할 수 있도록 합니다. 이 변수는 터미널 높이가 1일 때 자동으로 'on'으로 변경됩니다. 이 변수의 기본값은 'off'입니다.
- **input-meta**

  'on'이라면, Readline은 터미널이 이를 지원하는지 아닌지 관계없이 8비트 입력(문자를 읽을 때 8비트째를 지우지 않습니다)을 활성화합니다. 기본값은 'off'이지만 로케일이 8비트 문자를 포함한다면 Readline은 'on'으로 설정합니다. `meta-flag`는 이 변수와 동의어입니다.
- **isearch-terminators**

  증분 검색을 종료하고 문자열을 명령어로 실행하지 않는 문자들의 나열(Searching을 참조). 이 변수에 값이 설정되어있지 않다면 `ESC`와 `C-J`로 증분 검색을 종료할 수 있습니다.
- **keymap**

  Readline의 명령어 키 바인딩의 키맵을 설정합니다. 내장된 `keymap` 이름은 `emacs`, `emacs-standard`, `emacs-meta`, `emacs-ctlx`, `vi`, `vi-move`, `vi-command`, `vi-insert`입니다. `vi`는 `vi-command`와 동일합니다(`vi-move`도 동의어입니다). `emacs`는 `emacs-standard`와 동일합니다. 애플리케이션은 이름을 추가할 수 있습니다. 기본값은 `emacs`입니다. `editing-mode` 변수의 값은 기본 키맵에 영향을 줍니다.
- **keyseq-timeout**

  Readline이 여러 가능성을 가지는 키 나열(지금까지 읽은 입력으로 완전한 키 나열을 만들거나 더 긴 키 나열을 완성하기 위해서 추가 입력을 받거나)을 읽을 때 다음 문자를 기다리는 시간을 지정합니다. 지정된 시간안에 입력을 받지 못했다면, Readline은 짧지만 완전한 키 나열을 사용합니다. Readline은 현재 입력 소스(기본값은 `rl_instream`)에서 새 입력을 얻을 수 있는지 없는지 판단하기 위해서 이 값을 사용합니다. 값은 밀리초로 지정되므로, 1000을 지정하면 Readline은 추가 입력을 1초간 기다린다는 의미가 됩니다. 이 변수가 0 또는 0보다 작은 값, 숫자가 아닌 값이라면 Readline은 다른 키 입력을 기다려서 키 나열을 완전한지 아닌지 판단합니다. 기본값은 500입니다.
- **mark-directories**

  'on'이라면 완성된 디렉터리 이름에 슬래시가 추가됩니다. 기본값은 'on'입니다.
- **mark-modified-lines**

  이 변수가 'on'이라면 Readline은 수정된 이력 줄의 첫머리에 별표('*')를 출력합니다. 이 변수의 기본값은 'off'입니다.
- **mark-symlinked-directories**

  'on'이라면, 이름 완성에서 디렉터리를 가리키는 심볼릭 링크를 얻었을 때 슬래시를 추가합니다(*mark-directories*의 값이 적용됩니다). 기본값은 'off'입니다.
- **match-hidden-files**

  이 변수가 'on'이라면 Readline에서는 파일명 완성을 실행할 때 '.'으로 시작하는 이름(숨긴 파일)에도 일치합니다. 'off'라면 유저가 파일명을 완성하기 위해서는 '.'를 입력해야 합니다. 이 변수의 기본값은 'on'입니다.
- **menu-complete-display-prefix**

  'on'이라면 메뉴 완성은 리스트를 한바퀴 돌기 전에 완성 후보 리스트(비어있을 수도 있습니다)의 공통 접두사를 보여줍니다. 기본값은 'off'입니다.
- **output-meta**

  'on'이라면 Readline은 8비트 집합인 문자를 메타 키를 앞에 끼워넣고 이스케이프한 나열을 출력하는 대신 직접 출력합니다. 기본값은 'off'입니다만 로케일이 8비트 문자를 포함하고 있다면 Readline은 'on'을 설정합니다.
- **page-completions**

  'on'이라면 Readline은 내부의 'more-like' 페이저를 사용해서 완성 후보를 단번에 화면 전체에 보여줍니다. 이 변수의 기본값은 'on'입니다.
- **print-completions-horizontally**

  'on'이라면 Readline은 일치한 완성 후보를 화면 아래 대신에 알파벳 순으로 정렬해 수평으로 보여줍니다. 기본값은 'off'입니다.
- **revert-all-at-newline**

  'on'이라면 Readline은 `accept-line`이 실행되었을 때 반환하기 전에 이력 줄에 대한 변경을 모두 되돌립니다. 기본 설정에서 이력 줄에 대한 변경은 개별적으로 되돌리기가 가능하도록 유지하며 이는 `readline` 호출간에서도 호환됩니다. 기본값은 `off`입니다.
- **show-all-if-ambiguous**

  이는 완성 함수의 기본 동작을 변경합니다. 'on'이라면 하나 이상의 완성 후보가 있는 단어는 벨을 울리지 않고 즉시 나열됩니다. 기본값은 `off`입니다.
- **show-all-if-unmodified**

  이는 완성 함수의 기본 동작을 *show-all-if-ambiguous*와 비슷한 방식으로 변경합니다. 'on'일때 하나 이상의 완성 후보가 있고 가능한 부분 완성(공통 접두사를 공유하지 않는 완성 후보)이 없다면 밸을 울리지 않고 즉시 나열됩니다. 기본값은 'off'입니다.
- **show-mode-in-prompt**

  'on'이라면 프롬프트의 첫머리에 편집 모드를 알려주는 문자열을 추가합니다. emacs, vi command, vi insertion. 모드 문자열은 유저가 변경할 수 있습니다(e.g., *emacs-mode-string*). 기본값은 'off'입니다.
- **skip-completed-text**

  'on'이라면, 이는 줄에 일치한 문자열을 삽입하는 기본 완성 동작을 변경합니다. 단어의 중간에서 완성을 실행했을 때에만 유효합니다. 켜져있다면 Readline은 단어를 완성한 뒤 커서가 있는 위치에 일치한 문자를 삽입하지 않습니다. 그러므로 커서 뒤에 오는 단어의 일부가 중복되지 않습니다. 예를 들어 이 설정이 켜져있다면 'Makefile'의 'e'에 커서가 있는 상태에서 완성을 시도하면 완성 후보는 하나뿐이라고 가정하고 'Makefilefile'이 되지 않고 'Makefile'로 대체합니다. 기본값은 'off'입니다.
- **vi-cmd-mode-string**

  *show-mode-in-prompt* 변수가 켜져있다면, vi 편집 모드가 활성화되어 있고 명령어 모드인 경우 주 프롬프트의 마지막 문자열 앞에 이 문자열이 즉시 출력됩니다. 값은 키 바인딩처럼 전개되므로 메타 키, Control 키로 시작하는 표준 집합과 백슬래시 이스케이프 나열을 사용할 수 있습니다. '\\1'과 '\\2'로 출력 불가 문자 나열의 시작과 끝을 이스케이프할 수 있으며, 이는 터미널 제어 나열을 모드 문자열에 끼워넣을 때에도 사용할 수 있습니다. 기본값은 '(cmd)'입니다.
- **vi-ins-mode-string**

  *show-mode-in-prompt* 변수가 켜져있다면, vi 편집 모드가 활성화되어 있고 삽입 모드인 경우 주 프롬프트의 마지막 문자열 앞에 이 문자열이 즉시 출력됩니다. 값은 키 바인딩처럼 전개되므로 메타 키, Control 키로 시작하는 표준 집합과 백슬래시 이스케이프 나열을 사용할 수 있습니다. '\\1'과 '\\2'로 출력 불가 문자 나열의 시작과 끝을 이스케이프할 수 있으며, 이는 터미널 제어 나열을 모드 문자열에 끼워넣을 때에도 사용할 수 있습니다. 기본값은 '(ins)'입니다.
- **visible-stats**

  'on'이라면 완성 후보를 나열할 때 파일 타입을 나타내는 문자가 추가됩니다. 기본값은 'off'입니다.

**키 바인딩**

초기화 파일에서 키 바인딩을 제어하는 문법은 간단합니다. 첫번째로 변경하고 싶은 명령어의 이름을 찾으세요. 다음 섹션에 명령어 이름과 기본 키 바인딩이 있는 경우에는 그 값, 그리고 각 명령어가 무엇을 하는지 간략한 설명이 포함된 리스트가 있습니다.

명령어의 이름을 확인했다면, 초기화 파일에 바인딩하고 싶은 키의 이름을 적고 콜론을 적은 뒤 명령어의 이름을 적으세요. 키 이름과 콜론 사이에 공백을 넣어서는 안됩니다. 콜론이 키 이름의 일부로 해석되기 때문입니다. 키의 이름은 여러 방법으로 표현할 수 있으며 가장 편한 방식을 사용하세요.

Readline은 명령어 이름 뿐만 아니라, 키를 입력했을 때 삽입할 문자열과 바인딩할 수도 있습니다(*매크로*).

`bind -p` 명령어는 Readline 함수 이름과 바인딩을 초기화 파일에서 사용할 수 있는 형식으로 출력합니다. Bash Builtins를 참조하세요.

***keyname*: *function-name* 또는 *macro***

*keyname*은 영어로 된 키의 이름입니다. 다음은 예시입니다.

```sh
Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "> output"
```

이 예제에서 *C-u*는 *universal-argument* 함수에 바인딩되어 있으며, *M-DEL*은 `backward-kill-word` 함수에 바인딩 되어있고, *C-o*는 우측항('> output'이라는 텍스트를 줄에 삽입합니다.)과 바인딩되어 있습니다.

다음 심볼릭 문자 이름은 키 바인딩 문법을 처리하는 중에 인식됩니다. *DEL*, *ESC*, *ESCAPE*, *LFD*, *NEWLINE*, *RET*, *RETURN*, *REBOUT*, *SPACE*, *SPC*, *TAB*.

**"*keyseq*": *function-name* 또는 *macro***

*keyseq*은 위에서 설명한 *keyname*과 다르게 키 나열을 큰따옴표로 감싸서 키 나열 전체를 지정할 수 있습니다. 다음 예제처럼 몇몇 GNU Emacs 스타일의 키 이스케이프를 사용할 수 있습니다만, 특수 문자 이름은 인식되지 않습니다.

```sh
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
```

이 예제에서 *C-u*는 (첫번째 예제처럼) *universal-argument* 함수에 바인딩되어 있으며, '*C-x C-r*'은 `re-read-init-file` 함수에 바인딩 되어있고, '`ESC [ 1 1 ~`'는 '`Function Key 1`'이라는 문자열을 삽입하도록 바인딩되어 있습니다.

키 나열을 지정할 때 다음 GNU Emacs 스타일의 이스케이프 나열을 사용할 수 있습니다.

- **\C-**

  Control 접두사
- **\M-**

  메타 접두사
- **\e**

  이스케이프 문자
- **\\\\**

  백슬래시
- **\\"**

  ", 큰따옴표
- **\\'**

  ', 작은 따옴표

GNU Emacs 스타일의 이스케이프 나열뿐 아니라 다음의 백슬래시 이스케이프 집합도 사용할 수 있습니다.

- **\\a**

  경고(벨)
- **\\b**

  백스페이스
- **\\d**

  삭제
- **\\f**

  폼 피드
- **\\n**

  개행
- **\\r**

  캐리지 리턴
- **\\t**

  수평 탭
- **\\v**

  수직 탭
- **\\*nnn***

  8진수 *nnn*(3문자까지 가능)으로 표현한 8비트 문자
- **\\x*HH***

  16진수 *HH*(2문자까지 가능)으로 표현한 8비트 문자

매크로의 텍스트에 들어갈 때, 작은따옴표나 큰따옴표는 반드시 매크로 정의를 가리켜야 합니다. 따옴표를 벗긴 텍스트는 함수 이름이라고 가정됩니다. 매크로 본체에서는 위에서 설명된 백슬래시 이스케이프가 전개됩니다. 백슬래시는 매크로 텍스트에서 '"'와 '''를 포함한 다른 문자를 감쌀 수 있습니다. 예를 들어 다음 바인딩은 '*C-x* \'로 '\' 하나를 줄에 삽입합니다.

```sh
"\C-x\\": "\\"
```
