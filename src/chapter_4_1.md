## 4.1 Bourne Shell Builtins
다음 셸 빌트인 명령어들은 Bourne Shell로부터 계승한 것들입니다. 이 명령어들은 POSIX 표준에 기술된 대로 구현되어 있습니다.

**:** (콜론)

```sh
: [arguments]
```
인수를 전개하고, 리다이렉션을 설정하는 이외에는 아무것도 하지 않습니다. 반환 스테이터스는 0입니다.

**.** (마침표)

```sh
. filename [arguments]
```
현재 셸 컨텍스트에서 *filename* 인수로부터 명령어를 읽고 실행합니다. *filename*에 슬래시가 포함되어 있지 않다면, `PATH` 변수를 사용해서 *filename*을 찾습니다. 만약 Bash가 POSIX 모드가 아니고, `$PATH`에서 *filename*을 발견하지 못했다면 현재 디렉터리를 검색합니다. `arguments`가 제공되었다면, 이는 `filename`을 실행할 때 위치 매개변수가 됩니다. 그렇지 않다면 위치 매개변수는 변경되지 않습니다. `set` 빌트인으로 `-T` 옵션이 켜진 상태라면, `source`는 `DEBUG`에 등록된 트랩을 상속합니다. `-T` 옵션이 꺼진 상태라면 `DEBUG` 트랩의 문자열은 저장되지 않고, `source` 호출 전후로 복구합니다. `source`는 실행하는 동안 `DEBUG` 트랩을 제거합니다. `-T` 옵션이 꺼진 상태이고 `source`의 대상 파일이 `DEBUG` 트랩을 변경했다면, 새 값은 `source`가 종료될 때까지 유지됩니다. 반환 스테이터스는 마지막으로 실행된 명령어의 종료 스테이터스이며, 실행된 명령이 없다면 0입니다. 만약 *filename*을 찾을 수 없거나 읽을 수 없다면 종료 스테이터스는 0이 아닌 값입니다. 이 빌트인 명령어는 `source`와 동일합니다.

**break**

```sh
break [n]
```
`for`, `while`, `until`, `select` 루프를 종료합니다. 만약 *n*을 넘겼다면, 감싸고 있는 *n*번째 루프가 종료됩니다. *n*은 반드시 1 이상이어야 합니다. 종료 스테이터스는 *n*이 1보다 작지 않다면 0입니다.

**cd**

```sh
cd [-L|[-P [-e]] [-@]] [directory]
```
현재 작업 디렉터리를 *directory*로 변경합니다. *directory*가 제공되지 않았다면, 셸 변수 `HOME`의 값이 사용됩니다. *directory* 뒤에 따라오는 모든 추가 인수는 무시됩니다. 셸 변수 `CDPATH`가 존재한다면 검색용 경로로 사용합니다. `CDPATH`의 각 디렉터리를 검색하며, 이를 대체할 디렉터리 이름은 `CDPATH`에서 콜론(':')으로 구분되어있습니다. 만약 *directory*가 슬래시로 시작한다면 `CDPATH`는 사용되지 않습니다.

`-P` 옵션은 심볼릭 링크를 따라가지 말라는 의미입니다. `cd`가 *directory*를 순회하고 *directory*의 '..'를 처리하기 전에 심볼릭 링크를 해결합니다. (역주: 심볼릭 링크를 따라가지 않고, 실제 디렉터리 구조를 사용합니다.)

기본 설정 상태나 `-L` 옵션이 넘겨진 경우, 디렉터리의 심볼릭 링크는 `cd`가 디렉터리의 '..'의 인스턴스를 처리하고 나서 해결됩니다.

*directory*에서 '..'가 포함되어 있을 경우, 이는 직전의 경로 부분을 즉시 제거하고 슬래시로 만들거나, *directory*의 시작 부분으로 돌아가도록 처리됩니다.

만약 `-e` 옵션이 `-P`와 함께 사용되고 성공적으로 디렉터리 변경이 이루어진 뒤에 현재 작업 디렉터리를 성공적으로 결정하지 못하면 `cd`는 성공하지 못했다는 스테이터스를 반환합니다.

시스템이 지원한다면, `-@` 옵션은 디렉터리로서의 파일과 연관된 확장된 속성을 표현할 수 있습니다.
만약 *directory*가 '-'라면 이는 디렉터리 변경이 시도되기 전에 `$OLDPWD`로 변환됩니다.

`CDPATH`에 있는 공백이 아닌 디렉터리 이름이 사용되거나 '-'가 첫번째 인수인 경우, 디렉터리 변경은 성공하며, 새 작업 디렉터리의 절대 경로가 표준 출력으로 출력됩니다.

만약 현재 디렉터리가 변경에 성공했다면 반환 스테이터스는 0이며, 실패했다면 0이 아닌 값입니다.

**continue**

```sh
continue [n]
```
감싸고 있는 `for`, `while`, `until`, `select` 루프의 다음 반복을 시작합니다. *n*이 있다면, *n*번째로 감싸고 있는 루프의 실행의 다음 반복이 시작됩니다. *n*은 1 이상이어야 합니다. *n*이 1보다 작지 않다면 종료 스테이터스는 0입니다.

**eval**

```sh
eval [arguments]
```
인수는 하나의 명령어로 결합되어 실행됩니다. 그리고 그 종료 스테이터스는 `eval`의 종료 스테이터스가 됩니다. 만약 인수가 없거나 공백이 넘겨지는 경우 반환 스테이터스는 0입니다.

**exec**

```sh
exec [-cl] [-a name] [command [arguments]]
```
*command*를 넘긴 경우, 새 프로세스를 생성하지 않고, 현재의 셸을 덮어씁니다. `-l` 옵션을 사용하는 경우, 셸은 *command*에 넘긴 0번째 인수의 앞부분에 하이픈을 추가합니다. 이는 `login` 프로그램이 하는 것과 동일합니다. `-c` 옵션은 *command*를 빈 환경에서 실행합니다. `-a`옵션은 셸이 *command*의 0번째 인수로 *name*을 넘깁니다. *command*가 어떤 이유로 실행할 수 없고, `execfail` 셸 옵션이 켜져있지 않다면 논-인터랙티브 셸은 종료와 함께 실패를 반환합니다. 인터랙티브 셸은 파일을 실행할 수 없다면 실패를 반환합니다. 서브셸은 `exec`가 실패하면 무조건 종료합니다. 만약 *command*가 지정되지 않았다면, 리다이렉션을 현재 셸 환경에 적용합니다. 만약 리다이렉션 에러가 발생하지 않았다면 반환 스테이터스는 0입니다. 그렇지 않으면 반환 스테이터스는 0이 아닌 값입니다.

**exit**

```sh
exit [n]
```
셸을 종료하고, 셸의 부모에게 종료 스테이터스로 *n*을 넘깁니다. 만약 *n*을 생략했다면 종료 스테이터스는 마지막에 실행한 명령어의 종료 스테이터스입니다. 셸이 종료되기 전에 `EXIT`에 설정된 트랩이 실행됩니다.

**export**

```sh
export [-fn] [-p] [name[=value]]
```
각 *name*을 환경의 자식 프로세스에 익스포트하도록 설정합니다. `-f` 옵션을 사용하면 *name*으로 셸 함수를 지정할 수 있습니다. 그렇지 않다면 이름은 셸 변수를 지정합니다. `-n` 옵션을 사용하면 각 *name*을 익스포트 하지 않도록 설정합니다. *name*을 넘기지 않거나 `-p` 옵션을 사용했다면 익스포트 대상인 모든 변수를 출력합니다. `-p` 옵션의 출력 형식은 입력으로 재사용할 수 있습니다. 변수 이름 뒤에 *=value*를 덧붙이면 변수의 값을 *value*로 설정합니다. 

잘못된 옵션, 유효하지 않은 셸 변수 이름, `-f` 옵션을 넘겼을 때 셸 함수가 아닌 이름을 사용하지 않는다면 반환 스테이터스는 0입니다.

**getopts**

```sh
getopts optstring name [arg …]
```
`getopts`는 셸 스크립트가 위치 매개변수를 구문 해석하기 위해서 사용합니다. *optstring*은 인식해야할 옵션 문자를 포함합니다. 옵션 문자 뒤에 콜론이 있다면 인수값을 기대하며, 인수를 넘길 때에는 스페이스로 구분되어야 합니다. 콜론(':')과 물음표('?')는 옵션 문자로 사용할 수 없습니다. 호출될 때마다, `getopts`는 셸 변수 *name*(*name*이 존재하지 않는다면 초기화합니다)에 다음 옵션과 `OPTIND` 변수에 다음에 처리할 인수의 인덱스를 저장합니다. `OPTIND`는 셸이나 셸 스크립트가 호출될 때마다 초기화됩니다. 옵션이 인수를 요구할 때, `getopts`는 인수를 `OPTARG` 변수에 저장합니다. 셸은 `OPTIND`를 자동으로 리셋하지 않습니다. 동일한 셸 호출 내에서 새로운 매개변수 집합을 사용하여 `getopts`를 여러번 호출할 때에는 직접 리셋해야 합니다.

옵션의 마지막에 도착했을 때 `getopts`는 0보다 큰 반환 값으로 종료합니다. `OPTIND`는 옵션 인수가 아닌 첫번째 인덱스 값이 되며, *name*은 '?'가 됩니다.

`getopts`는 일반적으로 위치 매개변수를 구문 해석하지만, 만약 추가 인수가 *arg* 값으로 넘겨진 경우, `getopts`는 그 값을 구문 해석합니다.

`getopts`는 에러를 두 가지 방식으로 보고합니다. *optstring*의 첫번째 문자가 콜론이라면 에러 보고를 무시합니다. 일반적인 동작에서는 유효하지 않은 옵션을 사용하거나 옵션 인수가 부족한 경우 진단 메시지가 출력됩니다. 만약 `OPTERR` 변수가 0이라면 `optstring`의 첫번째 문자가 콜론이라도 에러 메시지는 출력되지 않습니다.

만약 유효하지 않은 옵션이 있다면, `getopts`는 *name*에 '?'를 설정하며 에러 보고를 무시하지 않았다면 에러 메시지를 출력하고 `OPTARG` 값을 제거합니다. `getopts`가 에러 보고를 무시하고 있다면 발견된 옵션 문자는 `OPTARG`에 설정되며, 진단 메시지는 출력되지 않습니다.

만약 필수 인수를 찾을 수 없고, `getopts`가 에러 보고를 무시하지 않았다면, *name*에는 물음표('?')가 설정되고 `OPTARG`의 값이 제거되며, 진단 메시지가 출력됩니다. 만약 `getopts`가 에러 보고를 무시하고 있다면 *name*에는 콜론(':')이 설정되고, `OPTARG`에는 발견된 옵션 문자가 설정됩니다.

**hash**

```sh
hash [-r] [-p filename] [-dt] [name]
```
`hash`를 호출할 때마다 이후의 호출에서 검색을 할 필요가 없도록 *name* 인수에 지정된 명령어의 전체 경로를 기억합니다. 명령어는 `$PATH`에 나열되어 있는 디렉터리들에서 검색됩니다. 이전에 기억하고 있던 경로는 전부 버려집니다. `-p` 옵션은 경로 검색을 금지하며, *filename*은 *name*의 장소로 사용됩니다. `-r` 옵션은 셸이 기억하고 있는 모든 위치 정보를 잊도록 합니다. `-d` 옵션은 셸이 기억하고 있는 각 *name*의 위치 정보를 지웁니다. `-t` 옵션을 넘기면 *name*에 대응하는 전체 경로가 출력됩니다. `-t` 옵션에 여러 개의 *name* 인수를 넘겼다면 해싱된 전체 경로명 앞에 *name*을 함께 출력합니다. `-l` 옵션은 입력으로 재이용 가능한 형식으로 결과를 출력합니다. 만약 인수가 주어지지 않거나 `-l` 옵션만 넘겨졌다면 기억하고 있는 명령어에 대한 정보가 출력됩니다. *name*을 발견할 수 없거나, 유효하지 않은 옵션을 넘기지 않았다면 반환 스테이터스는 0입니다.

**pwd**

```sh
pwd [-LP]
```
현재 작업 디렉터리의 절대경로명을 출력합니다. `-P` 옵션은 출력할 경로명에 심볼릭 링크를 포함하지 않도록 합니다. `-L` 옵션은 출력할 경로명에 심볼릭 링크를 포함합니다. 현재 디렉터리의 이름을 찾는 중에 에러가 발생하거나 잘못된 옵션을 넘기지 않는 이상 종료 스테이터스는 0입니다.

**readonly**

```sh
readonly [-aAf] [-p] [name[=value]] …
```
각 *name*을 읽기 전용으로 변경합니다. 이 이름들의 값은 그 이후의 대입을 통해 변경될 수 없습니다. `-f` 옵션은 각 *name*이 셸 함수를 참조합니다. `-a` 옵션은 각 *name*이 순차 배열 변수를 참조합니다. `-A` 옵션은 각 *name*이 연상 배열 변수를 참조합니다. 만약 두 옵션을 모두 사용하는 경우, `-A`를 우선합니다. 만약 *name* 인수가 없거나 `-p` 옵션이 존재하는 경우, 모든 읽기 전용 이름이 출력됩니다. 다른 옵션은 읽기 전용 이름의 집합의 부분 집합을 출력하도록 제한하는데 쓰입니다. `-p` 옵션은 입력으로 재사용가능한 형태로 결과를 출력합니다. 만약 변수의 이름 뒤에 =*value*가 따라오는 경우, 변수의 값이 *value*로 설정됩니다. 잘못된 옵션을 사용하거나 *name* 인수 중에 유효하지 않은 변수명 또는 함수명이 존재하는 경우, 또는 `-f` 옵션이 셸 함수가 아닌 이름과 함께 사용된 경우를 제외하면 종료 스테이터스는 0입니다. 

**return**

```sh
return [n]
```
셸 함수가 실행을 중지하고 값 *n* 을 호출자에게 반환하도록 만듭니다. *n*을 넘기지 않았다면, 종료 값은 함수에서 마지막으로 실행된 명령어의 종료 스테이터스입니다. 만약 `return`이 트랩 핸들러에 의해서 실행되었다면, 스테이터스를 결정하는 데에 쓰이는 마지막 명령어는 트랩 핸들러 직전에 실행된 마지막 명령어입니다. `return`이 `DEBUG` 트랩 도중에 실행되었다면, 스테이터스를 결정하는 데에 쓰이는 마지막 명령어는 `return`이 호출되기 전에 트랩 핸들러에 의해서 실행된 마지막 명령어입니다. `return`은 `.`(`source`) 빌트인 명령어로 실행된 스크립트의 실행을 종료할 때도 사용됩니다. 이때 *n*이나 스크립트 내에서 실행된 마지막 명령어의 종료 스테이터스를 스크립트의 종료 스테이터스로 반환합니다. *n*을 넘겼다면 종료값은 넘긴 값의 가장 작은 8비트의 값입니다. `RETURN` 트랩과 연결된 명령어는 함수나 스크립트의 실행이 재개되기 전에 실행됩니다. `return`이 숫자가 아닌 인수를 넘겨받거나, 함수 바깥에서 실행하거나, `.`나 `source`에 의한 스크립트 실행중이 아닐때 실행되는 경우의 종료 스테이터스는 0 이외의 값입니다.

**shift**

```sh
shift [n]
```
위치 매개변수의 값을 왼쪽으로 *n*만큼 밀어냅니다. *n*+1 ... $#의 위치 매개변수는 $1 ... $#-*n*으로 재명명됩니다. $#부터 $#-*n*+1의 매개변수는 제거됩니다.*n*은 $#보다 작거나 같은 양의 숫자이어야 합니다. 만약 *n*이 0이나 $#보다 큰 값이라면, 위치 매개변수는 변경되지 않습니다. *n*을 넘기지 않았다면 1을 넘긴 것처럼 동작합니다. *n*이 $#보다 크거나 0보다 작지 않다면, 종료 스테이터스는 0입니다. 그 이외의 경우에는 0이 아닌 값입니다.

**test**

**[**

```sh
test expr
```
조건 표현식 *expr*을 평가하고 0(참) 또는 1(거짓)의 스테이터스를 반환합니다. 각 연산자와 피연산자는 별도의 인수여야 합니다. 표현식은 [Bash Conditional Expressions](chapter_6_4.html)에서 설명하는 연산자, 피연산자의 쌍으로 구성됩니다. `test`는 어떤 옵션도 없으며, 옵션의 끝을 나타내는 `--`의 인수도 무시합니다.

`[` 형식을 사용하는 경우, 명령어의 마지막 인수는 반드시 `]`이어야 합니다.

표현식은 다음 연산자를 사용해 결합될 수 있습니다. 우선순위는 높은 것부터 낮은 것 순으로 정렬되어 있습니다. 평가는 아래에서 설명할 인수의 개수에 의존합니다. 연산자의 우선순위는 5개 이상의 인수를 넘긴 경우 사용됩니다.

- **! *expr***

  *expr*이 거짓이라면 참입니다.
- **( *expr* )**

  *expr*의 값을 반환합니다. 이는 연산자의 우선순위를 덮어쓰기 위해서 사용합니다.
- ***expr1* -a *expr2***

  *expr1*과 *expr2*가 모두 참이라면 참입니다.
- ***expr1* -o *expr2***

  *expr1*와 *expr2* 중 하나라도 참이라면 참입니다.

`test`와 `[` 빌트인 명령어는 인수의 개수에 기초한 규칙 집합을 사용해 조건 표현식을 평가합니다.

  - **0개의 인수**

  표현식은 거짓입니다.
  - **1개의 인수**

  표현식은 인수가 널이 아니라면 참입니다.
  - **2개의 인수**

  첫번째 인수가 '!'라면 표현식은 두번째 인수가 널일 경우에 표현식이 참이 됩니다. 첫번째 인수가 단항 연산자([Bash Conditional Expressions](chapter_6_4.html)를 참조)이고, 단항 연산의 결과가 참이라면 표현식은 참입니다. 만약 첫번째 인수가 유효한 단항 연산자가 아니라면 표현식은 거짓입니다.
  - **3개의 인수**

  다음 조건이 순서대로 적용됩니다.
    1. 두번째 인수가 이항 조건 연산자([Bash Conditional Expressions](chapter_6_4.html)를 참조)라면, 표현식의 결과는 첫번째, 세번째 인수를 사용한 이항 연산자의 검사 결과입니다. '-a'와 '-o' 연산자는 인수가 3개일 때 이항 연산자인 것처럼 취급됩니다.
    2. 첫번째 인수가 '!'라면 두번째와 세번째 인수를 사용한 두 인수 검사 결과의 부정값이 됩니다.
    3. 첫번째 인수가 '('이고, 세번째 인수가 ')'라면 두번째 인수의 단일 인수 검사의 결과가 됩니다.
    4. 그 이외의 경우, 표현식은 거짓이 됩니다.
  - **4개의 인수**

    첫번째 인수가 '!'라면, 나머지 인수들로 구성된 세 인수 표현식의 부정값이 결과가 됩니다. 그렇지 않다면, 표현식은 위에서 설명한 우선순위 규칙을 사용해 분해되고 평가됩니다.
  - **5개 이상의 인수**

    표현식은 위에서 설명한 우선순위 규칙을 사용해 분해되고 평가됩니다.

'<'와 '>'를 `test`나 '\['와 함께  사용하는 경우, 해당 연산자들은 ASCII 순서에 따라서 사전순으로 정렬합니다.

**times**

```sh
times
```
셸과 그 자식이 사용한 사용자와 시스템 시간을 출력합니다. 종료 스테이터스는 0입니다.

**trap**

```sh
trap [-lp] [arg] [sigspec …]
```
셸이 시그널 *sigspec*을 받을 때 *arg*의 명령어를 읽고 실행합니다. *arg*가 없고 하나의 *sigspec*이 있거나 '-'일 경우, 각 *sigspec* 시그널에 설정된 값이 셸이 시작될 때 가지고 있었던 값으로 초기화됩니다. *arg*가 널 문자열이라면, 각 *sigspec*으로 지정된 시그널은 셸과 셸이 호출한 명령어에서 무시됩니다.  *arg*가 없고 `-p` 옵션을 넘겼다면 셸은 각 *sigspec*에 연결된 트랩 명령어를 출력합니다. 만약 넘긴 임수가 없거나 `-p` 만 넘겼다면 `trap`은 셸의 입력으로 재사용가능한 형식으로 각 시그널 번호와 그와 연결된 명령어 리스트를 출력합니다. `-l` 옵션을 넘기면 셸은 시그널의 이름과 그에 대응하는 번호 리스트를 출력합니다. 각 *sigspec*은 시그널 이름이나 시그널 번호입니다. 시그널 이름을 사용하는 경우 대소문자를 구분하지 않으며, `SIG` 접두사는 생략가능합니다.

*sigspec*이 0이나 `EXIT`이라면, *arg*는 셸이 종료될 때 실행됩니다. *sigspec*이 `DEBUG`라면 명령어 *arg*는 모든 단순 명령어, `for` 명령어, `case` 명령어, `select` 명령어, 모든 산술 `for` 명령어, 셸 함수에서 실행되는 첫 번째 함수 직전에 실행됩니다. `shopt` 빌트인 명령어([The Shopt Builtin](chapter_4_3_2.html)을 참조)의 `extdebug` 옵션 설명을 참조하세요. *sigspec*이 `RETURN`이라면 명령어 *arg*는 셸 함수나 `.` 또는 `source` 빌트인 명령어에 의해 실행된 스크립트의 실행이 종료될 때마다 실행됩니다.

만약 *sigspec*이 `ERR`라면, (단순 명령어로 구성될 수도 있는) 파이프라인, 리스트, 복합 명령어가 0이 아닌 종료 스테이터스를 반환할 때마다 다음 조건에 따라서 명령어 *arg*가 실행됩니다. `ERR` 트랩은 실패한 명령어가 `until`이나 `while` 키워드 직후에 오는 경우, `if`나 `elif` 예약어 뒤에 오는 경우, `&&`나 `||`의 일부이되 마지막 `&&`, `||`의 뒤에 오지 않은 경우, 파이프라인의 마지막 명령어인 경우, 명령어의 반환 스테이터스를 `!`로 뒤집은 경우에는 실행되지 않습니다. 이는 `errexit`(`-e`) 옵션이 적용되는 조건과 동일합니다.

셸이 생성될 때 무시하도록 설정해둔 시그널은 트랩을 설정하거나 초기화할 수 없습니다. 무시하도록 설정하지 않은 시그널은 서브셸 또는 서브셸 환경을 생성할 때 원래의 값으로 초기화됩니다.
*sigspec*에 유효하지 않은 시그널을 설정한 것이 아니라면 종료 스테이터스는 0입니다.

**umask**

```sh
umask [-p] [-S] [mode]
```
셸 프로세스의 파일 생성 마스크를 *mode*로 설정합니다. *mode*가 숫자로 시작하면 8진수로 처리됩니다. 그 이외의 경우에는 `chmod` 명령어가 받는 것과 유사한 심볼릭 모드 마스크로 처리됩니다. *mode*를 생략하면 현재 마스크 값이 출력됩니다. `-S` 옵션을 *mode* 인수 없이 사용하면, 심볼릭 형식으로 마스크를 출력합니다. `-p` 옵션을 사용하고 *mode*를 생략한 경우, 입력으로 재활용이 가능한 형식으로 결과를 출력합니다. 모드가 성공적으로 변경되었거나, *mode* 인수가 주어지지 않은 경우 반환 스테이터스는 0입니다. 그 이외의 경우에는 0이 아닌 값입니다.

모드가 8진수로 처리되는 경우 umask의 각 숫자는 7로부터 뺀 값이 된다는 것을 기억하세요. 그러므로 `022`의 umask는 `755` 권한을 의미합니다.

**unset**

```sh
unset [-fnv] [name]
```
각 변수 또는 함수 *name*을 제거합니다. `-v` 옵션을 넘기면 각 *name*은 셸 변수를 참조하고 해당 변수를 제거합니다. `-f` 옵션을 넘기면 *name*은 셸 함수를 참조하며 함수의 정의를 제거합니다. `-n` 옵션을 넘기는 경우 *name*은 *nameref* 속성을 가지고 있는 변수이며, *name*이 참조하고 있는 변수를 제거하기 보다는 변수 자체를 제거합니다. `-f` 옵션을 함께 사용했다면 `-n`은 무시됩니다. 아무런 옵션을 사용하지 않았다면 *name*은 변수를 참조합니다. 만약 지정한 이름의 변수가 존재하지 않고, 지정한 이름을 가지는 함수가 있다면 그 쪽을 제거합니다. 읽기 전용 변수와 함수는 제거되지 않습니다. 몇몇 셸 변수는 제거하면 특수한 행동을 하지 않게 됩니다. 이에 해당하는 행동은 각 별수의 설명에서 확인할 수 있습니다. *name*이 읽기 전용이 아니라면 종료 스테이터스는 0입니다.
