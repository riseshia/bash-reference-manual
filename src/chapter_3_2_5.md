### 3.2.5 Compound Commands
- [Looping Constructs](chapter_3_2_5.html#3251-looping-constructs) : 반복 행동을 위한 셸 명령어.
- [Conditional Constructs](chapter_3_2_5.html#3252-conditional-constructs) : 조건부 실행을 위한 셸 명령어.
- [Grouping Commands](chapter_3_2_5.html#3253-grouping-commands) : 명령어를 그룹화하는 방법.

복합 명령어란 셸 프로그래밍 언어 구조입니다. 각 구조는 예약어나 제어 연산자로 시작하며 그에 대응하는 예약어 또는 연산자로 끝납니다. 명시적으로 덮어쓰지 않는 한, 복합 명령어에 연관된 리다이렉션은 해당 복합명령어에 속해있는 모든 명령어에 적용됩니다.

대부분의 경우 복합 명령어에 포함된 명령어의 나열은 하나 이상의 개행으로 다른 명령어들과 구분되며, 세미콜론 대신 개행이 따라옵니다.

Bash는 반복 구조, 조건부 실행, 명령어들을 그룹화하는 방법과 그룹을 하나의 단위로서 실행할 수 있는 기능을 제공합니다.

#### 3.2.5.1 Looping Constructs

Bash는 다음의 반복 구조를 제공합니다.
명령어의 문법 구조에 ';'가 나타난다는 점에 주의하세요. 이는 한줄 이상의 개행으로 바꿔 쓸 수도 있습니다.

##### until

`until` 명령어의 문법은 다음과 같습니다.

```sh
until test-commands; do consequent-commands; done
```

*test-commands*의 종료 스테이터스가 0이 될 때까지 *consequent-commands*를 계속해서 실행합니다. 반환 스테이터스는 *consequent-commands*에 속해있는 가장 마지막에 실행된 명령어의 종료 스테이터스이거나, 아무것도 실행되지 않았다면 0입니다.

##### while

`while` 명령어의 문법은 다음과 같습니다.

```sh
while test-commands; do consequent-commands; done
```

*test-commands*의 종료 스테이터스가 0이 아니게 될 때까지 *consequent-commands*를 계속해서 실행합니다. 반환 스테이터스는 *consequent-commands*에 속해있는 가장 마지막에 실행된 명령어의 종료 스테이터스이거나, 아무것도 실행되지 않았다면 0입니다.

##### for

`for` 명령어의 문법은 다음과 같습니다.

```sh
for name [ [in [words …] ] ; ] do commands; done
```

*words*를 전개하여 목록을 만들고, 목록의 각 원소들을 *name*에 바인딩하여 *commands*를 실행합니다. 만약 'in words'가 존재하지 않는다면, *for* 명령은 'in "$@"'이 지정된 것처럼 행동합니다.
반환 스테이터스는 마지막에 실행된 명령어의 종료 스테이터스입니다. *words*를 전개한 결과 아무런 원소가 없었다면 아무 명령도 실행되지 않으며 반환 스테이터스는 0이 됩니다.

다음과 같은 형태도 지원합니다.

```sh
for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
```

먼저 아래의 규칙에 따라 산술 표현식인 *expr1*이 평가됩니다. 산술 표현식 *expr2*가 평가 결과가 0이 될 때까지 반복적으로 평가됩니다. *expr2*의 평가 결과가 0이 아닐 때마다, *commands*와 *expr3*이 실행됩니다. 모든 표현식이 생략된다면 이들은 1이 있었던 것처럼 처리됩니다. 종료 값은 실행된 *commands*의 마지막 명령어의 종료 스테이터스이거나 표현식이 유효하지 않은 경우 false가 됩니다.

*break*와 *continue* 빌트인 명령어가 반복 실행을 제어하기 위해서 사용될 수 있습니다.

#### 3.2.5.2 Conditional Constructs
##### if

if 명령어의 문법은 다음과 같습니다.

```sh
if test-commands; then
  consequent-commands;
[elif more-test-commands; then
  more-consequents;]
[else alternate-consequents;]
fi
```

*test-commands* 리스트를 실행하고 만약 종료 스테이터스가 0이라면 *consequent-commands* 리스트를 실행합니다. 만약 *test-commands*가 0이 아닌 종료 스테이터스를 반환한다면 *elif*의 리스트를 차례로 실행하며 만약 이 리스트의 종료 스테이터스가 0일 경우, 이에 대응하는 *more-consequents*를 실행하고 명령어 실행을 종료합니다. 만약 'else alternate-consequents' 가 존재한다면, 마지막 *if* 또는 *elif* 절의 마지막 명령어의 종료 스테이터스가 0이 아닐 경우에 *alternate-consequents*가 실행됩니다. 반환 스테이터스는 마지막으로 실행된 명령어의 종료 스테이터스이거나, 테스트 조건에서 참으로 판정된 경우가 없었다면 0이 됩니다.

##### case

case 명령어의 문법은 다음과 같습니다.

```sh
case word in
  [ [(] pattern [| pattern]...) command-list ;;]...
esac
```

case는 *word*와 매칭하는 첫번째 *pattern* 에 대응하는 *command-list*를 선택적으로 실행합니다. 매칭은 3.5.8.1 Pattern Matching에서 기술하는 규칙에 따라서 이루어집니다. 만약 `nocasematch` 셸 옵션이 켜져있다면, 알파벳 문자의 대소문자를 구분하지 않습니다. '|'는 복수의 패턴을 구분하기 위해서 사용되며, ')' 연산자는 패턴 목록의 종료를 의미합니다. 패턴들과 그와 연관된 *command-list*의 쌍을 절이라고 부릅니다.

각 절은 ';;', ';&', ';;&'로 끝나야 합니다. *word*에 매칭을 시도하기 전, 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개, 따옴표 제거가 적용됩니다. 각 *pattern*은 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개가 적용됩니다.

*case*의 절은 임의의 갯수가 존재할 수 있으며, 이들은 각각 ';;', ';&', ';;&'로 끝납니다. 처음으로 매치된 패턴이 실행될 명령어 목록을 결정합니다. 어느 패턴에도 매칭이 발생하지 않는 경우를 처리하기 위해 가장 마지막 패턴으로 언제나 매칭에 성공하는 '\*'를 사용하는 것은 흔한 패턴입니다.

여기에 스크립트에서 입력받은 동물의 다리 개수를 출력하기 위해 *case*를 사용하는 예시가 있습니다.

```sh
echo -n "Enter the name of an animal: "
read ANIMAL
echo -n "The $ANIMAL has "
case $ANIMAL in
  horse | dog | cat) echo -n "four";;
  man | kangaroo ) echo -n "two";;
  *) echo -n "an unknown number of";;
esac
echo " legs."
```

';;' 연산자를 사용하면 첫번째 패턴 매칭이 발생한 이후, 추가적으로 매칭을 시도하지 않습니다. 대신에 ';&'를 사용하는 경우, 만약 존재한다면, 다음 절에 연관된 *command-list*를 실행합니다.직전의 매칭의 성공 여부와 관계없이 모든 패턴에 대해서 매칭을 시도하고, 그에 연관된 *command-list*를 실행합니다. ';;&'를 사용하는 경우, 만약 존재한다면, 나머지 패턴들에 대해서도 모두 매칭을 시도하고, 성공한다면 그에 연관된 *command-list*를 실행합니다.

어떤 패턴과도 매칭이 발생하지 않았다면 종료 스테이터스는 0입니다. 그렇지 않다면, 실행된 *command-list*의 종료 스테이터스가 반환 스테이터스가 됩니다.

##### select

`select` 구조로 메뉴를 간단하게 생성할 수 있습니다. 이는 `for` 명령어와 거의 같은 구조입니다.

```sh
select name [in words ...]; do commands; done
```

*in* 뒤에 따라오는 단어들의 목록이 전개되어 목록을 생성합니다. 전개된 단어들의 집합은 표준 에러 출력 스트림으로 보내지며, 각각에는 번호가 할당됩니다. 만약 'in *words*'가 생략되면 "$@"가 넘겨진 것처럼 행동합니다. 그러면 `PS3` 프롬프트가 표시되며 표준 입력으로부터 한 줄을 입력받습니다. 그 줄이 표시된 단어들과 대응하는 숫자로 구성되어 있다면, *name*에 그 단어가 설정됩니다. 만약 읽은 줄이 비어있다면 단어들과 프롬프트가 다시 표시됩니다. `EOF`를 읽으면 `select` 명령어의 처리가 완료됩니다. 그 이외의 값을 읽어들일 경우, *name*에 null이 설정됩니다. 읽어들인 줄은 `REPLY` 변수에 저장됩니다.

*commands*는 각 선택이 발생한 이후에 실행되며, `select` 명령이 끝남을 의미하는 `break` 명령어가 실행되기 전까지는 계속됩니다.

다음은 현재의 디렉토리에 있는 파일의 이름을 가져와서 보여주고, 선택한 번호와 해당하는 파일명을 출력하고 종료하는 예시입니다.

```sh
select fname in *;
do
  echo you picked $fname \($REPLY\)
  break;
done
```

##### ((...))

```sh
(( expression ))
```

산술 표현식인 `expression`을 [Shell Arithmetic](chapter_6_5.html)에서 설명하는 규칙대로 평가합니다. 만약 표현식의 값이 0이 아니라면 종료 스테이터스는 0입니다. 그렇지 않으면 종료 스테이터스는 1입니다. 이는 정확히 다음과 동등합니다.

```sh
let "expression"
```

빌트인 명령어 `let` 에 대한 설명은 Bash Builtins를 참조하세요.

##### \[\[...]]

```sh
[[ expression ]]
```

조건 표현식인 *expression*의 평가 결과에 따라서 0이나 1을 반환합니다. 표현식은 Bash Conditional Expressions에서 기술되는 요소들로 구성됩니다. \[\[와 ]];사이에서는 단어 분리, 파일명 전개가 발생하지 않습니다. 반면 물결줄표 전개, 매개변수와 변수 전개, 산술 전개, 명령어 치환, 프로세스 치환, 따옴표 제거는 적용됩니다. '-f' 와 같은 조건 연산자는 올바르게 인식되기 위해서 반드시 따옴표로 감싸서는 안됩니다.

'<', '>' 연산자는 '\[\['와 함께 사용하는 경우, 현재 로케일에서의 사전순을 이용하여 정렬을 수행합니다.

'\=\='와 '!\=' 연산자를 사용하는 경우, `extglob` 셸 옵션이 켜진 것처럼, 연산자 오른쪽의 문자열은 패턴으로 취급되며 Pattern Matching 에서 기술된 규칙에 따라서 매칭 여부를 판단합니다. '=' 연산자는 '\=\=' 와 동등합니다. 만약 `nocasematch` 셸 옵션이 켜져 있다면 알파벳의 대소문자를 무시하고 비교합니다. 문자열이 패턴 매칭에 성공하거나 실패하면 0을 반환하며, 그렇지 않은 경우에는 1을 반환합니다. 문자열의 임의의 부분을 따옴표로 감싸면 이 부분을 문자열로서 매칭하도록 강제할 수 있습니다.

다른 이항 연산자인 '=~'도 사용할 수 있으며, 이는 '\=\=', '!='과 같은 우선순위를 가집니다. 이를 사용할 때 오른쪽의 문자열은 POSIX 확장 정규표현식으로 인식되며 이에 맞게 비교를 수행(POSIX `regcomp`와 `regexec`를 사용)합니다. 반환 스테이터스는 문자열이 패턴 매칭에 성공하면 0이, 그렇지 않으면 1이 됩니다. 만약 정규표현식이 올바르지 않다면, 조건 표현식의 반환 스테이터스는 2가 됩니다. 만약 `nocasematch` 셸 옵션이 켜져있다면 비교시에 알파벳의 대소문자 구별을 무시합니다. 패턴의 임의의 부분을 따옴표로 감싸면 이 부분을 문자열로서 매칭하도록 강제할 수 있습니다. 정규표현식의 괄호 표현식은 괄호 사이의 따옴표가 그 의미를 잃어버리기 때문에 조심스럽게 다룰 필요가 있습니다. 만약 패턴이 셸 변수에 저장되어 있다면, 변수 전개를 따옴표로 감싸서 전체 패턴이 문자열로 매칭되도록 강제할 수 있습니다.

패턴은 문자열의 어떤 부분과도 매칭됩니다. 정규표현식 연산자인 '^'와 '$'를 사용하여 전체 문자열에 대해서 비교하도록 강제할 수 있습니다. 배열 변수 `BASH_REMATCH`는 문자열의 어느 부분이 패턴과 일치했는지를 기록합니다. `BASH_REMATCH`의 0번 인덱스에 들어있는 요소는 정규표현식 전체에 일치한 문자열의 위치가 들어있습니다. 정규표현식의 부분일치에 대한 정보는 `BASH_REMATCH`의 나머지 배열에 들어있습니다. `BASH_REMATCH`의 인덱스 n번째 요소는 n번째 부분 정규표현식(n번째 괄호)의 부분일치 위치입니다.

예를 들어 다음은 *line*이라는 셸 변수에 들어있는 문자열이 0개 이상의 공백문자, 0개 또는 1개의 'a', 그리고 하나의 'b'와 일치합니다.

```sh
[[ $line =~ [[:space:]]*(a)?b ]]
```

이는 'aab'나 'aaaaaab'와 일치합니다.

정규표현식을 셸 변수에 저장하는 것은 셸에게 있어 특별한 의미를 가지는 문자들을 따옴표로 감쌀 때 발생하는 문제를 회피하는데에 유용한 방법입니다. 때때로 따옴표를 사용하지 않고는 정규 표현식을 기술하는 것이나 정규표현식에서 사용된 따옴표가 셸에 의해서 제거될 때까지 감시하는 것이 이론적으로 어려울 때가 있습니다. 셸 변수에 패턴을 저장하는 것은 이러한 문제를 경감할 수 있습니다. 예를 들어 다음은 위의 코드와 동등합니다.

```sh
pattern='[[:space:]]*(a)?b'
[[ $line =~ $pattern ]]
```

정규표현식 문법에서 특별한 의미의 문자를 비교하고 싶다면 이는 특별한 의미를 갖지 않도록 따옴표로 감싸야 합니다.다시 말해, 'xxx.txt' 라는 패턴이 있다면 '.'는 문자열에 있는 (일반적인 정규표현식처럼) 어떤 문자든 매칭에 성공합니다. 그러나 '"xxx.txt"'는 그냥 '.' 문자와만 매칭됩니다. 셸 프로그래머는 백슬래시는 정규표현식이든 셸에서든 그 다음에 오는 문자의 특별한 의미를 제거하기 위해서 사용되기 때문에 반드시 이를 매우 조심스럽게 다루어야 합니다. 다음 두 명령어 집합은 같은 의미가 *아닙니다*.

```sh
pattern='\.'

[[ . =~ $pattern ]]
[[ . =~ \. ]]

[[ . =~ "$pattern" ]]
[[ . =~ '\.' ]]
```

첫번째 두 매칭은 성공하지만, 두번째 두 매칭은 실패합니다. 왜냐하면 백슬래시 그 자체가 패턴이 되어서 매칭 대상이 되기 때문입니다. 첫번째 두 예제는 백슬래시가 '.'으로부터 특별한 의미를 제거하므로 문자 '.'와 일치합니다. 만약 첫번째 예제 집합에서 문자열 '.' 대신에, 예를 들어 'a'를 넣는다면 패턴에서 따옴표로 감싼 '.'은 어떤 한 문자와 매칭된다는 특별한 의미를 상실하기 때문에 매칭에 실패할 것입니다.

표현식은 다음 연산자들을 사용하는 것으로 결합할 수 있으며, 우선순위가 낮은 순서대로 쓰여있습니다.
- ( expression )
  - *expression*의 값을 반환합니다. 이는 다른 연산자의 우선 순위를 원하는 순위로 변경하기 위해서 사용됩니다.
- ! expression
  - *expression*이 거짓이라면 참이 됩니다.
- expression1 && expression2
  - *expression1*과 *expression2*가 모두 참일때 참입니다.
- expression1 || expression2
  - *expression1*과 *expression2*가 하나라도 참일때 참입니다.

`&&`와 `||` 연산자는 *expression1*의 값이 조건 표현식 전체의 반환값을 결정하기에 충분할 때, *expression2*의 평가를 수행하지 않습니다.

#### 3.2.5.3 Grouping Commands

Bash는 여러 명령어를 하나의 단위로 묶어 실행하기 위한 방법을 두가지 제공하고 있습니다. 명령어들이 하나로 묶여있으면, 리다이렉션은 전체 명령어 목록에 적용됩니다. 예를 들어 목록에 포함되어 있는 모든 명령어의 출력은 전부 단일 스트림으로 보내집니다.

##### ()

```sh
( list )
```

소괄호로 명령어 목록을 감싸면 이는 서브셸을 생성하고([Command Execution Environment](chapter_3_7_3.html)를 참조), 목록에 포함되어 있는 각 명령어는 서브셸에서 실행됩니다. *list*는 서브셸에서 실행되므로, 변수 대입은 서브셸이 종료된 이후에 영향을 남기지 않습니다.

##### {}

```sh
{ list; }
```

중괄호로 명령어 목록을 감싸면 현재 셸 컨텍스트에서 명령어 목록을 실행합니다. 서브셸은 생성되지 않습니다. *list*뒤의 세미콜론(또는 개행)은 필수입니다.

두 방식에는 역사적인 이유로 서브셸의 생성여부 이외에도 미묘한 차이가 있습니다. 중괄호는 예약어이므로, 공백이나 다른 셸 메타문자를 이용하여 *list* 와 분리되어야 합니다. 반면 소괄호는 연산자이며 *list*와 공백 문자로 분리되지 않더라도 셸에 의해서 별개의 토큰으로 인식됩니다.

*list*의 종료 스테이터스가 두 구조의 종료 스테이터스가 됩니다.
