# 1. Introduction
- What is Bash? : Bash에 대한 짧은 설명.
- What is a shell? : 셸에 대한 짧은 설명.

## 1.1 What is Bash?
Bash는 GNU 운영체제를 위한 셸, 또는 명령어 해석기입니다. 이름은 'Bourne-Again SHell'의 약어로, 7번째 벨 연구소 버전에서 등장한 현 유닉스 셸인 `sh`의 조상을 만든 Stephen Bourne의 말장난으로부터 유래했습니다.

Bash는 sh 와 상당히 호환성이 있으며, Korn Shell(`ksh`)와 C Shell(`csh`)로부터 유용한 기능들을 받아들였습니다. Bash는 IEEE POSIX Shell과 IEEE POSIX의 도구에 대한 명세를 준수합니다. sh 보다 상호작용/프로그래밍 목적에서 개선된 기능을 제공합니다.

GNU 운영체제는 `csh`를 포함한 다른 셸을 포함하고 있습니다만, Bash가 기본 셸입니다. 다른 GNU 소프트웨어와 마찬가지로 Bash는 상당히 이식이 쉽습니다. 현재 움직이고 있는 거의 모든 유닉스와 MS-DOS, OS/2 윈도우즈 플랫폼을 위한 독립적인 포팅이 지원하는 몇몇 다른 운영체제에서 동작합니다.

## 1.2 What is a shell?
셸은 간단하게 설명하면 명령을 실행하는 매크로 처리기입니다. 매크로 처리기란 텍스트와 심볼을 전개하여 더 큰 표현식을 만드는 장치를 의미합니다.

유닉스 셸은 명령어 해석기이면서 프로그래밍 언어입니다. 셸은 명령어 처리기로서 풍푸한 GNU 유틸리티 집합에 대한 인터페이스를 제공합니다. 프로그래밍 언어 기능은 유틸리티들을 결합할 수 있도록 해줍니다. 명령어들을 포함하는 파일을 만들 수 있으며, 그 자체로 명령이 될 수 있습니다. 이러한 새 명령들은 `/bin` 와 같은 디렉토리에 존재하는 시스템 명령어와 동일한 스테이터스를 가지며 사용자 또는 그룹에게 전용 환경을 만들고 빈번한 작업을 자동화할 수 있도록 합니다.

셸은 인터랙티브하게도 하지 않게도 사용할 수 있습니다. 인터랙티브 모드에서는 키보드로부터의 입력을 받을 수 있습니다. 만약 비-인터랙티브 모드에서 실행중이라면, 셸은 파일로부터 읽어온 명령을 실행합니다.

셸은 GNU 명령을 실행할 수 있으며, 동기적으로도 비동기적으로도 가능합니다. 셸은 새로운 입력을 받기 전에 동기적인 명령이 완료될 때까지 기다립니다. 비동기 명령은 셸이 읽거나 다른 새로운 명령을 실행하는 동안 병렬로 실행됩니다. 리다이렉션 구조는 이러한 명령들의 입력과 출력을 세밀하게 제어할 수 있도록 해줍니다. 게다가 셸은 명령어의 실행 환경의 내용을 제어할 수 있도록 해줍니다.

또한 셸은 여러 유틸리티를 통해서 얻을 수 없거나 불편한 기능을 구현하는 작은 내장 명령어 집합을 제공합니다. 예를 들어, `cd`, `break`, `continue`, `exec`는 직접 셸을 조작하기 때문에 셸 바깥에서는 구현될 수 없는 것들입니다. `history`, `getopts`, `kill`, `pwd`을 포함하는 내장 명령어들은 여러 유틸리티를 사용하여 구현될 수 있습니다만, 내장 명령어를 이용하는 것이 훨씬 편리합니다. 모든 셸 내장 기능은 이후의 섹션에서 설명합니다. 

명령어를 실행하는 기능이 필수임에도 불구하고, 셸의 강력한 성능(과 복잡성)은 이들이 내장하고 있는 프로그래밍 언어에서 비롯합니다. 다른 고레벨 언어처럼 셸도 변수, 흐름 제어, 따옴표로 감싸기, 함수를 제공합니다.

셸은 프로그래밍 언어를 확장하기 보다는 인터랙티브한 사용을 위해 특별히 조정된 기능을 제공합니다. 이러한 인터랙티브 기능에는 잡 컨트롤, 명령줄 수정, 명령 기록과 엘리아스 등이 포함됩니다. 이 메뉴얼에서 각 기능들에 대해서 설명합니다.

# 2. Definitions
다음 정의들은 뒷부분에서 사용됩니다.

- `POSIX`: 유닉스 기반의 공개 시스템 표준. Bash는 주로 POSIX 1003.1 표준의 셸과 유틸리티 부분에 관련이 있습니다.
- `공백`: 스페이스나 탭 문자.
- `빌트인`: 파일 시스템 어딘가에 존재하는 실행 가능한 프로그램이 아닌, 셸 자신에 의해서 내부적으로 구현된 명령어.
- `제어 연산자`: 제어 함수를 실행하는 토큰. 개행이나 다음 중 하나입니다. `::`, `&&`, `&`, `;`, `;;`, `;&`, `;;&`, `|`, `|&`, `(`, `)`.
- `종료 스테이터스`: 명령이 호출자에게 반환하는 값. 이 값은 8비트로 제한되어 있으며, 그러므로 최대값은 255입니다.
- `필드`: 셸 전개의 결과물로서 나타나는 문자열의 한 부분. 전개 후, 명령을 실행할 때 필드들은 명령어의 이름과 인수로 사용됩니다.
- `파일명`: 파일을 식별하기 위해 사용되는 문자열.
- `잡`: 파이프라인을 구성하는 프로세스의 집합과 이들의 자식 프로세스들. 이들은 전부 동일한 프로세스 그룹에 포함됩니다.
- `잡 컨트롤`: 프로세스들의 정지(서스펜드)하거나, 재시작(재개)할 수 있게끔 하는 구조
- `메타문자`: 따옴표를 제거했을 때 단어로 분리되는 문자들. 메타 문자는 스페이스, 탭, 개행이나 다음 중 하나입니다 `|`, `&`, `;`, `(`, `)`, `<`, `>`
- `이름`: 영문자, 숫자, 언더스코어로 구성되며, 영문자나 언더스코어로 시작되는 단어. 이름들은 셸의 변수나 함수명으로 사용된다. `식별자`라고도 부릅니다.
- `연산자`: `제어 연산자`나 `리다이렉션 연산자`. 리다이렉션 연산자에 대해서는 Redirections를 참조하세요. 연산자는 적어도 하나의 따옴표가 제거된 메타문자를 포함하세요.
- `프로세스 그룹`: 같은 프로세스 그룹 ID를 가지고 있는 프로세스 집합.
- `프로세스 그룹 ID`: 프로세스 그룹의 생애주기 동안 이를 가리키는 유일한 식별자.
- `예약어`: 셸에서 특별한 의미를 가지는 단어. `for`, `while` 같은 대부분의 예약어는 흐름 제어 구조에서 소개됩니다.
- `반환 스테이터스`: 종료 스테이터스와 동의어.
- `시그널`: 커널이 시스템에서 발생한 이벤트를 프로세스에게 알리기 위한 구조.
- `특수 빌트인`: POSIX에서 특별한 것으로 분류되는 셸의 내장 명령어.
- `토큰`: 셸에서 하나의 단위로 인식되는 연속된 문자들. 단어이거나 연산자.
- `단어`: 셸에서 하나의 단위로 처리되는 연속된 문자들. 단어는 따옴표가 제거된 메타문자를 포함하지 않을 수도 있습니다.

# 3. Basic Shell Features

Bash는‘Bourne-Again SHell’의 약자입니다. Bourne 쉘은 원래 Stephen Bourne이 작성한 전통적인 Unix 쉘입니다. Bourne 쉘 내장 명령은 모두 Bash에서 사용할 수 있습니다. 평가 및 따옴표로 감싸는 규칙은 '표준'Unix 쉘의 POSIX 사양에서 가져옵니다.

이 챕터에서는 명령, 제어 구조, 셸 함수, 셸 매개 변수, 셸 전개, 리다이렉션, 명명 된 파일의 입력 및 출력을 지시하는 방법과 셸이 명령을 실행하는 방법 등 셸의 '구성 요소'를 간략하게 요약합니다. 

- Shell Syntax : 셸에게 입력한 내용의 의미.
- Shell Commands : 사용할 수 있는 명령어의 타입.
- Shell Functions : 이름으로 명령어를 그룹으로 만들기.
- Shell Parameters : 변수가 값을 저장하는 방법.
- Shell Expansions : Bash가 매개변수를 전개하는 방법과 사용할 수 있는 다양한 전개에 대해서.
- Redirections : 입력과 출력을 제어하는 방법.
- Executing Commands : 명령어를 실행할 때 벌어지는 일.
- Shell Scripts : 셸 명령어가 들어있는 파일을 실행하기.

## 3.1 Shell Syntax

- Shell Operation : 셸의 기본 동작.
- Quoting : 문자로부터 특별한 의미를 제거하는 방법.
- Comments : 코멘트를 구별하는 방법.

입력은 순차적으로 해석합니다. 코멘트 심볼(`#`)을 발견하면 해당 줄의 나머지를 무시합니다.

순차해석을 할 때에는 입력을 단어와 연산자로 분리하며, 따옴표로 감싸기 규칙을 적용해서 각 단어와 문자들에 어떤 의미를 적용할 지를 선택합니다.

그리고나서 셸은 토큰들을 명령어와 다른 구조로 분석하고, 특별한 의미를 가진 문자를 제거하고, 다른 것들을 전개하고, 필요하면 입출력을 적절한 곳으로 전송하고, 지정된 명령을 실행하고, 명령의 종료 스테이터스를 기다려서 다음 검사(inspection)나 처리에서 사용할 수 있도록 합니다.
### 3.1.1 Shell Operation

다음은 명령을 읽고 실행할 때 셸의 작동에 대한 간략한 설명입니다. 셸은 기본적으로 이렇게 수행됩니다. 

1. 파일로부터 읽거나 -c 옵션을 통해서 문자열을 받거나, 또는 사용자의 터미널로부터 입력을 받습니다.
2. 입력을 단어와 연산자로 분해하고, 따옴표로 감싸기 규칙을 적용한다. 이 토큰들은 메타 문자로 분리되며, 별칭(alias) 전개가 이루어집니다.
3. 토큰들을 간단한 복합 명령어로 구문 분석합니다.
4. 파일 이름, 명령어, 인수의 리스트로 토큰을 전개하는 등의 다양한 셸 전개를 실행합니다.
5. 필요한 리다이렉션을 수행하고 리다이렉션 연산자와 그 피연산자를 매개변수 리스트에서 제거합니다.
6. 명령을 실행합니다.
7. 필요하다면 명령의 실행을 기다려 종료 스테이터스를 취득할 수도 있습니다.

### 3.1.2 Quoting
- Escape Character : 단일 문자에서 특별한 의미를 제거하는 방법.
- Single Quotes : 문자열에서 모든 의미 해석을 금지하는 방법.
- Double Quotes : 문자열에서 거의 모든 의미 해석을 금지하는 방법.
- ANSI-C Quoting : 따옴표로 감싼 문자열에서 ANSI-C 나열을 전개하는 방법.
- Locale-Specific Translation : 문자열을 다른 언어로 번역하는 방법.

따옴표로 감싸기는 어떤 문자나 단어의 특별한 의미를 셸에서 제거하기 위해서 사용됩니다. 이는 특수 문자에 대한 특수 처리를 비활성화하여 예약어가 그대로 인식되는 것을 방지하며 매개변수 전개를 방지하는 데 사용할 수 있습니다.

셸의 메타 문자들은 셸에 있어서 특별한 의미를 가지며 그 자신을 가리키기 위해서는 반드시 따옴표로 감싸기를 이용해야 합니다. 예를 들어 명령어 이력 전개 기능을 사용하고 있다면, 이력 전개 문자(기본값은 `!`입니다)를 사용할 때에는 전개를 피하기 위해서 반드시 따옴표로 감싸기를 사용해야 합니다. 이력 전개에 대한 자세한 설명은 `Bash History Facilities` 항목을 읽어주세요.

따옴표로 감싸는 방법은 3가지입니다. 이스케이프 문자, 작은따옴표, 큰따옴표.

#### 3.1.2.1 Escape Character

따옴표로 감싸지 않은 백슬래시(`\`)는 Bash의 이스케이프 문자입니다. 이는 다음에 이어지는 개행 이외의 문자의 값을 보존합니다. 만약 `\개행`이 있다면 백슬래시는 따옴표로 감싸기가 발생하지 않으며, `\개행`은 행이 계속되는 것으로 처리됩니다. (참고로 이는 입력 스트림에 의해서 제거되고 사실상 무시됩니다)

#### 3.1.2.2 Single Quotes

작은따옴표(`'`)로 문자들을 감싸면 각 문자들의 값을 보존합니다. 작은따옴표는 백슬래시를 사용하더라도 작은따옴표 쌍의 사이에서 사용될 수 없습니다.

#### 3.1.2.2 Double Quotes

큰따옴표(`"`)로 문자들을 감싸면 모든 문자들의 값을 보존합니다만,  '\$', '\`', '\\'는 예외이며, 이력 전개 기능이 켜져있을 경우, '!'도 예외에 포함됩니다. 셸이 POSIX 모드에서 동작하고 있을 경우, '!'는 이력 전개 기능이 켜져있더라도 큰따옴표 사이에서는 아무런 의미가 없습니다. 반면 '\$'나 '\`'는 여전히 특별한 의미를 가집니다.

백슬래시는 '\$', '\`', '\"', '\\', 그리고 개행 앞에서만 특별한 의미로 사용됩니다. 큰따옴표 사이에서 백슬래시는 이 문자들의 앞에 있을 때 제거됩니다. 특별한 의미를 가지지 않는 문자 앞에 위치한 백슬래시는 제거되지 않습니다. 큰따옴표는 큰따옴표 사이에서 백슬래시를 앞에 두어서 자기 자신을 의미할 수 있습니다. 이력 전개 기능이 켜져있을 때, 큰따옴표 사이의 '!'를 백슬래시로 이스케이프하지 않았다면 이력 전개가 발생합니다. '!' 앞의 백슬래시는 제거되지 않습니다.
특별한 인수인 '\*', '@'은 큰따옴표 사이에서 특별한 의미를 가집니다.
#### 3.1.2.4 ANSI-C Quoting

$'string' 형태의 단어들은 특별하게 처리됩니다. 이 단어는 백슬래시로 ANSI C 표준에 의해 정해진 이스케이프된 문자열로 치환되어 전개됩니다. 만약 백슬래시로 이스케이프된 문자가 있다면, 이는 다음처럼 처리됩니다:

- `\a`: 경고 (벨소리)
- `\b`: 백스페이스
- `\e`, `\E`: 이스케이프 문자 (ANSI C가 아님)
- `\f`: 폼 피드
- `\n`: 개행
- `\r`: 캐리지 리턴
- `\t`: 탭
- `\v`: 수직탭
- `\\:` 백슬래시
- `\':` 작은따옴표
- `\":` 큰따옴표
- `\?:` 물음표
- `\nnn`: 8진수 nnn으로 표현된 8비트 문자(3글자까지 허용)
- `\xHH`: 16진수 HH로 표현된 8비트 문자(2글자까지 허용)
- `\uHHHH`: 16진수 HHHH로 표현된 유니코드(ISO/IEC 10646) 문자(16진수 4글자까지 허용)
- `\UHHHHHHHH`: 16진수 HHHHHHHH로 표현된 유니코드(ISO/IEC 10646) 문자(8진수 8글자까지 허용)
- `\cx`: Ctrl-x 문자

전개된 결과는 $ 기호가 존재하지 않는 작은따옴표로 감싼 문자열이 됩니다.
#### 3.1.2.5 Locale-Specific Translation

달러 기호('\$')로 시작한 큰따옴표 문자열은 현재 로케일로 문자열을 번역합니다. `gettext` 인프라는 `LC_MESSAGES`와 `TEXTDOMAIN` 셸 변수를 사용하여 아래와 같이 메시지 카탈로그를 검색/번역합니다. 더 자세한 설명은 gettext 문서를 확인하세요. 만약 현재의 로케일이 `C`나 `POSIX`, 또는 사용 가능한 번역이 존재하지 않는다면, 달러 기호는 무시됩니다. 만약 문자열이 번역/치환되었다면, 변경된 결과는 큰따옴표로 감싸진 상태입니다.

몇몇 시스템은 `LC_MESSAGES` 셸 변수로 지정된 메시지 카탈로그를 사용합니다. 다른 시스템들은 `TEXTDOMAIN` 셸 변수의 값을 이용하며 메시지 카탈로그의 이름을 생성하며, 접미사로 '.mo'를 추가하는 경우도 있습니다. 만약 `TEXTDOMAIN` 변수를 사용한다면, `TEXTDOMAINDIR` 변수에 메시지 카탈로그의 위치를 지정해야할 가능성이 있습니다. 사람들은 여전히 아래와 같은 스타일로 두 변수를 모두 사용하고 있습니다.

`TEXTDOMAINDIR`/`LC_MESSAGES`/LC\_MESSAGES/`TEXTDOMAIN`.mo

### 3.1.3 Comments

비-인터랙티브 셸, 또는 `shopt` 빌트인에 `interactive_comments`를 넘긴 인터랙티브 셸에서는 '#'으로 시작하는 단어와 같은 행에 존재하는 그 뒤의 모든 문자들을 무시합니다. `interactive_comments` 옵션을 켜지 않은 인터랙티브 셸에서는 코멘트를 허가하지 않습니다. `interactive_comments` 옵션은 인터랙티브 셸에서 기본으로 켜져있습니다. Interactive Shells에서 무엇이 셸을 인터랙티브하게 만드는지에 대한 설명을 참고하세요.
## 3.2 Shell Commands
`echo a b c` 같은 간단한 셸 명령어는 명령어 자신과 스페이스로 구분된 인수가 그 뒤로 옵니다.

이보다 복잡한 셸 명령어는 단순 명령어를 다양한 방식으로 조합하여 구성됩니다. 파이프라인을 사용해 한 명령어의 출력을 다음 명령어의 입력으로 사용하거나, 루프나 조건부 구조를 사용하거나, 다른 방식으로 그룹화할 수 있습니다.

- Reserved Words : 셸에게 있어 특별한 의미를 가지는 단어.
- Simple Commands : 가장 흔한 명령어의 타입.
- Pipelines : 여러 명령어의 입력과 출력을 연결하기.
- Lists of Commands : 명령어를 순서대로 실행하는 방법.
- Compound Commands : 제어 흐름을 이용하는 셸 명령어.
- Coprocesses : 명령어 간의 양방향 통신.
- GNU Parallel : 명령어를 병렬로 실행하기.

### 3.2.1 Reserved Words

예약어는 셸에서 특별한 의미를 가지는 단어들입니다. 이것들은 셸의 복합명령어들의 시작과 끝에서 사용됩니다.
다음 단어들은 따옴표로 감싸지 않은 상태에서 명령어의 첫번째 단어로 왔을 때 예약어로 인식됩니다.

`if`, `then`, `elif`, `else`, `fi`, `time`, `for`, `in`, `until`, `while`, `do`, `done`, `{`, `}`, `[[`, `]]`, `!`

다음은 예외사항입니다.

- `in`은 세번째 단어가 `case`나 `select` 명령인 경우에 예약어로 취급됩니다.
- `in`과 `do`는 `for` 명령의 세번째 단어인 경우에 예약어로 취급됩니다.

### 3.2.2 Simple Commands

평소에 자주 마주하는 명령어들. 공백으로 구분된 단어들에 셸의 제어 연산자(정의를 참조)로 끝나는 것들입니다. 첫번째 단어는 일반적으로 실행될 명령이며, 나머지는 명령어의 매개변수입니다.

종료 스테이터스는 POSIX 1003.1 `waitpid` 함수에 의해서 제공되는 종료 스테이터스이거나, 시그널 n에 의해서 종료된 경우 128 + n 입니다.

### 3.2.3 Pipelines

파이프라인이란 제어 연산자의 하나인 '|', '|&'를 사용하여 나눠지는 하나 이상의 명령어 나열을 의미합니다.

파이프라인의 형식은 다음과 같습니다.

```sh
[time [-p]] [!] command1 [ | or |& ] command2 ] ...
```

파이프라인의 각 명령어의 출력은 파이프를 통해 다음 명령어의 입력으로 연결됩니다. 그러니까 각 명령어는 직전 명령의 출력을 읽습니다. 명령어에 의해서 어떤 리다이렉션이 지정되기 전에만 이루어집니다.

만약 '|&'를 사용한다면, command1의 표준 에러가 표준 출력과 함께 파이프를 통해 command2의 표준 출력으로 연결됩니다. 이는 `2>&1 |` 의 짧은 표현입니다. 이 표준 에러를 표준 출력으로 연결하는 암묵적인 리다이렉션은 명령어에 의해 지정된 어떤 리다이렉션의 뒤에서라도 동작합니다.

예약어 `time` 을 사용하면 파이프라인 처리가 완료될 때에 실행 시간에 대한 통계정보를 출력합니다. 이 정보는 걸린 시간과 명령어 실행에 소모된 유저/시스템 시간으로 이루어져있습니다. '-p' 옵션은 출력 형식을 POSIX 준거로 바꿔줍니다. 만약 셸이 POSIX 모드에서 실행되고 있다면, 다음 토큰이 '-'로 시작하지 않는 경우 `time`를 예약어로 처리되지 않습니다. `TIMEFORMAT` 변수를 지정하여 어떤 형식으로 시간 정보를 출력할지 변경할 수도 있습니다. 사용가능한 형식에 대해서는 Bash Variables를 참조하세요. `time`을 예약어로 사용하면 셸의 빌트인 명령어, 셸 함수, 파이프라인의 실행 시간을 계측할 수 있습니다. 외부의 `time` 명령어는 이처럼 간단하게 시간을 잴 수 없습니다.

셸이 POSIX 모드에서 동작할 때, `time` 뒤에는 개행이 따라옵니다. 이 경우, 셸은 셸과 그 자식들에 의해 소비된 모든 유저/시스템 시간을 표시합니다. `TIMEFORMAT` 변수를 사용하여 출력 형식을 변경할 수 있습니다.

파이프라인이 비동기로 실행되지 않는다면, 셸은 파이프라인의 모든 명령어의 실행이 종료되는 것을 기다립니다.

파이프라인의 각 명령어는 각각의 서브셸에서 실행됩니다. 이 서브셸은 별도의 프로세스입니다(Command Execution Environment를 참조). `shopt` 빌트인에서 `lastpipe` 옵션을 켰다면 파이프라인의 마지막 원소는 셸 프로세스에서 실행됩니다.

파이프라인의 종료 스테이터스는 `pipefail` 옵션을 켠 상태가 아니라면 파이프라인의 마지막 명령어의 종료 스테이터스입니다. 만약 `pipefail` 옵션을 켠 상태라면 파이프라인의 반환 스테이터스는 0이 아닌 스테이터스로 종료된 오른쪽 끝의 명령어의 반환 스테이터스를 돌려주거나, 모든 명령어들이 성공적으로 종료되었다면 0을 반환합니다. 파이프라인의 시작 부분에서 예약어 '!'가 있다면, 종료 스테이터스는 위에서 설명한 종료 스테이터스의 논리 부정값(원문은 logical nagation)입니다. 셸은 값을 반환하기 전에 파이프라인의 모든 명령어의 실행이 종료될 때까지 기다립니다.

### 3.2.4 Lists of Commands

리스트는 ';', '&', '&&', '||', 때때로는 ';', '&', 개행으로 연결된 하나 이상의 파이프라인의 나열로 정의됩니다.

리스트 연산자 중, '&&'와 '||'는 동등한 우선순위를 가지며, ';'와 '&'도 동등한 우선순위입니다.

리스트에서 하나 이상의 개행의 연속은 명령어들의 경계를 결정하며, 이는 세미콜론과 동일합니다.

명령어가 제어 연산자 '&'로 끝난다면 셸은 이 명령을 서브셸에서 비동기로 실행합니다. 이는 명령을 백그라운드에서 실행한다는 표현으로 알려져 있으며, 비동기 명령어라고 불립니다. 셸ㄹ은 이 명령어의 실행 종료를 기다리지 않으며, 반환 스테이터스는 0(true)이 됩니다. 잡 컨트롤을 쓰고 있지 않다면 비동기 명령어의 표준 입력은 다른 명시적인 리다이렉션이 존재하지 않는다면 `/dev/null`로부터 리다이렉션됩니다.

';'로 분리된 명령어들은 순차적으로 실행됩니다. 셸은 각 명령어가 종료되는 것을 기다립니다. 반환 스테이터스는 가장 마지막에 실행된 명령어의 종료 스테이터스입니다.

AND나 OR 리스트는 '&&'와 '||'로 분리된 하나 이상의 파이프라인의 나열입니다. AND/OR 리스트는 왼쪽부터 순서대로 실행됩니다(left associativity).

AND 리스트는 다음 형식입니다.

```sh
command1 && command2
```

*command2*는 *command1*이 종료 스테이터스로 0을 반환했을 때만 실행됩니다.

OR 리스트는 다음 형식입니다.

```sh
command1 || command2
```

*command2*는 *command1*이 종료 스테이터스로 0을 반환하지 않았을 때만 실행됩니다.

AND/OR 리스트의 반환 스테이터스는 리스트에서 마지막으로 실행된 명령어의 실행 종료 스테이터스입니다.

### 3.2.5 Compound Commands
- Looping Constructs : 반복 행동을 위한 셸 명령어.
- Conditional Constructs : 조건부 실행을 위한 셸 명령어.
- Grouping Commands : 명령어를 그룹화하는 방법.

복합 명령어란 셸 프로그래밍 언어 구조입니다. 각 구조는 예약어나 제어 연산자로 시작하며 그에 대응하는 예약어 또는 연산자로 끝납니다. 명시적으로 덮어쓰지 않는 한, 복합 명령어에 연관된 리다이렉션은 해당 복합명령어에 속해있는 모든 명령어에 적용됩니다.

대부분의 경우 복합 명령어에 포함된 명령어의 나열은 하나 이상의 개행으로 다른 명령어들과 구분되며, 세미콜론 대신 개행이 따라옵니다.

Bash는 반복 구조, 조건부 실행, 명령어들을 그룹화하는 방법과 그룹을 하나의 단위로서 실행할 수 있는 기능을 제공합니다.

#### 3.2.5.1 Looping Constructs

Bash는 다음의 반복 구조를 제공합니다.
명령어의 문법 구조에 ';'가 나타난다는 점에 주의하세요. 이는 한줄 이상의 개행으로 바꿔 쓸 수도 있습니다.

##### until

`until` 명령어의 문법은 다음과 같습니다.

```sh
until test-commands; do consequent-commands; done
```

*test-commands*의 종료 스테이터스가 0이 될 때까지 *consequent-commands*를 계속해서 실행합니다. 반환 스테이터스는 *consequent-commands*에 속해있는 가장 마지막에 실행된 명령어의 종료 스테이터스이거나, 아무것도 실행되지 않았다면 0입니다.

##### while

`while` 명령어의 문법은 다음과 같습니다.

```sh
while test-commands; do consequent-commands; done
```

*test-commands*의 종료 스테이터스가 0이 아니게 될 때까지 *consequent-commands*를 계속해서 실행합니다. 반환 스테이터스는 *consequent-commands*에 속해있는 가장 마지막에 실행된 명령어의 종료 스테이터스이거나, 아무것도 실행되지 않았다면 0입니다.

##### for

`for` 명령어의 문법은 다음과 같습니다.

```sh
for name [ [in [words …] ] ; ] do commands; done
```

*words*를 전개하여 목록을 만들고, 목록의 각 원소들을 *name*에 바인딩하여 *commands*를 실행합니다. 만약 'in words'가 존재하지 않는다면, *for* 명령은 'in "$@"'이 지정된 것처럼 행동합니다.
반환 스테이터스는 마지막에 실행된 명령어의 종료 스테이터스입니다. *words*를 전개한 결과 아무런 원소가 없었다면 아무 명령도 실행되지 않으며 반환 스테이터스는 0이 됩니다.

다음과 같은 형태도 지원합니다.

```sh
for (( expr1 ; expr2 ; expr3 )) ; do commands ; done
```

먼저 아래의 규칙에 따라 산술 표현식인 *expr1*이 평가됩니다. 산술 표현식 *expr2*가 평가 결과가 0이 될 때까지 반복적으로 평가됩니다. *expr2*의 평가 결과가 0이 아닐 때마다, *commands*와 *expr3*이 실행됩니다. 모든 표현식이 생략된다면 이들은 1이 있었던 것처럼 처리됩니다. 종료 값은 실행된 *commands*의 마지막 명령어의 종료 스테이터스이거나 표현식이 유효하지 않은 경우 false가 됩니다.

*break*와 *continue* 빌트인 명령어가 반복 실행을 제어하기 위해서 사용될 수 있습니다.

#### 3.2.5.2 Conditional Constructs
##### if

if 명령어의 문법은 다음과 같습니다.

```sh
if test-commands; then
  consequent-commands;
[elif more-test-commands; then
  more-consequents;]
[else alternate-consequents;]
fi
```

*test-commands* 리스트를 실행하고 만약 종료 스테이터스가 0이라면 *consequent-commands* 리스트를 실행합니다. 만약 *test-commands*가 0이 아닌 종료 스테이터스를 반환한다면 *elif*의 리스트를 차례로 실행하며 만약 이 리스트의 종료 스테이터스가 0일 경우, 이에 대응하는 *more-consequents*를 실행하고 명령어 실행을 종료합니다. 만약 'else alternate-consequents' 가 존재한다면, 마지막 *if* 또는 *elif* 절의 마지막 명령어의 종료 스테이터스가 0이 아닐 경우에 *alternate-consequents*가 실행됩니다. 반환 스테이터스는 마지막으로 실행된 명령어의 종료 스테이터스이거나, 테스트 조건에서 참으로 판정된 경우가 없었다면 0이 됩니다.

##### case

case 명령어의 문법은 다음과 같습니다.

```sh
case word in
  [ [(] pattern [| pattern]...) command-list ;;]...
esac
```

case는 *word*와 매칭하는 첫번째 *pattern* 에 대응하는 *command-list*를 선택적으로 실행합니다. 매칭은 3.5.8.1 Pattern Matching에서 기술하는 규칙에 따라서 이루어집니다. 만약 `nocasematch` 셸 옵션이 켜져있다면, 알파벳 문자의 대소문자를 구분하지 않습니다. '|'는 복수의 패턴을 구분하기 위해서 사용되며, ')' 연산자는 패턴 목록의 종료를 의미합니다. 패턴들과 그와 연관된 *command-list*의 쌍을 절이라고 부릅니다.

각 절은 ';;', ';&', ';;&'로 끝나야 합니다. *word*에 매칭을 시도하기 전, 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개, 따옴표 제거가 적용됩니다. 각 *pattern*은 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개가 적용됩니다.

*case*의 절은 임의의 갯수가 존재할 수 있으며, 이들은 각각 ';;', ';&', ';;&'로 끝납니다. 처음으로 매치된 패턴이 실행될 명령어 목록을 결정합니다. 어느 패턴에도 매칭이 발생하지 않는 경우를 처리하기 위해 가장 마지막 패턴으로 언제나 매칭에 성공하는 '\*'를 사용하는 것은 흔한 패턴입니다.

여기에 스크립트에서 입력받은 동물의 다리 개수를 출력하기 위해 *case*를 사용하는 예시가 있습니다.

```sh
echo -n "Enter the name of an animal: "
read ANIMAL
echo -n "The $ANIMAL has "
case $ANIMAL in
  horse | dog | cat) echo -n "four";;
  man | kangaroo ) echo -n "two";;
  *) echo -n "an unknown number of";;
esac
echo " legs."
```

';;' 연산자를 사용하면 첫번째 패턴 매칭이 발생한 이후, 추가적으로 매칭을 시도하지 않습니다. 대신에 ';&'를 사용하는 경우, 만약 존재한다면, 다음 절에 연관된 *command-list*를 실행합니다.직전의 매칭의 성공 여부와 관계없이 모든 패턴에 대해서 매칭을 시도하고, 그에 연관된 *command-list*를 실행합니다. ';;&'를 사용하는 경우, 만약 존재한다면, 나머지 패턴들에 대해서도 모두 매칭을 시도하고, 성공한다면 그에 연관된 *command-list*를 실행합니다.

어떤 패턴과도 매칭이 발생하지 않았다면 종료 스테이터스는 0입니다. 그렇지 않다면, 실행된 *command-list*의 종료 스테이터스가 반환 스테이터스가 됩니다.

##### select

`select` 구조로 메뉴를 간단하게 생성할 수 있습니다. 이는 `for` 명령어와 거의 같은 구조입니다.

```sh
select name [in words ...]; do commands; done
```

*in* 뒤에 따라오는 단어들의 목록이 전개되어 목록을 생성합니다. 전개된 단어들의 집합은 표준 에러 출력 스트림으로 보내지며, 각각에는 번호가 할당됩니다. 만약 'in *words*'가 생략되면 "$@"가 넘겨진 것처럼 행동합니다. 그러면 `PS3` 프롬프트가 표시되며 표준 입력으로부터 한 줄을 입력받습니다. 그 줄이 표시된 단어들과 대응하는 숫자로 구성되어 있다면, *name*에 그 단어가 설정됩니다. 만약 읽은 줄이 비어있다면 단어들과 프롬프트가 다시 표시됩니다. `EOF`를 읽으면 `select` 명령어의 처리가 완료됩니다. 그 이외의 값을 읽어들일 경우, *name*에 null이 설정됩니다. 읽어들인 줄은 `REPLY` 변수에 저장됩니다.

*commands*는 각 선택이 발생한 이후에 실행되며, `select` 명령이 끝남을 의미하는 `break` 명령어가 실행되기 전까지는 계속됩니다.

다음은 현재의 디렉토리에 있는 파일의 이름을 가져와서 보여주고, 선택한 번호와 해당하는 파일명을 출력하고 종료하는 예시입니다.

```sh
select fname in *;
do
  echo you picked $fname \($REPLY\)
  break;
done
```

##### ((...))

```sh
(( expression ))
```

산술 표현식인 `expression`을 Shell Arithmetic에서 설명하는 규칙대로 평가합니다. 만약 표현식의 값이 0이 아니라면 종료 스테이터스는 0입니다. 그렇지 않으면 종료 스테이터스는 1입니다. 이는 정확히 다음과 동등합니다.

```sh
let "expression"
```

빌트인 명령어 `let` 에 대한 설명은 Bash Builtins를 참조하세요.

##### \[\[...]]

```sh
[[ expression ]]
```

조건 표현식인 *expression*의 평가 결과에 따라서 0이나 1을 반환합니다. 표현식은 Bash Conditional Expressions에서 기술되는 요소들로 구성됩니다. \[\[와 ]];사이에서는 단어 분리, 파일명 전개가 발생하지 않습니다. 반면 물결줄표 전개, 매개변수와 변수 전개, 산술 전개, 명령어 치환, 프로세스 치환, 따옴표 제거는 적용됩니다. '-f' 와 같은 조건 연산자는 올바르게 인식되기 위해서 반드시 따옴표로 감싸서는 안됩니다.

'<', '>' 연산자는 '\[\['와 함께 사용하는 경우, 현재 로케일에서의 사전순을 이용하여 정렬을 수행합니다.

'\=\='와 '!\=' 연산자를 사용하는 경우, `extglob` 셸 옵션이 켜진 것처럼, 연산자 오른쪽의 문자열은 패턴으로 취급되며 Pattern Matching 에서 기술된 규칙에 따라서 매칭 여부를 판단합니다. '=' 연산자는 '\=\=' 와 동등합니다. 만약 `nocasematch` 셸 옵션이 켜져 있다면 알파벳의 대소문자를 무시하고 비교합니다. 문자열이 패턴 매칭에 성공하거나 실패하면 0을 반환하며, 그렇지 않은 경우에는 1을 반환합니다. 문자열의 임의의 부분을 따옴표로 감싸면 이 부분을 문자열로서 매칭하도록 강제할 수 있습니다.

다른 이항 연산자인 '=~'도 사용할 수 있으며, 이는 '\=\=', '!='과 같은 우선순위를 가집니다. 이를 사용할 때 오른쪽의 문자열은 POSIX 확장 정규표현식으로 인식되며 이에 맞게 비교를 수행(POSIX `regcomp`와 `regexec`를 사용)합니다. 반환 스테이터스는 문자열이 패턴 매칭에 성공하면 0이, 그렇지 않으면 1이 됩니다. 만약 정규표현식이 올바르지 않다면, 조건 표현식의 반환 스테이터스는 2가 됩니다. 만약 `nocasematch` 셸 옵션이 켜져있다면 비교시에 알파벳의 대소문자 구별을 무시합니다. 패턴의 임의의 부분을 따옴표로 감싸면 이 부분을 문자열로서 매칭하도록 강제할 수 있습니다. 정규표현식의 괄호 표현식은 괄호 사이의 따옴표가 그 의미를 잃어버리기 때문에 조심스럽게 다룰 필요가 있습니다. 만약 패턴이 셸 변수에 저장되어 있다면, 변수 전개를 따옴표로 감싸서 전체 패턴이 문자열로 매칭되도록 강제할 수 있습니다.

패턴은 문자열의 어떤 부분과도 매칭됩니다. 정규표현식 연산자인 '^'와 '$'를 사용하여 전체 문자열에 대해서 비교하도록 강제할 수 있습니다. 배열 변수 `BASH_REMATCH`는 문자열의 어느 부분이 패턴과 일치했는지를 기록합니다. `BASH_REMATCH`의 0번 인덱스에 들어있는 요소는 정규표현식 전체에 일치한 문자열의 위치가 들어있습니다. 정규표현식의 부분일치에 대한 정보는 `BASH_REMATCH`의 나머지 배열에 들어있습니다. `BASH_REMATCH`의 인덱스 n번째 요소는 n번째 부분 정규표현식(n번째 괄호)의 부분일치 위치입니다.

예를 들어 다음은 *line*이라는 셸 변수에 들어있는 문자열이 0개 이상의 공백문자, 0개 또는 1개의 'a', 그리고 하나의 'b'와 일치합니다.

```sh
[[ $line =~ [[:space:]]*(a)?b ]]
```

이는 'aab'나 'aaaaaab'와 일치합니다.

정규표현식을 셸 변수에 저장하는 것은 셸에게 있어 특별한 의미를 가지는 문자들을 따옴표로 감쌀 때 발생하는 문제를 회피하는데에 유용한 방법입니다. 때때로 따옴표를 사용하지 않고는 정규 표현식을 기술하는 것이나 정규표현식에서 사용된 따옴표가 셸에 의해서 제거될 때까지 감시하는 것이 이론적으로 어려울 때가 있습니다. 셸 변수에 패턴을 저장하는 것은 이러한 문제를 경감할 수 있습니다. 예를 들어 다음은 위의 코드와 동등합니다.

```sh
pattern='[[:space:]]*(a)?b'
[[ $line =~ $pattern ]]
```

정규표현식 문법에서 특별한 의미의 문자를 비교하고 싶다면 이는 특별한 의미를 갖지 않도록 따옴표로 감싸야 합니다.다시 말해, 'xxx.txt' 라는 패턴이 있다면 '.'는 문자열에 있는 (일반적인 정규표현식처럼) 어떤 문자든 매칭에 성공합니다. 그러나 '"xxx.txt"'는 그냥 '.' 문자와만 매칭됩니다. 셸 프로그래머는 백슬래시는 정규표현식이든 셸에서든 그 다음에 오는 문자의 특별한 의미를 제거하기 위해서 사용되기 때문에 반드시 이를 매우 조심스럽게 다루어야 합니다. 다음 두 명령어 집합은 같은 의미가 *아닙니다*.

```sh
pattern='\.'

[[ . =~ $pattern ]]
[[ . =~ \. ]]

[[ . =~ "$pattern" ]]
[[ . =~ '\.' ]]
```

첫번째 두 매칭은 성공하지만, 두번째 두 매칭은 실패합니다. 왜냐하면 백슬래시 그 자체가 패턴이 되어서 매칭 대상이 되기 때문입니다. 첫번째 두 예제는 백슬래시가 '.'으로부터 특별한 의미를 제거하므로 문자 '.'와 일치합니다. 만약 첫번째 예제 집합에서 문자열 '.' 대신에, 예를 들어 'a'를 넣는다면 패턴에서 따옴표로 감싼 '.'은 어떤 한 문자와 매칭된다는 특별한 의미를 상실하기 때문에 매칭에 실패할 것입니다.

표현식은 다음 연산자들을 사용하는 것으로 결합할 수 있으며, 우선순위가 낮은 순서대로 쓰여있습니다.
- ( expression )
  - *expression*의 값을 반환합니다. 이는 다른 연산자의 우선 순위를 원하는 순위로 변경하기 위해서 사용됩니다.
- ! expression
  - *expression*이 거짓이라면 참이 됩니다.
- expression1 && expression2
  - *expression1*과 *expression2*가 모두 참일때 참입니다.
- expression1 || expression2
  - *expression1*과 *expression2*가 하나라도 참일때 참입니다.

`&&`와 `||` 연산자는 *expression1*의 값이 조건 표현식 전체의 반환값을 결정하기에 충분할 때, *expression2*의 평가를 수행하지 않습니다.

#### 3.2.5.3 Grouping Commands

Bash는 여러 명령어를 하나의 단위로 묶어 실행하기 위한 방법을 두가지 제공하고 있습니다. 명령어들이 하나로 묶여있으면, 리다이렉션은 전체 명령어 목록에 적용됩니다. 예를 들어 목록에 포함되어 있는 모든 명령어의 출력은 전부 단일 스트림으로 보내집니다.

##### ()

```sh
( list )
```

소괄호로 명령어 목록을 감싸면 이는 서브셸을 생성하고(Command Execution Environment를 참조), 목록에 포함되어 있는 각 명령어는 서브셸에서 실행됩니다. *list*는 서브셸에서 실행되므로, 변수 대입은 서브셸이 종료된 이후에 영향을 남기지 않습니다.

##### {}

```sh
{ list; }
```

중괄호로 명령어 목록을 감싸면 현재 셸 컨텍스트에서 명령어 목록을 실행합니다. 서브셸은 생성되지 않습니다. *list*뒤의 세미콜론(또는 개행)은 필수입니다.

두 방식에는 역사적인 이유로 서브셸의 생성여부 이외에도 미묘한 차이가 있습니다. 중괄호는 예약어이므로, 공백이나 다른 셸 메타문자를 이용하여 *list* 와 분리되어야 합니다. 반면 소괄호는 연산자이며 *list*와 공백 문자로 분리되지 않더라도 셸에 의해서 별개의 토큰으로 인식됩니다.

*list*의 종료 스테이터스가 두 구조의 종료 스테이터스가 됩니다.

### 3.2.6 Coprocesses

코프로세스는 `coproc` 예약어 뒤에 오는 셸 명령어를 가리킵니다. 코프로세스는 '&' 제어 연산자가 뒤에 붙어있는 명령어처럼 서브셸에서 비동기로 실행되며, 실행중인 셸과 양방향 파이프가 연결됩니다.

코프로세스의 포맷은 다음과 같습니다.

```sh
coproc [NAME] command [redirections]
```

이는 *NAME*이라는 이름을 가진 코프로세스를 생성합니다. 만약 *NAME*이 제공되지 않는다면 기본값인 *COPROC*이 사용됩니다. *NAME*은 *command*가 단순 명령어일 때에 사용해서는 안됩니다. 이 경우, 해당 명령의 첫번째 단어로 해석됩니다.

코프로세스가 실행된 이후, 셸은 실행중인 셸에 `NAME`이라는 배열 변수를 생성합니다. *command*의 표준 출력은 파이프를 통해 실행중인 셸의 파일 디스크립터에 연결되며, 이 파일 디스크립터는 `NAME[0]`에 대입됩니다. *command*의 표준 입력은 파이프를 통해 실행중인 셸의 파일 디스크립터에 연결되며, 이 파일 디스크립터는 `NAME[1]`에 대입됩니다. 이 파이프는 명령어의 리다이렉션 지정보다 먼저 생성됩니다. 파일 디스크립터들은 셸 명령어들의 인수나 표준 단어 전개의 리다이렉션 용도로 활용될 수 있습니다. 명령을 실행하거나 프로세스 치환을 위해 생성된 것 이외에는 파일 디스크립터는 서브셸에서 사용할 수 없습니다.

프로세스를 실행하기 위해 생성된 셸의 프로세스 ID는 `NAME`\_PID 변수의 값으로 저장되어 있습니다. `wait` 빌트인 명령어를 코프로세스의 종료를 기다리기 위해 사용할 수 있습니다.

코프로세스는 비동기 실행을 위해 생성되므로, `coproc` 명령의 실행은 언제나 성공합니다. 코프로세스의 반환 스테이터스는 *command*의 종료 스테이터스가 됩니다.

### 3.2.7 GNU Parallel

명령을 병렬로 실행할 수도 있습니다. 이 기능은 bash에 내장되어 있지 않습니다. GNU Parallel이 바로 이를 위한 도구입니다.

GNU Parallel은 이름으로부터 알 수 있듯, 명령어를 병렬로 빌드하거나 실행할 수 있습니다. 같은 명령을 다른 인수와 함께 실행할 수 있습니다. 예를 들어 파일명이나 사용자명, 호스트명, 파일로부터 입력을 받을 수 있죠. GNU Parallel은 흔한 작업(줄 단위의 입력, 입력 줄의 특정 위치, 다른 방식의 입력 소스 지정 등등)을 위한 간결한 표기법을 제공합니다. parallel은 `xargs`나 자신의 입력 소스들로부터 명령어를 얻고, 여러 Bash 인스턴스에 제공할 수 있습니다.

완전한 설명은 GNU Parallel 문서를 확인하세요. 여기에서는 몇몇 예제를 간단한 설명과 함께 제공합니다.

예를 들어, 단순히 `xargs` 대신 사용해 현재 디렉토리와 서브디렉토리의 모든 html 파일을 압축할 수 있습니다.

```sh
find . -type f -name '*.html' -print | parallel gzip
```

파일명안의 개행같은 특별한 문자들을 유지하고 싶다면, find의 -print0 옵션과 parallel의 -0 옵션을 사용하세요.
현재 디렉토리의 파일들이 하나의 `mv` 호출로 옮기기에 너무 많은 경우, parallel을 사용할  수 있습니다.

```sh
printf '%s\\n' * | parallel mv {} destdir
```

이처럼 {}는 표준 입력의 각 행으로 대체됩니다. 대부분의 경우에는 `ls`로 충분합니다만, 모든 파일명을 다루고 싶을 때에는 충분하지 않습니다. `printf`는 셸 빌트인이므로, 커널의 프로그램 인수 갯수 제한을 받지 않습니다. 그러므로 '\*'를 사용할 수 있습니다(그렇지만 `dotglob` 셸 옵션에 대해서 확인하세요). 만약 파일명에 포함된 특별한 문자를 처리할 필요가 있다면 

```sh
printf '%s\0' * | parallel -0 mv {} destdir
```

처럼 사용할 수 있습니다.

다음은 `mv` 명령을 현재 폴더에 있는 파일 숫자만큼 실행합니다. -X 옵션을 추가하는 것으로 병렬 `xargs`를 흉내낼 수 있습니다.

```sh
printf '%s\0' * | parallel -0 -X mv {} destdir
```

(`dotglob` 옵션이 켜져있다면 패턴을 변경해야 합니다.)

GNU Parallel은 파일로부터 줄단위로 입력받는 전형적인 코드를 대체할 수 있습니다. 다음 예시는 각 행에 파일명이 들어있습니다.

```sh
while IFS= read -r x; do
                    do-something1 "$x" "config-$x"
                    do-something2 < "$x"
                  done < file | process-output
```

이를 람다를 떠올리는 좀 더 간결한 문법으로 쓸 수 있습니다.

```sh
cat list | parallel "do-something1 {} config-{} ; do-something2 < {}" |
           process-output
```

Parallel은 파일명에서 확장자를 제거하는 기능을 내장하고 있어 일괄 파일 변환이나 재명명시에 이용할 수 있습니다.

```sh
ls *.gz | parallel -j+0 "zcat {} | bzip2 >{.}.bz2 && rm {}"
```

이 코드는 현재 디렉토리의 파일명이 .gz 로 끝나는 모든 파일을 bzip2를 이용하여 재압축합니다. 이는 CPU 갯수만큼(-j+0) 병렬로 동작합니다. (여기에서는 간략히 보여주기 위해 `ls`를 사용했습니다. 예상치 못한 문자가 포함된 파일명을 올바르게 처리하기 위해서는 `find`를 이용하세요.) Parallel은 명령줄으로부터 인수들을 받을 수 있으므로 다음처럼도 쓸 수 있습니다.

```sh
parallel "zcat {} | bzip2 >{.}.bz2 && rm {}" ::: \*.gz
```

명령어가 출력을 생성하는 경우, 입력순에 맞춰 정렬되어있기를 바랄 수도 있습니다. 예를 들어, 다음 명령은 호출이 종료되는 순서대로 결과를 출력합니다.

```sh
{
    echo foss.org.my ;
    echo debian.org ;
    echo freenetproject.org ;
} | parallel traceroute
```

-k 옵션을 추가하여 `traceroute foss.org.my`의 결과가 가장 먼저 출력되도록 보장할 수 있습니다.

```sh
{
    echo foss.org.my ;
    echo debian.org ;
    echo freenetproject.org ;
} | parallel -k traceroute
```

마지막으로 Parallel은 셸 명령어들의 나열을 `cat file | bash` 처럼 병렬로 처리하기 위해서도 사용할 수도 있습니다. 파일명 목록을 파일로부터 넘겨받고, 이것들을 다루는 셸 명령어들을 생성하여 셸에게 넘겨주는 방식은 흔하지 않습니다만, Parallel을 이용하면 이 작업을 고속화할 수 있습니다. 파일에 셸 명령어들이 한 줄에 하나씩 들어있다고 가정합시다.

```sh
parallel -j 10 < file
```

이 코드는 (인수로 명령을 넘기지 않았으므로) 10개의 셸을 사용해 명령어를 실행합니다. 

## 3.3 Shell Functions

셸 함수는 나중에 실행할 명령어들을 하나의 이름을 사용하여 그룹화하는 방법입니다. 이들은 "평범한" 명령어처럼 실행됩니다. 간단한 다른 명령어처럼 셸 함수의 이름이 사용되면 이와 관련된 명령어들이 실행됩니다. 셸 함수는 현재 셸 컨텍스트에서 실행됩니다. 이를 처리하기 위한 별도의 프로세스는 만들어지지 않습니다.

함수는 다음 문법을 사용해서 선언됩니다.

```sh
fname () compound-command [ redirections ]
```

또는

```sh
function fname [()] compound-command [ redirections ]
```

이는 *fname*이라는 이름의 셸 함수를 정의합니다. `function` 예약어는 생략가능합니다. 만약 `function` 예약어를 사용한다면, 이름 뒤의 소괄호를 생략할 수 있습니다. 함수의 본체는 복합 명령어(Compound Commands 를 참조)인 *compound-command*입니다. 이 명령은 일반적으로 `{`와 `}`로 감싼 명령어 나열이며, 하나의 예외가 있습니다. 만약 `function` 예약어를 사용하고, 소괄호를 사용하지 않았다면 중괄호가 필수라는 점입니다. *compound-command*는 *fname*이 명령어의 이름으로 처리되었을 때 실행됩니다. 셸이 POSIX 모드에서 실행되는 경우, *fname*은 반드시 POSIX 에 준거한 이름을 가져야하며 특별한 빌트인 명령어들과 이름이 겹칠 수 없습니다. 기본 모드에서는 '$'를 포함하지 않고 따옴표로 감싸지 않은 이름이라면 함수 이름으로 사용할 수 있습니다. 셸 함수에 설정된 리다이렉션은 함수가 실행될 때 이용됩니다. 함수 정의는 `unset` 빌트인 명령어에 `-f` 옵션을 붙여서 삭제할 수 있습니다.

함수 정의 자체의 문법 에러가 발생하거나 같은 이름의 읽기 전용 함수가 이미 존재하지 않는 이상 종료 스테이터스는 0입니다. 실행했을 때 함수의 종료 스테이터스는 내부에서 마지막으로 실행된 명령의 종료 스테이터스입니다.

역사적인 이유로 대부분의 경우, 함수 본체를 감싸는 중괄호는 본체와 공백 또는 개행으로 분리되어야 합니다. 이는 중괄호가 예약어이므로 명령어 목록과 공백 문자 또는 다른 셸 메타문자와 구분되어 있어야만 인식 가능하기 때문입니다. 또한 중괄호를 사용할 때에는 명령어 목록은 반드시 세미콜론, '&', 개행으로 끝나야합니다.

함수가 실행되면 함수에 넘긴 인수는 실행 중에는 위치 매개변수가 됩니다. 위치 매개변수의 개수에 따라 전개되는 특별한 매개변수 '#'은 위치 매개변수의 변경에 따라서 갱신됩니다. 특별한 매개변수인 '0'는 변경되지 않습니다. `FUNCNAME` 변수의 첫번째 요소는 함수가 실행중인 동안 해당 함수의 이름을 반환합니다.

함수와 그 호출자의 셸 실행 환경은 다음 몇몇 예외를 제외하고 동일합니다: `DEBUG`와 `RETURN` 트랩은 `declare` 빌트인 명령어를 사용해 `trace` 속성을 부여하거나 `set` 빌트인 명령어를 통해 `-o functrace` 옵션을 켜지 않았다면, 상속되지 않습니다. 이 두 경우에서는 모든 함수가 `DEBUG`, `RETURN` 트랩을 상속합니다. 그리고 ERR 트랩은 `-o errtrace` 셸 옵션을 켜지 않았다면 상속되지 않습니다. `trap` 빌트인 명령어에 대해서는 Bourne Shell Builtins를 참조하세요.

`FUNCNEST` 변수는 0보다 큰 숫자를 설정했을 경우,  함수의 최대 중첩 횟수를 정의합니다. 이 상한을 초과하는 함수 호출은 명령어 전체를 중지시킵니다.

빌트인 명령어 `return`이 함수에서 실행되면, 함수의 실행은 즉시 완료되고, 함수 호출 다음에 오는 명령어로부터 실행을 재개합니다. `RETURN` 트랩에 연결된 명령어들은 실행을 재개하기 전에 실행됩니다. 함수가 완료될 때, 위치 매개변수와 매개변수 '#'의 값들은 함수 실행 직전에 가지고 있던 값으로 복원됩니다. 만약 `return`에 숫자 인수를 넘기면 이는 함수의 종료 스테이터스로 취급됩니다. 그렇지 않은 경우, 함수의 종료 스테이터스는 `return` 직전에 실행한 마지막 명령어의 종료 스테이터스가 됩니다.

`local` 빌트인 명령어를 사용하면 지역변수를 선언할 수 있습니다. 이 변수들은 선언된 함수와 함수가 호출한 명령어에서만 보입니다. 이는 다른 함수를 호출하는 셸 함수에서 특히 중요합니다.

지역 변수는 이전 스코프에서 선언한 같은 이름의 변수를 가립니다. 예를 들어, 함수에서 선언한 지역 변수가 같은 이름을 가진 전역 변수를 감춥니다. 참조와 대입은 지역 변수에 대해서 이루어지며, 전역 변수는 변경되지 않습니다. 함수가 종료되면 전역 변수가 다시 사용가능해집니다.

셸은 함수에 존재하는 변수의 가시성을 제어하기 위해 다이나믹 스코핑을 사용합니다. 다이나믹 스코핑에서 어떤 함수에서 보이는 변수와 그 값의 목록은 해당 함수가 실행되기까지 실행된 함수들의 호출 결과로 구성됩니다. 함수가 볼 수 있는 변수의 값은 그 호출자의 값에 의존하며, 호출자는 전역 스코프이거나, 다른 셸 함수일 수 있습니다. 또한 지역 변수 선언이 감추거나, 함수가 종료되었을 때 복원되는 값이기도 합니다.

예를 들어 *var*라는 지역 변수가 *func1* 함수에 정의되어 있고, *func1*은  *func2*를 호출한 경우, *func2*에서 참조하는 *var*는  *func1*의 지역 변수로 참조되며, 전역 변수 *var*는 감춰집니다.

다음 스크립트는 이 동작을 설명합니다. 실행이 끝나면 스크립트는 다음을 출력합니다.

```sh
In func2, var = func1 local
```

```sh
func1()
{
    local var='func1 local'
    func2
}

func2()
{
    echo "In func2, var = $var"
}

var=global
func1
```

`unset` 빌트인 명령어도 마찬가지로 다이나믹 스코프를 사용합니다. 만약 현재 스코프에 지역 변수가 존재한다면, `unset`은 이를 제거합니다. 그렇지 않다면 `unset`은 위에서 설명했듯이 호출 스코프를 따라가서 발견한 변수를 참조합니다. 현재 지역 스코프의 변수가 제거되었다면, 변수가 리셋되거나 함수가 반환될 때까지 제거된 상태를 유지합니다. 그 이후 함수가 종료되면 이전 스코프에 있는 변수의 값이 보이게 됩니다. 만약 `unset`이 이전 스코프의 값을 제거했다면, 그 값으로 감춰져있던 변수의 값이(있었다면) 보이게 됩니다.

함수의 이름과 정의는 `declare(typeset)` 빌트인 명령어에 `-f` 옵션을 넘기는 것으로 나열할 수 있습니다. `-F` 옵션은 함수의 이름(그리고 `extdebug` 옵션이 켜져있다면 소스 파일과 줄번호도)만을 출력합니다. 함수들은 `export` 빌트인 명령어에 `-f` 옵션을 넘겨서 서브셸에 자동으로 넘기도록 만들 수 있습니다.

함수는 재귀적일 수 있습니다. `FUNCNEST` 변수는 함수 호출 스택의 깊이를 제한하기 위해 사용될 수 있습니다. 기본 설정은 제한이 없는 상태입니다.

## 3.4 Shell Parameters
- Positional Parameters : 셸의 커맨드 라인 인수.
- Special Parameters : 특수 문자를 사용하는 매개변수.

매개변수는 값을 저장하고 있는 어떤 것입니다. 이는 이름, 숫자, 또는 아래에서 볼 수 있는 특별한 문자들 중 하나입니다. 변수는 식별 가능한 이름을 가지고 있는 매개변수입니다. 변수는 값과 0개 이상의 속성을 가집니다. 속성은 `declare` 빌트인 명령어를 통해 대입할 수 있습니다.

매개변수는 값이 대입될 때 설정됩니다. 널 문자열은 유효한 값입니다. 변수가 설정되면 `unset` 빌트인 명령어로만 제거할 수 있습니다.

변수 대입은 다음과 같은 형태의 식으로 이루어집니다.

```sh
name=[value]
```

만약 `value`가 주어지지 않았다면, 변수에는 널 문자열이 대입됩니다. 모든 값 대입에는 물결줄표 전개, 매개변수와 변수 전개, 명령어 치환, 산술 전개, 따옴표 제거가 적용됩니다. 만약 변수가 `integer` 속성을 가지고 있다면, `value`는 `$((...))` 전개를 사용하지 않더라도 산술 표현식으로 처리됩니다. 단어 나누기는 나중에 설명할 "$@"을 제외하고는 발생하지 않습니다. 파일명 전개도 발생하지 않습니다. 대입식은 `alias`, `declare`, `typeset`, `export`, `readonly`, `local` 빌트인 명령어의 인수로도 사용됩니다. POSIX 모드에서는 이러한 빌트인을 하나 이상의 `command` 빌트인으로 사용할 수 있으며, 대입식 사용법은 그대로 유지됩니다.

대입식으로 셸 변수나 배열의 인덱스에 값을 대입하는 상황에서, '+=' 연산자는 값을 추가하거나 변수의 이전 값에 더할 수 있습니다. 이는 `declare`와 같이 인수로 대입식을 받는 경우에도 적용됩니다. `integer` 속성이 적용된 변수에 '+='를 사용하는 경우, `value`는 산술 표현식으로 평가되며 변수의 현재 값에 더해집니다. 복합 대입을 사용해서 배열 변수에 '+=' 연산자를 사용한다면 ('='을 사용했을 때와 마찬가지로) 변수의 값은 제거되지 않으며, (일반적인 배열이라면) 새 값들은 배열의 가장 큰 인덱스값에서 1을 더한 위치부터 삽입되거나, 연상배열이라면 키-값 쌍으로 추가됩니다. 만약 문자열을 가진 변수가 대상이라면, `value`는 전개가 발생하며, 값의 뒷부분에 추가됩니다.

변수에 `declare`나 `local` 빌트인 명령어를 `-n` 옵션과 사용하여 `nameref` 속성을 추가하여 `nameref`, 또는 다른 변수에 대한 참조를 생성할 수 있습니다. 이를 통해 변수를 간접적으로 조작할 수 있습니다. nameref 변수를 참조, 제거, 속성을 수정(nameref 속성 자체를 사용하거나 변경하는 경우를 제외하고)한다면, 그 동작은 nameref 변수의 값에 지정된 변수에 대해서 이루어집니다. nameref는 일반적으로 셸 함수내에서 함수의 인수로 변수의 이름을 넘긴 경우, 이를 참조하기 위해서 사용됩니다. 예를 들어, 셸 함수의 첫번째 인수로 변수명을 넘겼다면, 함수 내부에서

```sh
declare -n ref=$1
```

를 실행하여 함수 내에서 첫번째 인수로 넘긴 변수 이름을 값으로 가지는 `ref`라는 nameref 변수를 생성할 수 있습니다. `ref`에 대한 참조와 대입, 속성에 대한 변경은 모두 `$1`로 넘겨진 값을 이름으로 가지는 변수에 대한 참조, 대입, 속성 변경이 됩니다.

만약 `for` 루프의 제어 변수가 nameref 속성을 가지고 있다면, 단어들의 목록은 셸 변수들의 목록이 될 수 있으며, 루프가 실행되는 동안, 이름 참조는 목록에 있는 각 변수들에 대한 참조를 순차적으로 생성하게 됩니다. 배열 변수는 nameref 속성을 가질 수 없습니다. 하지만, nameref 변수는 배열 변수와 그 요소를 참조할 수 있습니다. nameref 변수는 `unset` 빌트인 명령어와 `-n` 옵션을 사용하는 것으로 제거할 수 있습니다. 만약 `-n` 옵션 없이 `unset`을 실행한다면, nameref 변수가 참조하고 있는 변수가 제거됩니다.

### 3.4.1 Positional Parameters

위치 매개변수는 0이 아닌 하나 이상의 숫자로 표현되는 매개변수입니다. 위치 매개변수는 호출될 때 셸의 인수로부터 대입되며, `set` 빌트인 명령어로 재대입가능합니다. 위치 매개변수 `N`은 `${N}`로 참조 가능하며, N이 한 글자라면 `$N`으로도 참조할 수 있습니다. 위치 매개변수는 대입식으로는 대입할 수 없습니다. `set`과 `shift` 빌트인 명령어를 사용하여 변경할 수 있습니다. 위치 매개변수는 셸 함수가 호출되면 일시적으로 교체됩니다.

위치 매개변수가 한 글자 이상의 숫자로 구성되는 경우, 반드시 중괄호로 감싸야 합니다.

### 3.4.2 Special Parameters

셸은 몇몇 매개변수를 특별취급합니다. 이 매개변수들은 참조만 가능하며 대입은 불가능합니다.

- `*`: (\$\*) 위치 매개변수로 전개되며, 첫번째 값부터 시작됩니다. 전개가 큰따옴표 안에서 이루어지는 것이 아니라면, 각 위치 매개변수는 서로 다른 단어로 전개됩니다. 전개가 발생한 컨텍스트에서는 이 단어들에서 단어 나누기나 파일명 전개가 추가로 발생할 수 있습니다. 큰따옴표로 감싼 부분에서 전개가 발생했다면, 이는 각 매개변수가 `IFS` 특수 변수의 첫번째 문자로 구분되는 하나의 단어가 됩니다. 그러므로 "\$\*"는 "\$1c\$2c..."와 동일합니다. 여기에서 *c*는 `IFS` 변수값의 첫번째 문자입니다. 만약 `IFS` 변수가 없다면, 매개변수들은 공백으로 구분됩니다. 만약 `IFS`가 널(null)이라면 매개변수들은 구분자 없이 연결됩니다.
- `@`: (\$@) 위치 매개변수로 전개되며, 첫번째 값부터 시작됩니다. 단어 나누기가 적용된 후의 컨텍스트에서, 이는 각 위치 매개변수를 각각 다른 단어로 전개합니다. 만약 큰따옴표로 감싸져있는 것이 아니라면, 이 단어들은 단어 나누기가 다시 적용됩니다. 단어 나누기가 아직 발생하지 않은 컨텍스트라면, 이는 각 위치 매개변수들을 공백문자를 구분자로 하는 하나의 단어로 전개합니다. 만약 전개가 큰따옴표로 감싸진 부분에서 발생한다면, 단어 나누기가 적용되어 각 매개변수들은 다른 단어로 전개됩니다. 그러므로 `"$@"`는 `"$1"` `"$2"` ...와 동일합니다. 만약 단어 내부에서 큰따옴표 전개가 발생한다면 첫번째 매개변수의 전개는 원래 단어의 앞 부분과 결합하며, 마지막 매개변수의 전개는 원래 단어의 뒷 부분과 결합합니다. 만약 위치 매개변수가 존재하지 않는다면, `"$@"`와  `$@`는 아무것도 전개하지 않습니다.
- `#`: ($#) 위치 매개변수의 개수를 10진수로 전개합니다.
- `?`: ($?) 가장 최근에 실행된 포그라운드 파이프라인의 종료 스테이터스로 전개합니다.
- `-`: ($-, 하이픈) 기동시에 (`set` 빌트인 명령어로) 지정된 또는 셸 자신이 지정한 현재 옵션 플래그로 전개됩니다. 
- `$`: ($\$) 셸의 프로세스 ID로 전개됩니다. `()` 서브셸에서는 서브셸의 프로세스 ID가 아닌 호출한 셸의 프로세스 ID를 반환합니다.
- `!`: ($!) 비동기로 실행된 명령이나 `bg` 빌트인 명령어로 가장 최근에 백그라운드로 넘어간 잡의 프로세스 ID로 전개됩니다.
- `0`: (\$0) 셸이나 셸 스크립트의 이름으로 전개됩니다. 이는 셸 초기화 중에 설정됩니다. Bash가 명령어 파일과 함께 호출되었다면, `$0`는 해당 파일의 이름이 됩니다. 만약 Bash가 `-c` 옵션과 함께 기동했다면, `$0`은 실행될 문자열 뒤에 오는 첫번째 인수가 존재한다면, 그 값이 대입됩니다. 그렇지 않다면, \$0로 얻을 수 있는 Bash를 호출한 파일명이 됩니다.

## 3.5 Shell Expansions

전개는 명령줄이 토큰으로 분해된 이후에 발생합니다. 실행되는 전개는 7종류입니다.

- Brace Expansion : 중괄호 안의 표현식 전개.
- Tilde Expansion : ~ 문자 전개.
- Shell Parameter Expansion : Bash가 변수를 값으로 전개하는 방법.
- Command Substitution : 명령어의 출력을 인수로 사용하기.
- Arithmetic Expansion : 셸 전개에서 산술 계산을 사용하는 방법.
- Process Substitution : 명령어로부터 읽고 쓰는 방법.
- Word Splitting : 전개의 결과를 별개의 인수로 분리하는 방법.
- Filename Expansion : 파일명 일치 패턴을 지정하는 간결한 방법.
- Quote Removal : 따옴표 문자와 이스케이프 문자가 단어로부터 언제, 어떻게 제거되는지.

전개는 중괄호 전개, 물결줄표 전개, 매개변수와 변수 전개, 산술 전개, 명령어 치환(왼쪽부터 처리됩니다), 단어 분리, 파일명 전개 순서로 이루어집니다. 

지원하는 시스템에 한정하여 프로세스 치환도 사용가능합니다. 이는 물결줄표, 매개변수 변수, 산술 전개과 명령어 치환과 같은 시점에 실행됩니다.

이러한 전개들이 실행된 뒤, 원래의 단어에 나타나는 따옴표는 자신을 수식하는 경우를 제외하고 삭제됩니다(따옴표 제거).

중괄호 전개, 단어 분리, 파일명 전개에서만 전개의 결과로 단어 숫자가 증가할 수 있습니다. 다른 전개에서는 단일 단어를 단일 단어로만 전개합니다. 단, `"$@"`와 `$*`, `"${name[@]}"`, `${name[*]}`는 이 규칙의 예외입니다.

모든 전개가 끝나면 따옴표 제거가 실행됩니다.
### 3.5.1 Brace Expansion
중괄호 전개는 임의의 문자열을 생성할 수 있습니다. 이는 파일명 전개와 비슷하게 동작하지만, 생성된 파일명이 실제로 존재하지 않아도 됩니다. 패턴은 임의의 문자열로 시작할 수 있으며 중괄호로 감싼 쉼표로 구분된 문자열 또는 순서 표현식이 옵니다. 그 뒤에는 임의의 문자열이 올 수 있습니다. 중괄호 앞에 임의의 문자열이 있다면, 이는 중괄호 내부의 각 문자열의 접두사가 되며, 중괄호 뒤의 문자열은 각 문자열의 접미사가 됩니다. 전개는 왼쪽부터 오른쪽으로 순차로 진행됩니다.

중괄호 전개는 중첩될 수 있습니다. 전개된 각 문자열은 정렬되지 않습니다. 왼쪽에서 오른쪽으로의 순서는 보존됩니다. 예를 들어, 다음처럼 동작합니다.

```sh
bash$ echo a{d,c,b}e
ade ace abe
```

순서 표현식은 *{x..y[..incr]}* 의 형태를 가지며, *x*와 *y*는 숫자나 단일 문자입니다. 임의로 사용 가능한 증감자 *incr*는 정수입니다. 정수를 넘긴 경우, 표현식은 *x*부터 *y*까지 전개됩니다. '0'으로 시작하는 정수를 제공하여 각 단어가 같은 너비로 생성합니다. *x*나 *y*가 '0'으로 시작한다면, 셸은 생성된 모든 값이 같은 자릿수를 가지도록 필요에 따라 '0'을 접두사로 추가합니다. 문자를 넘긴 경우, 표현식을 기본 C 로케일을 사용하여 *x*부터 *y*까지 사전순으로 전개합니다. *x*와 *y*는 반드시 같은 타입이어야 합니다. 증감자가 있다면 이는 각 값의 차분으로 사용됩니다. 증감자의 기본값은 1이나 -1 중 적절한 값이 사용됩니다.

중괄호 전개는 다른 전개보다 먼저 실행되며, 다른 전개에서 사용되는 특별한 문자도 중괄호 전개 후에도 그대로 보존됩니다. 이는 원본 그대로입니다. Bash는 중괄호 사이의 텍스트나 전개의 컨텍스트에 어떠한 변경도 가하지 않습니다.

올바르게 구성된 중괄호 전개는 반드시 따옴표로 감싸지 않은 여는 중괄호와 닫는 중괄호를 반드시 가져야하며, 따옴표로 감싸지 않은 쉼표나 유효한 표현식을 가져야합니다. 올바르게 구성되지 않은 중괄호 전개는 적용되지 않습니다.

중괄호 전개의 일부로 취급되는 것을 막기 위해 `{`나 '`,`'를 백슬래시를 이용해 이스케이프할 수 있습니다. 매개변수 전개와의 충돌을 피하기 위해서 '`${`'는 중괄호 전개으로 인식되지 않으며, 닫는 중괄호가 나올때까지 중괄호 전개를 금지합니다.

이 구조는 위의 예제보다 긴 공통된 접두사를 가진 문자열을 생성하기 위한 간결한 표기로서 사용되는 경우가 많습니다. 다음은 예시입니다.

```sh
mkdir /usr/local/src/bash/{old,new,dist,bugs}
```

또는

```sh
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
```

### 3.5.2 Tilde Expansion

단어가 따옴표로 감싸지 않은 물결줄표 문자('~'), 따옴표로 감싸지 않은 첫번째 슬래시까지의 모든 문자(또는 해당하는 슬래시가 없다면 모든 문자)는 접두 물결줄표어(*tilde-prefix*)로 간주됩니다. 접두 물결줄표어에 따옴표로 감싼 문자가 없다면, 접두 물결줄표어의 물결줄표 뒤에 오는 문자는 로그인 가능한 이름으로 취급됩니다. 이 로그인 이름이 널 문자열이면 물결줄표는 `HOME` 셸 변수의 값으로 대체됩니다. `HOME`이 설정되어 있지 않으면 셸을 실행하는 사용자의 홈 디렉터리를 사용합니다. 그렇지 않으면 접두 물결줄표어는 식별된 로그인 이름에 대응하는 홈 디렉터리로 전개됩니다.

만약 접두 물결줄표어가 '~+'라면, `PWD` 셸 변수의 값이 접두 물결줄표어를 대체합니다. 접두 물결줄표어가 '~-'이고, 셸 변수 `OLDPWD`가 설정되어 있다면, 그 값으로 대체됩니다.

접두 물결줄표어에서 물결줄표 뒤의 문자가 숫자 N인 경우, 접두 물결줄표어는 그에 대응하는 디렉터리 스택의 요소로 대체됩니다. 이 표기법에서는 숫자 앞에 '+'나 '-'를 사용할 수 있습니다. 이는 `dirs` 빌트인 명령어를 접두 물결줄표의 물결줄표 이후의 문자열을 인수로 호출하는 경우 출력하는 값과 같습니다(The Directory Stack 참조). 접두 물결줄표어가 물결줄표를 제외하고, 앞에 '+'나 '-'가 없이 숫자만 오는 경우, '+'와 함께 호출한 것으로 간주합니다.

로그인 이름이 유효하지 않거나 물결줄표 전개가 실패하면 단어는 변경되지 않습니다.

각 변수 대입은 첫 '='나 ':'뒤에 오는 따옴표로 감싸지 않은 접두 물결줄표어의 존재를 확인합니다. 만약 존재한다면 물결줄표 전개가 실행됩니다. 따라서, `PATH`, `MAILPATH`, `CDPATH`에 물결줄표를 포함하는 파일명을 대입을 요구하는 경우, 셸은 전개된 값을 대입합니다.

다음 표는 Bash가 따옴표로 감싸지 않은 접두 물결줄표어를 어떻게 다루는지 보여줍니다.

- `~`
  `$HOME`의 값
- `~/foo`
  `$HOME/foo`
- `~fred/foo`
  유저 `fred`의 홈 디렉터리의 하위 디렉토리인 `foo`
- `~+/foo`
  `$PWD/foo`
- `~-/foo`
  `${OLDPWD-'~-'}/foo`
- `~N`
  '`dirs +N`'를 실행해서 출력된 문자열
- `~+N`
  '`dirs +N`'를 실행해서 출력된 문자열
- `~-N`
   '`dirs -N`'를 실행해서 출력된 문자열

또한 Bash는 변수 대입 조건을 충족하는 단어가 간단한 명령어의 인수로 등장하는 경우에도 물결줄표 전개를 실행합니다(Shell Parameters를 참조). POSIX 모드로 실행되는 Bash에서는 위에서 나열한 선언 명령을 제외하면 물결줄표 전개를 적용하지 않습니다.

### 3.5.3 Shell Parameter Expansion

'`$`'는 매개변수 전개, 명령어 치환, 산술 전개를 실행하는 문자입니다. 전개할 매개변수 이름과 기호는 중괄호로 감쌀 수 있습니다. 이는 선택사항입니다만, 뒤따라오는 문자와 결합해 이름으로 인식되어 전개되지 않도록 보호하는 역할을 합니다.

중괄호의 끝은 백슬래시로 이스케이프하지 않거나 따옴표로 감싸지 않은 첫번째 '`}`'이며, 이는 산술 전개, 명령어 치환, 매개변수 전개 도중이면 안됩니다.

매개변수 전개의 기본 형식은 *${parameter}*입니다. *parameter*의 값이 치환됩니다. *parameter*는 이전에 설명한 셸 매개변수(Shell Parameters를 참조) 또는 배열 참조(Arrays를 참조)입니다. *parameter*가 하나 이상의 숫자를 가지고 있는 위치 매개변수이거나 *parameter* 뒤에 이름의 일부로 해석하고 싶지 않은 문자가 오는 경우 중괄호를 사용해야 합니다.

*parameter*의 첫 문자가 느낌표(!)이고, *parameter*가 *nameref*가 아니라면, 간접 전개가 적용됩니다. Bash는 *parameter*의 나머지를 전개하여 생성한 값을 새 *parameter*로 사용합니다. 다시 말하면, 본래의 *parameter* 대신 전개된 값을 이후의 전개에서 사용합니다. 이를 간접 전개라고 부르며, 이 값은 물결줄표 전개, 매개변수 전개, 명령어 치환 및 산술 전개의 영향을 받습니다. *parameter*가 nameref라면  완전한 간접 전개를 수행하는 대신 *parameter*가 참조하는 변수의 이름으로 전개됩니다. 이에 대한 예외는 아래에서 설명할 ${!*prefix*\*}와 ${!*name*\[@]}의 전개입니다. 간접 전개를 사용하고 싶다면, 느낌표를 왼쪽 중괄호 바로 뒤에 두어야 합니다.

다음 각 예제에서 *word*는 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개가 적용됩니다.

부분 문자열 전개중이 아니라면, 아래에서 설명된 형식(예: '`:-`')을 사용하여 Bash는 매개변수가 설정되어있지 않거나 널인지 테스트합니다. 콜론을 생략하면 매개변수에 값이 설정되어있는지만 테스트합니다. 즉 콜론이 포함된 경우, 연산자는 *parameter*가 존재하는지, 그리고 그 값이 널이 아닌지 확인합니다. 만약 콜론이 생략되었다면 연산자는 존재 여부만 확인합니다.

- **${*parameter*:-*word*}**
  *parameter*가 존재하지 않거나 널이라면 *word*의 전개값으로 치환합니다. 그렇지 않다면 *parameter*로 치환합니다.
- **${*parameter*:=*word*}**
  *parameter*가 존재하지 않거나 널이라면 *word*이 *parameter*에 대입됩니다. 그 후에 *parameter*의 값으로 치환합니다. 위치 매개변수와 특수 매개변수는 이 방식으로 대입할 수 없습니다.
- **${*parameter*:?*word*}**
  *parameter*가 존재하지 않거나 널이라면 *word*의 전개 결과(또는 *word*가 존재하지 않는다면 그에 관한 메시지)를 표준 에러 출력과 셸에 출력하며, 인터랙티브 모드가 아니라면 종료합니다. 그렇지 않다면 *parameter*의 값으로 치환합니다.
- **${*parameter*:+*word*}**
  *parameter*가 존재하지 않거나 널이라면 치환하지 않습니다. 그렇지 않다면, *word*로 치환합니다.
- **${*parameter*:*offset*}**
- **${*parameter*:*offset*:*length*}**
  부분 문자열 전개라고 부릅니다. 이는 *parameter*의 값으로부터 *offset*으로 지정된 문자로부터 시작해 *length*개의 문자로 전개합니다. 만약 *parameter*가 '`@`', '`@`'나 '`*`'로 수식중인 순차 배열, 연상 배열의 이름이라면 결과가 다르며 아래에서 확인할 수 있습니다. 만약 *length*를 생략하면 *offset*으로 지정한 문자로부터 *parameter*의 마지막 문자까지 전개합니다. *length*와 *offset*은 산술 표현식입니다(Shell Arithmetic을 참조).
  만약 *offset*이 0보다 작은 숫자로 평가된다면, *parameter*의 값의 끝부분으로부터의 오프셋으로 사용됩니다. *length*가 0보다 작은 숫자로 평가된다면, 전개할 문자의 개수 제한이 아닌 *parameter*의 의 값의 마지막으로부터의 오프셋으로 인식되어 *offset*과 이 값의 사이에 있는 문자들로 전개됩니다. 음수 오프셋은 '`:-`' 전개와 의미가 겹치므로 이를 피하기 위해서 콜론과 적어도 하나의 스페이스의 간격을 두어야 합니다.
  다음은 매개변수와 배열의 첨자를 사용한 부분 문자열 전개 예시입니다.
  ```
  $ string=01234567890abcdefgh
  $ echo ${string:7}
  7890abcdefgh
  $ echo ${string:7:0}
  ```
  ```sh
  $ echo ${string:7:2}
  78
  $ echo ${string:7:-2}
  7890abcdef
  $ echo ${string: -7}
  bcdefgh
  $ echo ${string: -7:0}
  ```
  ```sh
  $ echo ${string: -7:2}
  bc
  $ echo ${string: -7:-2}
  bcdef
  $ set -- 01234567890abcdefgh
  $ echo ${1:7}
  7890abcdefgh
  $ echo ${1:7:0}
  ```
  ```sh
  $ echo ${1:7:2}
  78
  $ echo ${1:7:-2}
  7890abcdef
  $ echo ${1: -7}
  bcdefgh
  $ echo ${1: -7:0}
  ```
  ```sh
  $ echo ${1: -7:2}
  bc
  $ echo ${1: -7:-2}
  bcdef
  $ array[0]=01234567890abcdefgh
  $ echo ${array[0]:7}
  7890abcdefgh
  $ echo ${array[0]:7:0}
  ```
  ```sh
  $ echo ${array[0]:7:2}
  78
  $ echo ${array[0]:7:-2}
  7890abcdef
  $ echo ${array[0]: -7}
  bcdefgh
  $ echo ${array[0]: -7:0}
  ```
  ```sh
  $ echo ${array[0]: -7:2}
  bc
  $ echo ${array[0]: -7:-2}
  bcdef
  ```
  만약 매개변수가 '`@`'라면, 결과는 *offset*으로부터 시작하는 *length* 길이의 위치 매개변수입니다. 음수의 *offset*은 가장 마지막의 위치 매개변수의 뒷자리로부터 상대적인 위치를 계산하므로, -1은 가장 마지막 위치 매개변수로 평가됩니다. *length*가 0보다 작은 값일 경우 전개 에러가 발생합니다.
  다음은 위치 매개변수를 사용한 부분 문자열 전개 예시입니다.
  ```sh
  $ set -- 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
  $ echo ${@:7}
  7 8 9 0 a b c d e f g h
  $ echo ${@:7:0}
  ```
  ```sh
  $ echo ${@:7:2}
  7 8
  $ echo ${@:7:-2}
  bash: -2: substring expression < 0
  $ echo ${@: -7:2}
  b c
  $ echo ${@:0}
  ./bash 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
  $ echo ${@:0:2}
  ./bash 1
  $ echo ${@: -7:0}
  ```
  만약 *parameter*가 '`@`'나 '`*`' 첨자를 사용하는 순차 배열라면, 결과는 \${*parameter*\[offset]} 요소로부터 *length*개의 요소가 됩니다. 음수 *offset*은 지정된 배열의 인덱스 최대값보다 하나 큰 값으로부터 상대값을 취합니다. *length*가 0보다 작은 경우 전개 에러가 발생합니다.
  다음은 순차 배열을 사용한 부분 문자열 전개 예시입니다.
  ```sh
  $ array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h)
  $ echo ${array[@]:7}
  7 8 9 0 a b c d e f g h
  $ echo ${array[@]:7:2}
  7 8
  $ echo ${array[@]: -7:2}
  b c
  $ echo ${array[@]: -7:-2}
  bash: -2: substring expression < 0
  $ echo ${array[@]:0}
  0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h
  $ echo ${array[@]:0:2}
  0 1
  $ echo ${array[@]: -7:0}
  ```
  부분 문자열 전개를 연상 배열에 적용하는 것은 미정의 동작입니다.
  부분 문자열 색인은 위치 매개변수가 사용되지 않았다면 0부터 시작합니다만, 사용했다면 1부터 시작합니다. *offset*으로 0을 지정하고, 위치 매개변수를 사용했다면 `$0`이 리스트의 선두에 옵니다.
- **${!*prefix*\*}**
- **${!*prefix*@}**
  *prefix*로 시작하는 변수의 이름들로 전개합니다. 각 값은 `IFS` 특수 변수의 첫번째 문자로 구분됩니다. 만약 '`@`'이 사용되고 전개가 큰따옴표 내부에 있다면 각 변수 이름은 별개의 단어로 전개됩니다.
- **${!*name*\[@]}**
- **${!*name*\[\*]}**
  *name*이 배열 변수일 경우, *name*에 대입된 배열의 키 리스트로 전개됩니다. 만약 *name*이 배열 변수가 아니고, 변수가 존재한다면 0으로, 그렇지 않다면 널로 전개됩니다. '`@`'이 사용되고, 전개가 큰 따옴표 내부에 있다면, 각 키는 별개의 단어로 전개됩니다.
- **${#*parameter*}**
  *parameter*를 전개한 값의 문자 개수로 치환됩니다. 만약 *parameter*가 '`*`'나 '`@`'라면, 위치 매개변수의 갯수로 치환됩니다. 만약 *parameter*가 '`*`'와 '`@`'를 사용하는 배열의 첨자표기라면 배열이 가진 요소의 개수로 치환됩니다. 만약 *parameter*가 음수를 첨자로 가지는 이름이라면, 숫자는 *parameter*의 인덱스 최대값보다 하나 큰 숫자로부터의 상대값으로 취급되므로, -1은 마지막 요소를 참조합니다.
- **${*parameter*#*word*}**
- **${*parameter*##*word*}**
  *word*는 나중에 설명하는 규칙(Pattern Matching을 참조)에 따르는 패턴을 생성하고 일치 검사를 하기 위해서 전개됩니다. *parameter*의의 전개된 값의 첫머리에 패턴이 일치하면, 전개의 결과는 *parameter*와 일치한 가장 짧은 패턴('`#`'의 경우)이나 가장 긴 패턴('`##`'의 경우)이 제거된 값입니다. 만약 *parameter*가 '`*`'나 '`@`'라면 각 위치 매개변수에 대해서 삭제가 실행되며 전개의 결과는 삭제가 완료된 각 요소의 리스트입니다. 만약 *parameter*가 '`*`'와 '`@`'를 사용하는 배열의 첨자표기라면 패턴 삭제 동작은 배열의 각 요소에 대해서 수행되며, 전개의 결과는 삭제가 완료된 각 요소의 리스트입니다.
- **${*parameter*%*word*}**
- **${*parameter*%%*word*}**
  *word*는 나중에 설명하는 규칙(Pattern Matching을 참조)에 따르는 패턴을 생성하고 일치 검사를 하기 위해서 전개됩니다. *parameter*의의 전개된 값의 끄트머리에 패턴이 일치하면, 전개의 결과는 *parameter*와 일치한 가장 짧은 패턴('`%`'의 경우)이나 가장 긴 패턴('`%%`'의 경우)이 제거된 값입니다. 만약 *parameter*가 '`*`'나 '`@`'라면 각 위치 매개변수에 대해서 삭제가 실행되며 전개의 결과는 삭제가 완료된 각 요소의 리스트입니다. 만약 *parameter*가 '`*`'와 '`@`'를 사용하는 배열의 첨자표기라면 패턴 삭제 동작은 배열의 각 요소에 대해서 수행되며, 전개의 결과는 삭제가 완료된 각 요소의 리스트입니다.
- **${*parameter*/*pattern*/*string*}**
  *pattern*은 파일명 전개와 동일한 패턴을 생성합니다. *parameter*를 전개하고, *pattern*과 일치하는 가장 긴 일치 결과를 `string`으로 치환합니다. 일치는 나중에 설명하는 규칙(Pattern Matching을 참조)에 따라서 수행됩니다. 만약 *pattern*을 '`/`'로 시작하면, 모든 *pattern*의 일치 결과를 *string*으로 치환합니다. 일반적으로 첫번째 일치만을 치환합니다. *pattern*을 '`#`'으로 시작하면 *parameter*를 전개한 값의 첫머리와 일치해야 합니다. *pattern*을 '`%`'로 시작하면 *parameter*를 전개한 값의 끝머리와 일치해야 합니다. 만약 *string*이 널이라면 *pattern*과 일치한 결과는 제거되며 *pattern* 뒤의 `/`를 생략할 수 있습니다. 만약 셸 옵션 `nocasematch`(The Shopt Builtin을 참조)가 켜져있다면 일치하는지 검사할 때 대소문자를 구별하지 않습니다. 만약 *parameter*가 '`@`'나 '`*`'라면 치환 동작은 각 위치 매개변수에 대해서 수행되며, 전개의 결과는 치환이 완료된 각 요소의 리스트입니다.
- **${*parameter*^*pattern*}**
- **${*parameter*^^*pattern*}**
- **${*parameter*,*pattern*}**
- **${*parameter*,,*pattern*}**
  이 전개는 *parameter*의 대소문자를 변경합니다. *pattern*이 파일명 전개와 동일한 패턴을 생성합니다. *parameter*를 전개한 결과의 각 문자에 대해서 *pattern*으로 검사하며, 만약 일치한다면 대문자는 소문자로, 소문자는 대문자로 변경합니다. 패턴은 한 글자만을 검사해야합니다. '`^`' 연산자는 *pattern*에 일치하는 소문자를 대문자로 변경합니다. '`,`' 연산자는 일치하는 대문자를 소문자로 변경합니다. '`^^`'와 '`,,`'는 전개된 값에서 일치한 모든 문자에 대해서 변경을 수행합니다. '`^`'와 '`,`'는 전개된 값에서 일치한 첫번째 문자만을 변경합니다. *pattern*이 생략된다면, 모든 문자와 일치하는 '`?`'가 주어진 것처럼 동작합니다. *parameter*가 '`@`'나 '`*`'라면 대소문자 변경 동작은 각 위치 매개변수에 대해서 수행되며, 전개의 결과는 치환이 완료된 각 요소의 리스트입니다. 만약 *parameter*가 '`@`'와 '`*`'를 사용하는 배열의 첨자표기라면 패턴 삭제 동작은 배열의 각 요소에 대해서 수행되며, 전개의 결과는 삭제가 완료된 각 요소의 리스트입니다.
- **${*parameter*@*operator*}**
  *operator*의 값에 따라서 *parameter*를 변환하거나, *parameter* 자신의 정보로 전개됩니다. *operator*는 단일 문자입니다.
  - **U**
    *parameter*의 알파벳 소문자를 대문자로 변환합니다.
  - **u**
    *parameter*의 첫 글자가 알파벳이라면, 이를 대문자로 변환합니다.
  - **L**
    *parameter*의 알파벳 대문자를 소문자로 변환합니다.
  - **Q**
    입력으로 재활용할 수 있도록 *parameter*를 따옴표로 감쌉니다.
  - **E**
    $'...' 구조처럼 *parameter*를 백슬래시로 이스케이프합니다.
  - **P**
    *parameter*가 프롬프트 문자열(Controlling the Prompt를 참조)인 것처럼 전개합니다.
  - **A**
    *parameter*를 대입식이나 `declare` 명령의 형태로 변환합니다. 이를 평가하면 *parameter*를 같은 속성과 값을 가진 상태로 재생성할 수 있습니다. 
  - **K**
    *parameter*의 가능한 따옴표로 감싼 버전을 생성합니다. 단 순차/연상 배열의 값들은 따옴표로 감싼 키-값 쌍(Arrays를 참조)의 나열로서 출력합니다.
  - **a**
    *parameter*의 속성값으로 구성된 문자열로 전개합니다.

  *parameter*가 '`@`'나 '`*`'라면 대소문자 변경 동작은 각 위치 매개변수에 대해서 수행되며, 전개의 결과는 치환이 완료된 각 요소의 리스트입니다. 만약 *parameter*가 '`@`'와 '`*`'를 사용하는 배열의 첨자표기라면 패턴 삭제 동작은 배열의 각 요소에 대해서 수행되며, 전개의 결과는 삭제가 완료된 각 요소의 리스트입니다.
  전개의 결과에는 나중에 설명할 단어 분리와 파일명 확장이 적용됩니다.
### 3.5.4 Command Substitution
명령어 치환을 사용하면 명령어의 출력이 명령어 자체를 대체 할 수 있습니다. 명령어 치환은 명령어를 다음과 같이 감쌀 때 발생합니다.

```sh
$(command)
```

또는

```sh
`command`
```

Bash는 서브셸 환경에서 `command`를 실행하고 이 명령어의 표준 출력로 원 명령어를 치환합니다. 이 때 출력의 마지막에 개행 문자가 하나 이상 존재한다면 제거됩니다. 도중의 개행문자는 제거되지 않습니다만, 단어 분리 중에 제거될 수 있습니다. 명령어 치환 $(cat *file*)은 동일한 동작을 하지만 더 빠른 $(< *file*)로 작성할 수 있습니다.

오래된 스타일인 백틱을 사용하는 명령어 치환에서 백틱은 '$', '\`', '\\' 뒤에 오는 경우를 제외하면 리터럴 자체의 의미를 유지합니다. 백슬래시를 사용하지 않는 첫번째 백틱에서 명령어 치환이 종료됩니다. $(`command`) 를 사용하는 경우, 모든 소괄호 사이의 문자는 명령어가 됩니다. 특수한 처리는 없습니다.

명령어 치환은 중첩할 수 있습니다. 백틱과 함께 중첩하려면, 내부의 백틱을 백슬래시로 이스케이프하세요.

큰따옴표로 감싼 곳에서 명령어 치환이 있다면, 단어 분리와 파일명 전개는 실행되지 않습니다.
### 3.5.5 Arithmetic Expansion
산술 전개는 산술 표현식을 평가하고, 그 결과로 치환합니다. 산술 전개의 형식은 다음과 같습니다.

```
$(( expression ))
```

표현식은 큰따옴표로 감싼 것처럼 취급됩니다만, 소괄호 안의 큰따옴표는 특별취급하지 않습니다. 표현식의 모든 토큰에서 매개변수와 변수의 전개, 명령어 치환, 따옴표 제거가 실행됩니다. 산술 표현식은 중첩될 수 있습니다.

평가는 이후에 설명할 규칙에 따라서 실행됩니다(Shell Arithmetic을 참조). 만약 표현식이 올바르지 않다면, Bash는 실패 메시지를 표준 에러로 출력하고, 치환이 이루어지지 않습니다.

### 3.5.6 Process Substitution
프로세스 치환으로 프로세스의 입력이나 출력을 파일명을 통해 참조할 수 있습니다. 이는 다음과 같은 형식입니다.

```sh
<(list)
```

또는

```sh
>(list)
```

프로세스 리스트는 비동기로 실행되며, 그 입력과 출력은 파일명으로서 나타납니다. 이 파일명은 전개의 결과로서 현재의 명령어의 인수로 넘겨집니다. <(`list`) 형식을 사용한 경우, 파일에 대한 쓰기 명령은 `list`에 대한 입력 명령이 됩니다. <(`list`) 형식을 사용하는 경우, `list`의 출력을 얻기 위해 인수로 넘긴 파일을 읽습니다. `>`와 `<`와 왼쪽 소괄호 사이에는 스페이스를 사용할 수 없습니다. 만약 스페이스를 사용하면 이 구조는 리다이렉션으로 인식될 것입니다. 프로세스 치환은 이름을 갖는 파이프(FIFO)나 파일을 열기 위해 이름을 붙일 수 있는 `/dev/fd`를 지원하는 시스템에서 사용할 수 있습니다.

프로세스 치환이 가능한 경우, 이는 매개변수와 변수 전개, 명령어 치환, 산술 전개와 동시에 실행됩니다.

### 3.5.7 Word Splitting

셸은 매개변수의 전개, 명령어 치환, 산술 전개의 결과로부터 큰따옴표로 감싸지 않은 부분을 찾아서 단어를 분리합니다.

셸은 `$IFS`의 각 문자를 구분기호로 사용하며, 이 문자를 필드의 종료지시자로 사용해 다른 전개의 결과를 단어로 분리합니다. 만약 `IFS`가 없거나, 그 값이 기본값인 <space><tab><newline>인 경우, 결과의 처음과 마지막에 존재하는 <space>, <tab>, <newline>의 나열은 무시되며, 처음과 마지막을 제외한 `IFS` 문자로 이루어진 나열은 단어를 분리합니다. `IFS`가 기본값이 아닌 값을 가지고, `IFS` 문자에 공백 문자(스페이스, 탭, 개행. 이를 `IFS` 공백 문자라고 합니다)가 포함되어있는 경우, 단어의 처음과 마지막에 있는 공백 문자은 무시됩니다. `IFS`에 포함된 `IFS` 공백 문자가 아닌 문자는 인접하는 `IFS` 공백 문자와 함께 필드를 분리합니다. `IFS` 공백 문자의 나열 역시 구분기호로 취급됩니다. `IFS`의 값이 널일 경우, 단어 분리는 발생하지 않습니다.

명시적인 널 인수(""나 '')는 공백문자로 명령어에 넘겨집니다. 따옴표로 감싸지 않은 암묵의 널 인수는 값을 가지지 않는 매개변수 전개의 영향으로 제거됩니다. 값이 없는 매개변수가 큰따옴표 안에서 전개된다면, 널 인수는 유지되며, 명령어에 공백 문자열로 넘겨집니다. 따옴표로 감싼 널 인수가 전개의 결과가 널이 아닌 단어의 일부로 출현하는 경우, 널 인수는 제거됩니다. 예를 들어 `-d''`는 단어 분리와 널 인수 제거후 `-d`가 됩니다.

전개가 발생하지 않는다면 분리도 발생하지 않습니다.
### 3.5.8 Filename Expansion

`-f` 옵션(The Set Builtin을 참조)이 켜져있지 않다면, Bash는 단어 분리 후 각 단어에서 '*', '?', '\['를 찾습니다. 이들이 하나라도 존재하고, 따옴표로 감싸져있지 않다면, 단어는 `pattern`으로 간주되며, 패턴(Pattern Matching을 참조)에 일치하는 알파벳순으로 정렬된 파일명로 대체됩니다. 만약 `nullglob` 셸옵션이 꺼져있는 상황에서 일치하는 파일명을 찾지 못했다면 단어는 대체되지 않고 유지됩니다. 만약 `nullglob` 옵션이 켜져있다면 일치하는 파일명을 찾지 못할 경우, 단어를 삭제합니다. `failglob` 셸옵션이 켜져있고, 일치하는 파일명을 찾지 못했을 경우, 에러 메시지를 출력하고 명령어는 실행되지 않습니다. 만약 `nocaseglob` 셸옵션이 켜져있을 경우, 대소문자를 구분하지 않고 일치여부를 검사합니다.

파일명 전개를 위해 패턴이 사용될 때, 셸옵션 `dotglob`이 켜져있지 않다면 파일명 처음이나 슬래시 뒤의 '.' 문자는 반드시 명시적으로 일치해야합니다. 파일명 '.'나 '..'는 `dotglob` 옵션이 켜져있다고 하더라도 언제나 명시적으로 일치해야합니다. 그렇지 않은 경우, '.' 문자는 특별하게 취급되지 않습니다.

파일명 일치검사를 할 때, 슬래시는 언제나 명시적으로 슬래시를 통해 일치해야 합니다. 그 이외의 경우에는 나중에 설명할 특수 패턴 문자(Pattern Matching을 참조)를 통해 일치시킬 수 있습니다.

`nocaseglob`, `nullglob`, `failglob`, `dotglob`에 대해서는 The Shopt Builtin의 `shopt` 설명을 참조하세요.

`GLOBIGNORE` 셸변수는 파일명의 패턴 일치 집합을 제한할 때 사용합니다. 만약 `GLOBIGNORE`가 설정되어 있다면, `GLOBIGNORE`에 존재하는 패턴과도 일치하는 파일명은 일치한 목록에서 제거됩니다. 만약 `nocaseglob` 옵션이 켜져있다면, `GLOBIGNORE`의 패턴과 일치 검사를 할 때 대소문자를 구분하지 않습니다. `GLOBIGNORE`가 설정되어있고, 널이 아니라면 파일명 '.'와 '..'는 언제나 무시됩니다. 그러나 `GLOBIGNORE`를 널이 아닌 값으로 설정하면 `dotglob` 셸 옵션이 켜집니다. 그러므로 `.`으로 시작하는 모든 파일명과 일치하게 됩니다. '.'로 시작하는 모든 파일명을 무시하는 이전 동작으로 돌아가려면 '.*'를 `GLOBIGNORE`의 패턴에 추가하세요. `GLOBIGNORE`가 설정되어있지 않다면, `dotglob` 옵션은 꺼집니다.

#### 3.5.8.1 Pattern Matching

아래에서 설명할 특수 패턴 문자를 제외한 패턴에 나타나는 모든 문자는 자기 자신과 일치합니다. NUL 문자는 패턴에서 사용할 수 없습니다. 백슬래시는 뒤에 오는 문자를 이스케이프합니다. 이스케이프용 백슬래시는 일치 검사시에 제거됩니다. 특수 패턴 문자는 그 자체로 일치시키고 싶을 경우, 반드시 따옴표로 감싸야합니다.

특수 패턴 문자는 다음과 같은 의미를 가지고 있습니다.

- **\***
  널을 포함한 모든 문자열에 일치합니다. `globstar` 셸옵션이 켜진 상태에서 파일명 전개에서 '*'를 사용하면, 두 개의 인접한 '*'가 하나의 패턴이 되며, 이는 모든 파일과 일치하거나 0개 이상의 디렉터리, 하위 디렉터리와 일치합니다. 두 개의 인접한 '*' 뒤에 '/'를 사용하는 경우 디렉터리나 하위 디렉터리만 일치합니다.
- **?**
  임의의 한 문자와 일치합니다.
- **\[…]**
  대괄호로 감싼 문자들 중 하나와 일치합니다. 하이픈으로 구분된 한 쌍의 문자는 범위 표현식입니다. 현재의 로케일의 문자셋의 순서를 이용하여, 표현식에 사용된 문자들을 포함한 범위에 들어있는 임의의 문자와 일치합니다. 만약 '\[' 뒤에 오는 첫번째 문자가 '!'나 '^'인 경우, 대괄호에 들어있지 않은 문자와 일치합니다. '-'는 처음이나 마지막에 나타날 경우, 자기 자신과 일치합니다. ']'는 집합의 첫번째 문자로 포함하여 일치시킬 수 있습니다. 범위 표현식의 문자들의 정렬 순서는 현재 로케일, 설정 되어 있다면 `LC_COLLATE`와 `LC_ALL` 셸 변수에 의해 결정됩니다.

  예를 들어 기본 C 로케일에서 '[a-dx-z]'는 '[abcdxyz]'와 동일합니다. 많은 로케일에서는 사전순으로 문자를 정렬하며, 이러한 로케일에서 '[a-dx-z]'는 일반적으로 '[abcdxyz]'와 동일하지 않으며, 실제로는 '[aBbCcDdxXyYz]'와 동일합니다. 전형적인 대괄호 표현식의 범위 표현 방식을 사용하고 싶다면, `LC_COLLATE`나 `LC_ALL` 환경 변수를 'C'로 지정하여 C 로케일을 사용하거나 `globasciiranges` 셸옵션을 켜야 합니다.

  '\['와 ']' 사이의 *character class*는 \[:*class*:] 문법을 통해서 지정할 수 있습니다. *class*는 POSIX 표준에서 정의된 다음 클래스를 따릅니다.
  ```
  alnum   alpha   ascii   blank   cntrl   digit   graph   lower
  print   punct   space   upper   word    xdigit
  ```
  문자 클래스는 해당 클래스에 속하는 임의의 문자와 일치합니다. `word` 문자 클래스는 영문자, 숫자, '_'와 일치합니다.

  '\['와 ']' 사이의 *equivalence class*는 \[=*c*=] 문법으로 지정할 수 있습니다. 이는 문자 *c*와 (현재 로케일에서 정의된) 동일한 정렬순을 가지는 모든 문자들과 일치합니다.

  '\['와 ']' 사이의 \[.*symbol*.] 문법은 정렬 기호 *symbol*과 일치합니다.

`shopt` 빌트인에서 `extglob` 셸옵션을 켰다면, 몇몇 확장 패턴 일치 연산자를 사용할 수 있습니다. 다음 설명에서 *pattern-list*는 '|'로 구분된 하나 이상의 패턴 리스트입니다. 다음의 패턴을 하나 이상 결합하여 복합 패턴을 만들 수 있습니다.
- **\?(*pattern-list*)**
  주어진 패턴들이 없거나 한 번 출현하면 일치합니다.
- **\*(*pattern-list*)**
  주어진 패턴들이 0개 이상 출현하면 일치합니다.
- **\+(*pattern-list*)**
  주어진 패턴들이 1개 이상 출현하면 일치합니다.
- **\@(*pattern-list*)**
  주어진 패턴 중 하나와 일치합니다.
- **\!(*pattern-list*)**
  주어진 패턴 모두가 출현하지 않는 경우 일치합니다.

긴 문자열에서의 복잡한 확장 패턴 일치는 느리며, '|'를 여럿 포함하고 있거나, 문자열이 여러개의 패턴 일치를 포함하는 경우 특히 그렇습니다. 짧은 문자열에 대해서 각각 일치 검사를 수행하거나, 하나의 긴 문자열 대신 문자열의 배열을 사용하여 빠르게 만들 수 있습니다.
### 3.5.9 Quote Removal
앞에서 설명한 전개가 적용된 후, 어떤 전개의 생성 결과가 아닌, 따옴표로 감싸지 않은 모든 문자 '\\', '\'', '"'는 제거됩니다.
## 3.6 Redirections
셸에서는 특수한 표기 방식을 사용하여 명령어를 실행하기 전에 해당 명령어의 입력과 출력을 어디로 *리다이렉트*할 지 지정할 수 있습니다. 명령어는 리다이렉션을 이용해 파일 핸들을 복제, 열기, 닫기, 다른 파일에 대한 참조 만들기 그리고 명령어가 읽고 쓸 파일을 변경할 수 있습니다. 또한 리다이렉션은 현재 셸 실행 환경의 파일 핸들을 변경하기 위해서 사용할 수 있습니다. 다음의 리다이렉션 연산자는 앞에 두거나, 뒤에 두거나, 단순한 명령이라면 임의의 위치에 둘 수 있습니다. 리디렉션은 나타나는 순서대로 왼쪽에서 오른쪽으로 처리됩니다. 

파일 디스크립터 숫자가 앞에 올 수 있는 각 리다이렉션은 그 대신에 {*varname*}와 같은 형식으로 앞에 둘 수 있습니다. 이 경우, 셸은 `>&-`와 `<&-`를 제외한 각 리다이렉션 연산자에 10보다 큰 파일 디스크립터를 준비하고, 이를 {*varname*}에 대입합니다. 만약 {*varname*} 이 `>&-`와 `<&-` 앞에 오는 경우, *varname*의 값은 닫을 파일 디스크립터를 정의합니다. 만약 {*varname*}이 있다면, 리다이렉션은 셸 프로그래머가 파일 디스크립터의 생애주기를 직접 관리할 수 있도록 명령어의 스코프를 무시하고 *varname*을 유지합니다.

이후의 설명에서 파일 디스크립터의 숫자가 생략되고 리다이렉션 연산자의 첫글자가 '<'라면, 리다이렉션은 표준 출력(파일 디스크립터 0)을 참조하며, 리다이렉션 연산자의 첫번째 글자가 '>'라면 리다이렉션은 표준 출력(파일 디스크립터 1)을 참조합니다.

이후의 설명에서 리다이렉션 연산자 뒤에 오는 단어는 별도의 설명이 없는 한, 중괄호 전개, 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개, 따옴표 제거, 파일명 전개, 단어 분리가 적용됩니다. 만약 전개 결과가 2개 이상의 단어라면 Bash는 에러를 보고합니다.

리다이렉션의 순서에는 중요한 의미가 있습니다. 예를 들어, 다음 명령어는 표준 출력(파일 디스크립터 1)과 표준 에러(파일 디스크립터 2)를 모두 *dirlist*라는 파일로 전송합니다.

```sh
ls > dirlist 2>&1
```

반면 다음 명령어는 표준 출력이 *dirlist*로 전송하도록 설정하기 전의 표준 출력의 사본으로부터 표준 에러가 만들어지기 때문에 원래의 표준 출력만을 *dirlist*로 전송합니다.

```sh
ls 2>&1 > dirlist
```

Bash는 다음 테이블에서 설명하는 몇몇 파일명을 리다이렉션에서 사용될 때 특별취급합니다. 만약 Bash가 동작하고 있는 운영체제가 이 특별한 파일들을 제공한다면 Bash는 그것들을 사용합니다. 만약 존재하지 않는다면 아래에서 설명된 행동을 내부에서 에뮬레이트합니다.

- **/dev/fd/*fd***
  *fd*가 유효한 정수라면, 파일 디스크립터 *fd*를 복사합니다.
- **/dev/stdin**
  파일 디스크립터 0을 복사합니다.
- **/dev/stdout**
  파일 디스크립터 1을 복사합니다.
- **/dev/stderr**
  파일 디스크립터 2를 복사합니다.
- **/dev/tcp/*host*/*port***
  *host*가 유효한 호스트 이름이거나, 인터넷 주소이고, *port*가 포트 번호를 가리키는 정수이거나 서비스 이름이면, Bash는 그에 대응하는 TCP 소켓을 열려고 시도합니다.
- **/dev/udp/*host*/*port***
  *host*가 유효한 호스트 이름이거나, 인터넷 주소이고, *port*가 포트 번호를 가리키는 정수이거나 서비스 이름이면, Bash는 그에 대응하는 UDP 소켓을 열려고 시도합니다.

파일을 열거나 만들 수 없는 경우 리다이렉션은 실패합니다.

9보다 큰 파일 디스크립터를 사용하는 리다이렉션을 사용할 때는 셸이 내부에서 사용하는 파일 디스크립터와 충돌할 가능성이 있으므로 조심해야 합니다.

### 3.6.1 Redirecting Input

입력 리다이렉션은 *word* 를 전개하여 얻은 이름을 사용하는 파일을 열고, 파일 디스크립터 *n*으로부터 읽을 수 있도록 합니다. *n*이 지정되지 않았다면 표준 입력(파일 디스크립터 0)을 사용합니다.

입력 리다이렉션의 일반적인 형식은 다음과 같습니다.

```sh
[n]<word
```

### 3.6.2 Redirecting Output

출력 리다이렉션은 *word* 를 전개하여 얻은 이름을 사용하는 파일을 열고, 파일 디스크립터 *n*이 쓸 수 있도록 합니다. *n*이 지정되지 않았다면 표준 출력(파일 디스크립터 1)을 사용합니다. 대상 파일이 존재하지 않는다면 만듭니다. 만약 파일이 존재하는 경우 파일의 내용물을 지우고 빈 파일로 만듭니다.

출력 리다이렉션의 일반적인 형식은 다음과 같습니다.

```sh
[n]>[|]word
```

리다이렉션 연산자가 '>'이고 `set` 빌트인에서 `noclobber` 옵션을 켜고 있다면, *word*의 전개 결과로 얻은 파일명이 존재하고, 이 파일이 일반 파일이라면 리다이렉션이 실패합니다. 만약 리다이렉션 연산자가 '>|'이거나 '>'이고, `noclobber` 옵션이 꺼져있다면, `word`를 전개한 파일명이 존재하더라도 리다이렉션을 시도합니다.

### 3.6.3 Appending Redirected Output

이러한 방식의 출력 리다이렉션은 *word*를 전개하여 얻은 파일을 열고, 파일 디스크립터 *n*이 추가로 쓸 수 있도록 합니다. *n*이 지정되지 않았다면 표준 출력(파일 디스크립터 1)을 사용합니다. 대상 파일이 존재하지 않는다면 만듭니다.

출력 추가의 일반적인 형식은 다음과 같습니다.

```sh
[n]>>word
```

### 3.6.4 Redirecting Standard Output and Standard Error

이 구조는 표준 출력(파일 디스크립터 1)과 표준 에러 출력(파일 디스크립터 2)를 모두 *word*의 전개로 얻은 파일명으로 재전송합니다.

표준 출력과 표준 에러를 재전송하는 형식은 두 가지가 있습니다.

```sh
&>word
```

와

```sh
>&word
```

입니다. 첫번째 형식이 일반적으로 선호됩니다. 이 구조는 다음과 동일합니다.

```sh
>word 2>&1
```

두번째 형식을 사용하면 *word*는 숫자나 '-'로 전개되지 않을 수 있습니다. 이 경우, 호환성 문제로 다른 리다이렉션 연산자가 적용됩니다(Duplicating File Descriptors를 참조).

### 3.6.5 Appending Standard Output and Standard Error

이 구조는 표준 출력(파일 디스크립터 1)과 표준 에러 출력(파일 디스크립터 2)를 모두 *word*의 전개로 얻은 파일에 추가하도록 재전송합니다.

표준 출력과 표준 에러를 추가하도록 재전송하는 형식은 다음과 같습니다.

```sh
&>>word
```

이는 다음과 동일합니다(Duplicating File Descriptors를 참조).

```sh
>>word 2>&1
```

### 3.6.6 Here Documents

이 타입의 리다이렉션은 셸에게 현재 소스로부터 (뒤따라오는 공백 문자가 없이) *word*를 포함하는 줄이 나타날 때까지를 입력으로 읽도록 지시합니다. 읽어들인 모든 줄은 표준 입력(파일 디스크립터 *n*이 지정되어 있다면 *n*)인 것처럼 취급됩니다.

히어독의 형식은 다음과 같습니다.

```sh
[n]<<[-]word
        here-document
delimiter
```

*word*는 매개변수와 변수 전개, 명령어 치환, 산술 전개, 파일명 전개가 일어나지 않습니다. 만약 *word*의 일부분을 따옴표로 감쌌다면, *delimiter*는 *word*에서 따옴표를 제거한 결과가 되며, 히어독에 있는 줄들은 전개되지 않습니다. 만약 *word*를 따옴표로 감싸지 않았다면, 히어독의 모든 줄은 매개변수 전개, 명령어 치환, 산술 전개가 적용되며, 개행(`\newline`)은 무시되며, '\\', '$', '\`'를 사용할 때에는  '\\'로 이스케이프해야합니다.

만약 리다이렉션 연산자가 '<<-'라면, 각 입력 줄과 `delimiter`를 포함하는 줄의 처음에 오는 모든 탭 문자를 제거합니다. 이는 셸 스크립트에서 히어독을 자연스럽게 들여쓸 수 있도록 해줍니다.

### 3.6.7 Here Strings

히어독의 변형입니다. 형식은 다음과 같습니다.

```sh
[n]<<< word
```

*word*에는 물결줄표 전개, 매개변수와 변수 전개, 명령어 치환, 산술 치환, 따옴표 제거가 적용됩니다. 파일명 전개와 단어 분리는 발생하지 않습니다. 전개 결과는 마지막에 개행이 추가된 단일 문자열이 되며, 명령어의 표준 입력(파일 디스크립터 *n*이 지정되어 있다면 *n*)으로 이용됩니다.

### 3.6.8 Duplicating File Descriptors

```sh
[n]<&word
```

이 리다이렉션 연산자는 입력 파일 디스크립터를 복사합니다. *word*가 숫자로 확장된다면 그 파일 스크립터를 파일 디스크립터 *n*로 복사합니다. 만약 *word*의 숫자가 입력에 사용할 수 있는 파일 디스크립터를 지정하지 않았다면 에러가 발생합니다. *word*가 '-'로 평가되었다면, 파일 디스크립터 *n*을 닫습니다. 만약 *n*이 지정되지 않았다면 표준 입력(파일 디스크립터 0)이 사용됩니다.

```sh
[n]>&word
```

이 연산자는 출력 파일 디스크립터를 복사합니다. *n*이 지정되지 않았다면, 표준 출력(파일 디스크립터 1)이 사용됩니다. 만약 *word*의 숫자가 출력에 사용할 수 있는 파일 디스크립터를 지정하지 않았다면 에러가 발생합니다. *word*가 '-'로 평가되었다면, 파일 디스크립터 *n*을 닫습니다. 예외사항으로 *n*이 생략되었다면, *word*는 숫자나 '-'로 전개되지 않으며, 이전에 설명했듯이 표준 출력과 표준 에러가 재전송됩니다.

### 3.6.9 Moving File Descriptors

```sh
[n]<&digit-
```

이 리다이렉션 연산자는 파일 디스크립터 *digit*을 지정된 파일 디스크립터 *n* 또는 지정되지 않았다면 표준 입력(파일 디스크립터 0)으로 이동시킵니다. *digit*은 *n*으로 복사된 후에 닫힙니다.

```sh
[n]>&digit-
```

비슷하게, 이 연산자는 파일 디스크립터 *digit*을 지정된 파일 디스크립터 *n* 또는 지정되지 않았다면 표준 출력(파일 디스크립터 1)로 이동시킵니다. (역주: *n*은 *digit*으로 복사된 후에 닫힙니다.)

### 3.6.10 Opening File Descriptors for Reading and Writing

```sh
[n]<>word
```

이 연산자는 *word*를 전개하여 얻은 파일명을 사용해 읽고 쓰기가 가능하도록 파일을 열고 파일 디스크립터 *n*에 연결합니다. *n*이 지정되지 않았다면 파일 디스크립터 0을 연결합니다. 만약 파일이 존재하지 않는다면 만듭니다.

## 3.7 Executing Commands
- Simple Command Expansion : Bash가 단순 명령어를 실행하기 전에 이를 전개하는 방법.
- Command Search and Execution : Bash가 명령어를 찾고 실행하는 방법.
- Command Execution Environment : 셸 빌트인이 아닌 명령어를 실행할 때의 환경.
- Environment : 명령어의 환경.
- Exit Status : 명령어가 반환하는 스테이터스와 Bash가 스테이터스를 처리하는 방법.
- Signals : Bash나 명령어가 시그널을 받았을 때 일어나는 일.

### 3.7.1 Simple Command Expansion

단순 명령어를 실행할 때, 셸은 다음의 전개, 할당, 리다이렉션을 왼쪽에서 오른쪽으로 순차실행합니다.

1. 파서가 (명령어 앞에 오는) 변수 대입으로 인식한 단어와 리다이렉션은 나중의 처리를 위해서 보존됩니다.
2. 변수 대입이나 리다이렉션이 아닌 단어들은 전개가 적용됩니다(Shell Expansions를 참조). 전개 후에도 남아있는 단어는 첫번째 단어가 명령어, 나머지가 인수로 처리됩니다.
3. 이전에 설명한 리다이렉션이 실행됩니다(Redirections를 참조).
4. 각 변수 대입에서 '=' 뒤에 오는 텍스트에는 대입이 이루어지기 전에 물결줄표 전개, 매개변수 전개, 명령어 치환, 산술 전개, 따옴표 제거가 실행됩니다.

전개한 결과에 명령어가 존재하지 않을 경우, 변수 대입은 현재의 셸 환경에 적용됩니다. 그렇지 않으면 변수는 실행된 명령어의 환경에 추가되며, 현재의 셸 환경에는 영향을 주지 않습니다. 읽기 전용 변수에 대입을 시도한 경우, 명령어에서는 에러가 발생하며 0 이외의 스테이터스와 함께 종료됩니다.

명령어가 존재하지 않는 경우, 리다이렉션은 실행되지만 현재의 셸 환경에는 영향을 주지 않습니다. 리다이렉션 에러는 명령어가 0 이외의 스테이터스로 종료시킵니다.

전개 후에도 명령어가 남아있다면 다음 처리로 넘어가며, 남아있지 않다면 명령어 실행이 종료됩니다. 전개에 명령어 치환이 포함되어 있는 경우, 명령어의 종료 스테이터스는 마지막에 실행된 명령어 치환의 종료 스테이터스가 됩니다.

### 3.7.2 Command Search and Execution

명령어가 단어로 분리된 이후, 그 결과가 단순 명령어와 인수 리스트라면 다음 동작을 수행합니다.

1. 명령어의 이름이 슬래시를 포함하고 있지 않다면, 셸은 해당 명령어를 찾습니다. 만약 그 이름을 가지는 셸 함수가 존재한다면 Shell Functions에서 설명된 대로 실행합니다.
2. 해당 이름을 가지는 함수가 존재하지 않는다면, 셸은 셸 빌트인 명령어 목록을 검색합니다. 만약 일치하는 명령어가 있다면 해당 빌트인 명령어를 호출합니다.
3. 셸 함수와 빌트인 명령어에 일치하는 이름이 없고, 이름에 슬래시도 포함하고 있지 않다면, Bash는 `$PATH`의 각 요소로부터 해당 이름을 가진 실행가능한 파일이 존재하는 디렉터리를 찾습니다. Bash는 `PATH` 검색을 여러번 검색하는 것을 피하기 위해서, 실행가능한 파일의 전체 경로명을 해시 테이블을 사용해서 기억합니다(`hash`에 대한 설명은 Bourne Shell Builtins를 참조). 해시 테이블에서 명령어를 찾지 못했을 때에만 `$PATH`의 각 디렉터리에 대해 전체 검색을 수행합니다. 만약 검색에 실패하면, 셸은 `command_not_found_handle`라는 이름의 셸 함수가 정의되어 있는지 찾습니다. 만약 존재한다면, 이 함수는 원래의 명령어와 원래의 명령어에 넘겨진 인수를 넘겨받고, 별도의 실행 환경에서 호출되며, 이 함수의 종료 스테이터스는 서브셸의 종료 스테이터스가 됩니다. 만약 이 함수가 정의되어있지 않다면, 셸은 에러 메시지를 출력하고 종료 스테이터스 127과 함께 종료합니다.
4. 검색에 성공하거나, 명령어 이름이 하나 이상의 슬래시를 포함하고 있는 경우, 셸은 해당 이름의 프로그램을 별도의 실행 환경에서 실행합니다. 0번째 인수에는 주어진 이름이 설정되며, 만약 넘겨받은 인수가 있다면 명령어의 나머지 인수로 설정합니다.
5. 만약 지정된 파일이 실행 가능한 형식이 아니거나 파일이 디렉터리에 존재하지 않는다는 이유로 실행에 실패하는 경우, 이는 *셸 스크립트*인 것으로 취급하며 셸은 Shell Scripts에서 설명된 대로 이를 실행합니다.
6. 만약 명령어가 비동기로 실행된 것이 아니라면, 셸은 명령어의 실행이 완료되기를 기다리고 명령어의 종료 스테이터스를 수집합니다.

### 3.7.3 Command Execution Environment

셸은 *실행 환경*을 가지고 있으며, 이는 다음으로 구성되어 있습니다.

- 호출 시점에 셸에 의해서 열린 파일들을 상속합니다. 이들은 `exec` 빌트인 명령어에 제공된 리다이렉션에 의해 변경됩니다.
- `cd`, `pushd`, `popd`에 의해서 설정되거나 호출 시점에 셸로부터 상속된 현재 작업 디렉터리.
- `umask`나 셸의 부모로부터 상속된 파일 생성 모드 마스크 설정.
- `trap`에 의해서 설정된 현재 트랩.
- 변수 대입이나 `set`으로 설정되거나 셸의 부모의 환경으로부터 상속된 셸 매개변수.
- 실행중에 정의되거나 셸의 부모의 환경으로부터 상속된 셸 함수.
- 호출시 켠 옵션(기본값이나 실행시에 인수로 넘겨진 경우)이나 `set`으로 설정된 옵션.
- `shopt`로 켠 옵션(The Shopt Builtin을 참조).
- `alias`로 정의된 셸 엘리아스(Aliases를 참조).
- 다양한 프로세스 ID. 이는 백그라운드 잡(Lists of Commands를 참조)과 `$$`의 값, `$PPID`의 값을 포함합니다.

셸 함수나 빌트인 명령어가 아닌 단순 명령어를 실행하는 경우, 다음으로 구성된 별도의 실행 환경에서 호출됩니다. 특별한 언급이 없는 한 값은 셸에서 상속됩니다.

- 셸이 연 파일들에 더해 명령어에 지정된 리다이렉션이 적용됩니다.
- 현재 작업 디렉터리.
- 파일 생성 모드 마스크.
- 익스포트할 셸 변수/함수와 명령어를 위해 부모로부터 환경으로 넘겨진 익스포트된 변수(Environment를 참조).
- 잡도록 설정되어 있는 셸의 트랩을 부모로부터 상속된 값으로 초기화하며, 무시하도록 설정되어 있는 트랩은 그대로 무시합니다.

이 별도의 환경에서 실행된 명령어는 셸의 실행 환경에 영향을 줄 수 없습니다.

명령어 치환, 소괄호로 묶은 명령어 리스트, 비동기 명령어들은 서브셸 환경에서 호출되며, 이 환경은 셸의 트랩 설정이 호출 시점에 그 부모의 셸이 가지고 있는 값으로 재설정되는 점을 제외하면 셸의 환경의 복제판입니다. 파이프라인의 일부로 호출되는 빌트인 명령어 역시 서브셸 환경에서 실행됩니다. 서브셸 환경을 변경하는 것은 셸의 실행 환경에 영향을 줄 수 없습니다.

명령어 치환을 실행하기 위해서 생성되는 서브셸은 부모 셸로부터 `-e` 옵션의 값을 상속합니다. 만약 POSIX 모드가 아니라면, Bash는 서브셸에서 `-e` 옵션의 값을 지웁니다.

만약 명령어 뒤에 '&'가 존재하고, 잡 컨트롤이 활성화된 상태가 아니라면 명령어의 기본 표준 입력은 빈 파일인 `/dev/null`입니다. 그렇지 않다면, 호출된 명령어는 리다이렉션으로 변경된 셸의 파일 디스크립터를 상속합니다.

### 3.7.4 Environment

프로그램이 호출될 때, 환경이라고 불리는 문자열의 배열이 주어집니다. 이는 이름-값 쌍의 리스트로, `name=value`의 형식입니다.

Bash는 환경을 생성하기 위한 방법을 여럿 제공합니다. 셸은 호출시에 자신의 환경을 스캔하고 발견한 이름마다 매개변수를 생성한 뒤, 자식 프로세스로 *익스포트*할 매개변수를 자동으로 표시해둡니다. 실행된 명령어는 환경을 상속합니다. `export`와 `declare -x` 명령어는 매개변수와 함수를 환경에 추가하거나 삭제할 수 있습니다. 환경의 매개변수의 값이 수정되면 새 값은 이전 값을 대체하고 환경의 일부가 됩니다. 실행된 명령어에 상속된 환경은 셸의 초기 환경을 구성하며, 이는 `unset`과 `export -n` 명령어를 통해 삭제할 수 있으며, `export`, `declare -x`를 통해 추가할 수 있습니다.

단순 명령어의 환경이나 함수는 Shell Parameters에서 설명된 것처럼 매개변수 대입을 앞에 두어서 일시적으로 변경할 수 있습니다. 이 대입식은 해당 명령어의 환경에만 영향을 미칩니다.

만약 `-k` 옵션(The Set Builtin을 참조)이 켜져있다면 환경 내에서의 명령어에 대한 매개변수 대입은 명령어 앞에 올 필요가 없습니다.

만약 Bash가 외부 명령어를 호출한다면, 변수 `$_`에 명령어의 전체 경로명이 설정되며, 이는 명령어의 실행 환경에 넘겨집니다.

### 3.7.5 Exit Status
실행된 명령어의 종료 스테이터스는 *waitpid* 시스템 콜이나 이와 동등한 함수에 의해서 반환되는 값입니다. 종료 스테이터스는 0과 255사이의 값입니다만, 아래에서 설명하는 것처럼 셸은 125보다 큰 값을 특별한 의미로 사용합니다. 셸 빌트인 명령어와 복합 명령어의 종료 스테이터스는 이 범위로 제한됩니다. 특정 환경에서는 셸이 특정 실패 모드를 알리기 위해서 특수한 값을 사용합니다.

셸에서는 종료 스테이터스 0으로 종료한 명령어는 실행 성공입니다. 0이 아닌 종료 스테이터스는 실패를 의미합니다. 보기에는 직관적이지 않은 이 동작은 성공을 가리키는 하나의 잘 정돈된 방식과 실패를 가리키는 다양한 방식이 있음을 암시합니다. 만약 명령어가 치명적인 시그널 *N*과 함께 종료했을 경우, Bash는 128+*N*을 종료 스테이터스로 사용합니다.

명령어를 찾을 수 없다면, 자식 프로세스는 스테이터스 127을 반환하기 위해서 생성됩니다. 만약 명령어는 존재하지만 실행이 불가능할 경우, 반환 스테이터스는 126입니다.

명령어가 전개중이나 리다이렉션중에 에러가 발생하여 실패했을 경우, 종료 스테이터스는 0보다 큽니다.

종료 스테이터스는 Bash의 조건 명령어(Conditional Constructs를 참조)와 몇몇 리스트 구조(Lists of Commands를 참조)에서 사용됩니다.

모든 Bash 빌트인 명령어는 성공하면 종료 스테이터스 0을 반환하며, 실패한 경우 0이 아닌 스테이터스를 반환합니다. 그러므로 이들은 조건 명령어나 리스트 구조에서 사용할 수 있습니다. 모든 빌트인 명령어는 올바르지 않은 사용법일 경우 종료 스테이터스로 2를 반환하며, 일반적으로 옵션이 유효하지 않거나 인수가 부족하다는 의미입니다.

### 3.7.6 Signals
Bash가 인터랙티브 모드이고 트랩이 존재하지 않는다면 셸은 `SIGTERM`을 무시하며(그러므로 '`kill 0`'은 인터랙티브 셸을 죽일 수 없습니다) `SIGINT`는 붙잡히고 처리됩니다(그러므로 `wait` 빌트인은 끼어들 수 있습니다)
. Bash가 `SIGINT` 시그널을 받으면 어떤 실행 루프에 있더라도 벗어납니다. 모든 경우에 Bash는 `SIGQUIT`를 무시합니다. 만약 잡 컨트롤의 영향을 받고 있다면(Job Control을 참조) Bash는 `SIGTTIN`, `SIGTTOU`, `SIGTSTP`를 무시합니다.

Bash에 의해서 실행되는 빌트인이 아닌 명령어는 자신의 부모인 셸로부터 시그널 핸들러의 값을 상속받습니다. 잡 컨트롤의 영향을 받고 있지 않다면, 비동기 명령어는 `SIGINT`와 `SIGQUIT`, 그리고 상속된 핸들러를 무시합니다. 명령어 치환의 결과로 실행되는 명령어는 키보드가 생성하는 잡 컨트롤 시그널인 `SIGTTIN`, `SIGTTOU`, `SIGTSTP`를 무시합니다.

`SIGHUP`을 수신했을 때의 셸의 기본 동작은 종료입니다. 종료하기 전에 인터랙티브 셸은 실행중이거나 또는 종료된 모든 잡에 대해서 `SIGHUP`을 재전송합니다. 종료된 잡에는 `SIGHUP`을 수신했는지 확인하기 위해서 `SIGCONT`도 전송됩니다. 셸이 특정 잡에 대해서 `SIGHUP` 시그널을 전송하지 않도록 하려면 `disown` 빌트인(Job Control Builtins를 참조)을 사용해서 해당 잡을 잡 테이블에서 제거하거나, `disown -h`를 사용하여 `SIGHUP`을 수신하지 않도록 설정해야합니다.

만약 `shopt`(The Shopt Builtin을 참조)로 `huponexit` 셸 옵션이 지정되었다면, Bash는 인터랙티브 로그인 셸을 종료할 때 `SIGHUP`을 모든 잡에 전송합니다.

Bash가 명령어의 실행이 완료되는 것을 기다리고 있는 중에 트랩을 실행하라는 시그널을 받았다면, 트랩은 명령어의 실행이 완료될 때까지 실행되지 않습니다. Bash가 `wait` 빌트인 명령어로 비동기 명령어의 실행 완료를 기다리는 동안 트랩을 실행하라는 시그널을 수신하면 이는 `wait` 빌트인을 128보다 큰 종료 스테이터스와 함께 곧바로 종료시키며, 직후에 트랩을 실행합니다.

## 3.8 Shell Scripts

셸 스크립트는 셸 명령어를 포함하고 있는 텍스트 파일입니다. Bash에서 첫번째 인수로 이러한 파일을 사용하는 경우, `-c`나 `-s` 옵션(Invoking Bash를 참조)을 사용하지 않았다면 Bash는 파일으로부터 명령어를 읽고 실행한 뒤 종료합니다. 이 동작은 논-인터랙티브 셸을 생성합니다. 셸은 현재 디렉터리에서 파일을 탐색하며, 만약 발견하지 못했을 경우, `$PATH`의 디렉터리들을 확인합니다.

Bash가 셸 스크립트를 실행할 때, 특수 매개변수 `0`에는 셸의 이름 대신 파일명을 설정하며, 위치 매개변수에는 만약 존재한다면 나머지 인수들을 설정합니다. 추가 인수가 없을 경우, 기존의 위치 매개변수는 제거됩니다.

셸 스크립트는 `chmod` 명령어를 사용해 실행 비트를 변경하여 실행 가능하도록 변경할 수 있습니다. Bash가 명령어를 `$PATH`에서 찾는 동안 그러한 파일을 발견하는 경우, 서브셸을 생성하고 실행합니다. 다시 말해 파일명이 실행가능한 셸 스크립트라면, 이 명령어 실행은 

```sh
filename arguments
```

다음과 동등합니다.

```sh
bash filename arguments
```

이 서브셸은 스크립트를 해석하기 위해 새로운 셸이 호출된 것 처럼 동작하기 위해 자신을 재초기화합니다. 예외사항으로 이 때 부모가 기억하고 있는 명령어의 위치 정보(Bourne Shell Builtins의 `hash` 설명을 참조)는 자식에서도 그대로 유지됩니다.

대부분의 유닉스 버전에서는 이를 운영체제의 명령어 실행 구조의 일부로 구현합니다. 명령어의 첫번째 줄이 `#!`라는 문자들로 시작하는 경우, 해당 줄의 나머지 부분은 프로그램을 해석할 인터프리터와 (운영체제에 의존하는) 하나 이상의 인터프리터 옵션을 지정합니다. 그러므로 Bash, `awk`, Perl 또는 그 이외의 인터프리터를 지정하고, 해당 언어로 스크립트의 나머지 부분을 작성할 수 있습니다.

인터프리터의 인수는 스크립트 파일의 첫번째 줄의 인터프리터 이름 뒤에 오는 하나 이상의 인수로 구성됩니다. 이 뒤에는 스크립트 파일명과 스크립트 자신이 사용하는 나머지 인수가 올 수 있습니다. 인터프리터 줄이 어떻게 인터프리터 이름과 인수의 집합으로 분리되는지에 대한 상세한 방식은 시스템마다 다양합니다. Bash는 이 동작을 운영체제에서 실행하도록 두며, 직접 처리하지 않습니다. 몇몇 오래된 유닉스 버전에서는 인터프리터 이름과 인수의 길이를 32글자로 제한하고 있으며 하나의 인수만 사용 가능합니다. 그러므로 2개 이상의 인수를 사용하는 스크립트가 범용적일거라고 생각해서는 안됩니다.

Bash 스크립트를 해석할 때 다른 셸에서 실행되더라도 Bash를 사용하도록 만들기 위해 `#! /bin/bash`(Bash가 `/bin`에 설치되어있다고 가정)로 시작하는 경우가 많습니다. 다른 디렉터리에 설치되어있다고 하더라도 `bash`를 찾아서 실행하기 위해 `env`를 사용하는 방식도 일반적입니다. 예를 들어 `#!/usr/bin/env bash`는 `$PATH`의 디렉토리 목록에서 찾은 첫 번째 `bash`를 사용합니다.

# 4. Shell Builtin Commands
빌트인 명령어는 셸 자체에 포함되어 있습니다. 빌트인 명령어의 이름이 단순 명령어(Simple Commands를 참조)의 첫번째 단어로 사용되는 경우, 셸은 다른 프로그램을 호출하지 않고 명령어를 직접 실행합니다. 빌트인 명령어는 별도의 유틸리티로는 기술적으로 실현 불가능한 것이나 불편한 것을 구현하기 위해 필요합니다.

이 섹션에서는 Bash가 Bourne Shell로부터 계승한 빌트인 명령어와 Bash에만 존재하거나 기능을 확장한 명령어에 대해서 간략하게 설명합니다.

Bash 인터페이스에 잡 컨트롤 기능(Job Control Builtins를 참조), 디렉터리 스택(Directory Stack Builtins를 참조), 명령어 이력(Bash History Builtins를 참조), 프로그래밍 가능한 완성 기능(Programmable Completion Builtins을 참조)을 제공해주는 빌트인 명령어는 다른 장에서 설명합니다. 

 많은 빌트인 명령어는 POSIX나 Bash에 의해서 기능이 추가되었습니다.

따로 언급하지 않는다면, 설명에서 '-'로 시작하는 옵션을 받는 각 빌트인 명령어는 옵션의 끝을 표시하는 '--'를 사용할 수 있습니다. `:`, `true`, `false`, `test`/`[`는 옵션을 받지 않으며, '--'를 특별 취급하지도 않습니다. `exit`, `logout`, `return`, `break`, `continue`, `let`, `shift` 빌트인 명령어는 '--' 없이 '-'로 시작하는 인수를 받을 수 있습니다. 인수를 받지만 옵션을 사용할 수 없는 다른 빌트인 명령어는 '-'로 시작하는 인수를 잘못된 옵션으로 해석하므로 이를 피하기 위해서는 '--'를 사용해야 합니다.

## 4.1 Bourne Shell Builtins
다음 셸 빌트인 명령어들은 Bourne Shell로부터 계승한 것들입니다. 이 명령어들은 POSIX 표준에 기술된 대로 구현되어 있습니다.

**:** (콜론)
```sh
: [arguments]
```
인수를 전개하고, 리다이렉션을 설정하는 이외에는 아무것도 하지 않습니다. 반환 스테이터스는 0입니다.

**.** (마침표)
```sh
. filename [arguments]
```
현재 셸 컨텍스트에서 *filename* 인수로부터 명령어를 읽고 실행합니다. *filename*에 슬래시가 포함되어 있지 않다면, `PATH` 변수를 사용해서 *filename*을 찾습니다. 만약 Bash가 POSIX 모드가 아니고, `$PATH`에서 *filename*을 발견하지 못했다면 현재 디렉터리를 검색합니다. `arguments`가 제공되었다면, 이는 `filename`을 실행할 때 위치 매개변수가 됩니다. 그렇지 않다면 위치 매개변수는 변경되지 않습니다. `set` 빌트인으로 `-T` 옵션이 켜진 상태라면, `source`는 `DEBUG`에 등록된 트랩을 상속합니다. `-T` 옵션이 꺼진 상태라면 `DEBUG` 트랩의 문자열은 저장되지 않고, `source` 호출 전후로 복구합니다. `source`는 실행하는 동안 `DEBUG` 트랩을 제거합니다. `-T` 옵션이 꺼진 상태이고 `source`의 대상 파일이 `DEBUG` 트랩을 변경했다면, 새 값은 `source`가 종료될 때까지 유지됩니다. 반환 스테이터스는 마지막으로 실행된 명령어의 종료 스테이터스이며, 실행된 명령이 없다면 0입니다. 만약 *filename*을 찾을 수 없거나 읽을 수 없다면 종료 스테이터스는 0이 아닌 값입니다. 이 빌트인 명령어는 `source`와 동일합니다.

**break**
```sh
break [n]
```
`for`, `while`, `until`, `select` 루프를 종료합니다. 만약 *n*을 넘겼다면, 감싸고 있는 *n*번째 루프가 종료됩니다. *n*은 반드시 1 이상이어야 합니다. 종료 스테이터스는 *n*이 1보다 작지 않다면 0입니다.

**cd**
```sh
cd [-L|[-P [-e]] [-@]] [directory]
```
현재 작업 디렉터리를 *directory*로 변경합니다. *directory*가 제공되지 않았다면, 셸 변수 `HOME`의 값이 사용됩니다. *directory* 뒤에 따라오는 모든 추가 인수는 무시됩니다. 셸 변수 `CDPATH`가 존재한다면 검색용 경로로 사용합니다. `CDPATH`의 각 디렉터리를 검색하며, 이를 대체할 디렉터리 이름은 `CDPATH`에서 콜론(':')으로 구분되어있습니다. 만약 *directory*가 슬래시로 시작한다면 `CDPATH`는 사용되지 않습니다.

`-P` 옵션은 심볼릭 링크를 따라가지 말라는 의미입니다. `cd`가 *directory*를 순회하고 *directory*의 '..'를 처리하기 전에 심볼릭 링크를 해결합니다. (역주: 심볼릭 링크를 따라가지 않고, 실제 디렉터리 구조를 사용합니다.)

기본 설정 상태나 `-L` 옵션이 넘겨진 경우, 디렉터리의 심볼릭 링크는 `cd`가 디렉터리의 '..'의 인스턴스를 처리하고 나서 해결됩니다.

*directory*에서 '..'가 포함되어 있을 경우, 이는 직전의 경로 부분을 즉시 제거하고 슬래시로 만들거나, *directory*의 시작 부분으로 돌아가도록 처리됩니다.

만약 `-e` 옵션이 `-P`와 함께 사용되고 성공적으로 디렉터리 변경이 이루어진 뒤에 현재 작업 디렉터리를 성공적으로 결정하지 못하면 `cd`는 성공하지 못했다는 스테이터스를 반환합니다.

시스템이 지원한다면, `-@` 옵션은 디렉터리로서의 파일과 연관된 확장된 속성을 표현할 수 있습니다.
만약 *directory*가 '-'라면 이는 디렉터리 변경이 시도되기 전에 `$OLDPWD`로 변환됩니다.

`CDPATH`에 있는 공백이 아닌 디렉터리 이름이 사용되거나 '-'가 첫번째 인수인 경우, 디렉터리 변경은 성공하며, 새 작업 디렉터리의 절대 경로가 표준 출력으로 출력됩니다.

만약 현재 디렉터리가 변경에 성공했다면 반환 스테이터스는 0이며, 실패했다면 0이 아닌 값입니다.

**continue**
```sh
continue [n]
```
감싸고 있는 `for`, `while`, `until`, `select` 루프의 다음 반복을 시작합니다. *n*이 있다면, *n*번째로 감싸고 있는 루프의 실행의 다음 반복이 시작됩니다. *n*은 1 이상이어야 합니다. *n*이 1보다 작지 않다면 종료 스테이터스는 0입니다.

**eval**
```sh
eval [arguments]
```
인수는 하나의 명령어로 결합되어 실행됩니다. 그리고 그 종료 스테이터스는 `eval`의 종료 스테이터스가 됩니다. 만약 인수가 없거나 공백이 넘겨지는 경우 반환 스테이터스는 0입니다.

**exec**
```sh
exec [-cl] [-a name] [command [arguments]]
```
*command*를 넘긴 경우, 새 프로세스를 생성하지 않고, 현재의 셸을 덮어씁니다. `-l` 옵션을 사용하는 경우, 셸은 *command*에 넘긴 0번째 인수의 앞부분에 하이픈을 추가합니다. 이는 `login` 프로그램이 하는 것과 동일합니다. `-c` 옵션은 *command*를 빈 환경에서 실행합니다. `-a`옵션은 셸이 *command*의 0번째 인수로 *name*을 넘깁니다. *command*가 어떤 이유로 실행할 수 없고, `execfail` 셸 옵션이 켜져있지 않다면 논-인터랙티브 셸은 종료와 함께 실패를 반환합니다. 인터랙티브 셸은 파일을 실행할 수 없다면 실패를 반환합니다. 서브셸은 `exec`가 실패하면 무조건 종료합니다. 만약 *command*가 지정되지 않았다면, 리다이렉션을 현재 셸 환경에 적용합니다. 만약 리다이렉션 에러가 발생하지 않았다면 반환 스테이터스는 0입니다. 그렇지 않으면 반환 스테이터스는 0이 아닌 값입니다.

**exit**
```sh
exit [n]
```
셸을 종료하고, 셸의 부모에게 종료 스테이터스로 *n*을 넘깁니다. 만약 *n*을 생략했다면 종료 스테이터스는 마지막에 실행한 명령어의 종료 스테이터스입니다. 셸이 종료되기 전에 `EXIT`에 설정된 트랩이 실행됩니다.

**export**
```sh
export [-fn] [-p] [name[=value]]
```
각 *name*을 환경의 자식 프로세스에 익스포트하도록 설정합니다. `-f` 옵션을 사용하면 *name*으로 셸 함수를 지정할 수 있습니다. 그렇지 않다면 이름은 셸 변수를 지정합니다. `-n` 옵션을 사용하면 각 *name*을 익스포트 하지 않도록 설정합니다. *name*을 넘기지 않거나 `-p` 옵션을 사용했다면 익스포트 대상인 모든 변수를 출력합니다. `-p` 옵션의 출력 형식은 입력으로 재사용할 수 있습니다. 변수 이름 뒤에 *=value*를 덧붙이면 변수의 값을 *value*로 설정합니다. 

잘못된 옵션, 유효하지 않은 셸 변수 이름, `-f` 옵션을 넘겼을 때 셸 함수가 아닌 이름을 사용하지 않는다면 반환 스테이터스는 0입니다.

**getopts**
```sh
getopts optstring name [arg …]
```
`getopts`는 셸 스크립트가 위치 매개변수를 구문 해석하기 위해서 사용합니다. *optstring*은 인식해야할 옵션 문자를 포함합니다. 옵션 문자 뒤에 콜론이 있다면 인수값을 기대하며, 인수를 넘길 때에는 스페이스로 구분되어야 합니다. 콜론(':')과 물음표('?')는 옵션 문자로 사용할 수 없습니다. 호출될 때마다, `getopts`는 셸 변수 *name*(*name*이 존재하지 않는다면 초기화합니다)에 다음 옵션과 `OPTIND` 변수에 다음에 처리할 인수의 인덱스를 저장합니다. `OPTIND`는 셸이나 셸 스크립트가 호출될 때마다 초기화됩니다. 옵션이 인수를 요구할 때, `getopts`는 인수를 `OPTARG` 변수에 저장합니다. 셸은 `OPTIND`를 자동으로 리셋하지 않습니다. 동일한 셸 호출 내에서 새로운 매개변수 집합을 사용하여 `getopts`를 여러번 호출할 때에는 직접 리셋해야 합니다.

옵션의 마지막에 도착했을 때 `getopts`는 0보다 큰 반환 값으로 종료합니다. `OPTIND`는 옵션 인수가 아닌 첫번째 인덱스 값이 되며, *name*은 '?'가 됩니다.

`getopts`는 일반적으로 위치 매개변수를 구문 해석하지만, 만약 추가 인수가 *arg* 값으로 넘겨진 경우, `getopts`는 그 값을 구문 해석합니다.

`getopts`는 에러를 두 가지 방식으로 보고합니다. *optstring*의 첫번째 문자가 콜론이라면 에러 보고를 무시합니다. 일반적인 동작에서는 유효하지 않은 옵션을 사용하거나 옵션 인수가 부족한 경우 진단 메시지가 출력됩니다. 만약 `OPTERR` 변수가 0이라면 `optstring`의 첫번째 문자가 콜론이라도 에러 메시지는 출력되지 않습니다.

만약 유효하지 않은 옵션이 있다면, `getopts`는 *name*에 '?'를 설정하며 에러 보고를 무시하지 않았다면 에러 메시지를 출력하고 `OPTARG` 값을 제거합니다. `getopts`가 에러 보고를 무시하고 있다면 발견된 옵션 문자는 `OPTARG`에 설정되며, 진단 메시지는 출력되지 않습니다.

만약 필수 인수를 찾을 수 없고, `getopts`가 에러 보고를 무시하지 않았다면, *name*에는 물음표('?')가 설정되고 `OPTARG`의 값이 제거되며, 진단 메시지가 출력됩니다. 만약 `getopts`가 에러 보고를 무시하고 있다면 *name*에는 콜론(':')이 설정되고, `OPTARG`에는 발견된 옵션 문자가 설정됩니다.

**hash**
```sh
hash [-r] [-p filename] [-dt] [name]
```
`hash`를 호출할 때마다 이후의 호출에서 검색을 할 필요가 없도록 *name* 인수에 지정된 명령어의 전체 경로를 기억합니다. 명령어는 `$PATH`에 나열되어 있는 디렉터리들에서 검색됩니다. 이전에 기억하고 있던 경로는 전부 버려집니다. `-p` 옵션은 경로 검색을 금지하며, *filename*은 *name*의 장소로 사용됩니다. `-r` 옵션은 셸이 기억하고 있는 모든 위치 정보를 잊도록 합니다. `-d` 옵션은 셸이 기억하고 있는 각 *name*의 위치 정보를 지웁니다. `-t` 옵션을 넘기면 *name*에 대응하는 전체 경로가 출력됩니다. `-t` 옵션에 여러 개의 *name* 인수를 넘겼다면 해싱된 전체 경로명 앞에 *name*을 함께 출력합니다. `-l` 옵션은 입력으로 재이용 가능한 형식으로 결과를 출력합니다. 만약 인수가 주어지지 않거나 `-l` 옵션만 넘겨졌다면 기억하고 있는 명령어에 대한 정보가 출력됩니다. *name*을 발견할 수 없거나, 유효하지 않은 옵션을 넘기지 않았다면 반환 스테이터스는 0입니다.

**pwd**
```sh
pwd [-LP]
```
현재 작업 디렉터리의 절대경로명을 출력합니다. `-P` 옵션은 출력할 경로명에 심볼릭 링크를 포함하지 않도록 합니다. `-L` 옵션은 출력할 경로명에 심볼릭 링크를 포함합니다. 현재 디렉터리의 이름을 찾는 중에 에러가 발생하거나 잘못된 옵션을 넘기지 않는 이상 종료 스테이터스는 0입니다.

**readonly**
```sh
readonly [-aAf] [-p] [name[=value]] …
```
각 *name*을 읽기 전용으로 변경합니다. 이 이름들의 값은 그 이후의 대입을 통해 변경될 수 없습니다. `-f` 옵션은 각 *name*이 셸 함수를 참조합니다. `-a` 옵션은 각 *name*이 순차 배열 변수를 참조합니다. `-A` 옵션은 각 *name*이 연상 배열 변수를 참조합니다. 만약 두 옵션을 모두 사용하는 경우, `-A`를 우선합니다. 만약 *name* 인수가 없거나 `-p` 옵션이 존재하는 경우, 모든 읽기 전용 이름이 출력됩니다. 다른 옵션은 읽기 전용 이름의 집합의 부분 집합을 출력하도록 제한하는데 쓰입니다. `-p` 옵션은 입력으로 재사용가능한 형태로 결과를 출력합니다. 만약 변수의 이름 뒤에 =*value*가 따라오는 경우, 변수의 값이 *value*로 설정됩니다. 잘못된 옵션을 사용하거나 *name* 인수 중에 유효하지 않은 변수명 또는 함수명이 존재하는 경우, 또는 `-f` 옵션이 셸 함수가 아닌 이름과 함께 사용된 경우를 제외하면 종료 스테이터스는 0입니다. 

**return**
```sh
return [n]
```
셸 함수가 실행을 중지하고 값 *n* 을 호출자에게 반환하도록 만듭니다. *n*을 넘기지 않았다면, 종료 값은 함수에서 마지막으로 실행된 명령어의 종료 스테이터스입니다. 만약 `return`이 트랩 핸들러에 의해서 실행되었다면, 스테이터스를 결정하는 데에 쓰이는 마지막 명령어는 트랩 핸들러 직전에 실행된 마지막 명령어입니다. `return`이 `DEBUG` 트랩 도중에 실행되었다면, 스테이터스를 결정하는 데에 쓰이는 마지막 명령어는 `return`이 호출되기 전에 트랩 핸들러에 의해서 실행된 마지막 명령어입니다. `return`은 `.`(`source`) 빌트인 명령어로 실행된 스크립트의 실행을 종료할 때도 사용됩니다. 이때 *n*이나 스크립트 내에서 실행된 마지막 명령어의 종료 스테이터스를 스크립트의 종료 스테이터스로 반환합니다. *n*을 넘겼다면 종료값은 넘긴 값의 가장 작은 8비트의 값입니다. `RETURN` 트랩과 연결된 명령어는 함수나 스크립트의 실행이 재개되기 전에 실행됩니다. `return`이 숫자가 아닌 인수를 넘겨받거나, 함수 바깥에서 실행하거나, `.`나 `source`에 의한 스크립트 실행중이 아닐때 실행되는 경우의 종료 스테이터스는 0 이외의 값입니다.

**shift**
```sh
shift [n]
```
위치 매개변수의 값을 왼쪽으로 *n*만큼 밀어냅니다. *n*+1 ... $#의 위치 매개변수는 $1 ... $#-*n*으로 재명명됩니다. $#부터 $#-*n*+1의 매개변수는 제거됩니다.*n*은 $#보다 작거나 같은 양의 숫자이어야 합니다. 만약 *n*이 0이나 $#보다 큰 값이라면, 위치 매개변수는 변경되지 않습니다. *n*을 넘기지 않았다면 1을 넘긴 것처럼 동작합니다. *n*이 $#보다 크거나 0보다 작지 않다면, 종료 스테이터스는 0입니다. 그 이외의 경우에는 0이 아닌 값입니다.

**test**
**[**
```sh
test expr
```
조건 표현식 *expr*을 평가하고 0(참) 또는 1(거짓)의 스테이터스를 반환합니다. 각 연산자와 피연산자는 별도의 인수여야 합니다. 표현식은 Bash Conditional Expressions에서 설명하는 연산자, 피연산자의 쌍으로 구성됩니다. `test`는 어떤 옵션도 없으며, 옵션의 끝을 나타내는 `--`의 인수도 무시합니다.

`[` 형식을 사용하는 경우, 명령어의 마지막 인수는 반드시 `]`이어야 합니다.

표현식은 다음 연산자를 사용해 결합될 수 있습니다. 우선순위는 높은 것부터 낮은 것 순으로 정렬되어 있습니다. 평가는 아래에서 설명할 인수의 개수에 의존합니다. 연산자의 우선순위는 5개 이상의 인수를 넘긴 경우 사용됩니다.

- **! *expr***
  *expr*이 거짓이라면 참입니다.
- **( *expr* )**
  *expr*의 값을 반환합니다. 이는 연산자의 우선순위를 덮어쓰기 위해서 사용합니다.
- ***expr1* -a *expr2***
  *expr1*과 *expr2*가 모두 참이라면 참입니다.
- ***expr1* -o *expr2***
  *expr1*와 *expr2* 중 하나라도 참이라면 참입니다.

`test`와 `[` 빌트인 명령어는 인수의 개수에 기초한 규칙 집합을 사용해 조건 표현식을 평가합니다.

  - **0개의 인수**
  표현식은 거짓입니다.
  - **1개의 인수**
  표현식은 인수가 널이 아니라면 참입니다.
  - **2개의 인수**
  첫번째 인수가 '!'라면 표현식은 두번째 인수가 널일 경우에 표현식이 참이 됩니다. 첫번째 인수가 단항 연산자(Bash Conditional Expressions를 참조)이고, 단항 연산의 결과가 참이라면 표현식은 참입니다. 만약 첫번째 인수가 유효한 단항 연산자가 아니라면 표현식은 거짓입니다.
  - **3개의 인수**
  다음 조건이 순서대로 적용됩니다.
    1. 두번째 인수가 이항 조건 연산자(Bash Conditional Expressions를 참조)라면, 표현식의 결과는 첫번째, 세번째 인수를 사용한 이항 연산자의 검사 결과입니다. '-a'와 '-o' 연산자는 인수가 3개일 때 이항 연산자인 것처럼 취급됩니다.
    2. 첫번째 인수가 '!'라면 두번째와 세번째 인수를 사용한 두 인수 검사 결과의 부정값이 됩니다.
    3. 첫번째 인수가 '('이고, 세번째 인수가 ')'라면 두번째 인수의 단일 인수 검사의 결과가 됩니다.
    4. 그 이외의 경우, 표현식은 거짓이 됩니다.
  - **4개의 인수**
    첫번째 인수가 '!'라면, 나머지 인수들로 구성된 세 인수 표현식의 부정값이 결과가 됩니다. 그렇지 않다면, 표현식은 위에서 설명한 우선순위 규칙을 사용해 분해되고 평가됩니다.
  - **5개 이상의 인수**
    표현식은 위에서 설명한 우선순위 규칙을 사용해 분해되고 평가됩니다.

'<'와 '>'를 `test`나 '\['와 함께  사용하는 경우, 해당 연산자들은 ASCII 순서에 따라서 사전순으로 정렬합니다.

**times**
```sh
times
```
셸과 그 자식이 사용한 사용자와 시스템 시간을 출력합니다. 종료 스테이터스는 0입니다.

**trap**
```sh
trap [-lp] [arg] [sigspec …]
```
셸이 시그널 *sigspec*을 받을 때 *arg*의 명령어를 읽고 실행합니다. *arg*가 없고 하나의 *sigspec*이 있거나 '-'일 경우, 각 *sigspec* 시그널에 설정된 값이 셸이 시작될 때 가지고 있었던 값으로 초기화됩니다. *arg*가 널 문자열이라면, 각 *sigspec*으로 지정된 시그널은 셸과 셸이 호출한 명령어에서 무시됩니다.  *arg*가 없고 `-p` 옵션을 넘겼다면 셸은 각 *sigspec*에 연결된 트랩 명령어를 출력합니다. 만약 넘긴 임수가 없거나 `-p` 만 넘겼다면 `trap`은 셸의 입력으로 재사용가능한 형식으로 각 시그널 번호와 그와 연결된 명령어 리스트를 출력합니다. `-l` 옵션을 넘기면 셸은 시그널의 이름과 그에 대응하는 번호 리스트를 출력합니다. 각 *sigspec*은 시그널 이름이나 시그널 번호입니다. 시그널 이름을 사용하는 경우 대소문자를 구분하지 않으며, `SIG` 접두사는 생략가능합니다.

*sigspec*이 0이나 `EXIT`이라면, *arg*는 셸이 종료될 때 실행됩니다. *sigspec*이 `DEBUG`라면 명령어 *arg*는 모든 단순 명령어, `for` 명령어, `case` 명령어, `select` 명령어, 모든 산술 `for` 명령어, 셸 함수에서 실행되는 첫 번째 함수 직전에 실행됩니다. `shopt` 빌트인 명령어(The Shopt Builtin을 참조)의 `extdebug` 옵션 설명을 참조하세요. *sigspec*이 `RETURN`이라면 명령어 *arg*는 셸 함수나 `.` 또는 `source` 빌트인 명령어에 의해 실행된 스크립트의 실행이 종료될 때마다 실행됩니다.

만약 *sigspec*이 `ERR`라면, (단순 명령어로 구성될 수도 있는) 파이프라인, 리스트, 복합 명령어가 0이 아닌 종료 스테이터스를 반환할 때마다 다음 조건에 따라서 명령어 *arg*가 실행됩니다. `ERR` 트랩은 실패한 명령어가 `until`이나 `while` 키워드 직후에 오는 경우, `if`나 `elif` 예약어 뒤에 오는 경우, `&&`나 `||`의 일부이되 마지막 `&&`, `||`의 뒤에 오지 않은 경우, 파이프라인의 마지막 명령어인 경우, 명령어의 반환 스테이터스를 `!`로 뒤집은 경우에는 실행되지 않습니다. 이는 `errexit`(`-e`) 옵션이 적용되는 조건과 동일합니다.

셸이 생성될 때 무시하도록 설정해둔 시그널은 트랩을 설정하거나 초기화할 수 없습니다. 무시하도록 설정하지 않은 시그널은 서브셸 또는 서브셸 환경을 생성할 때 원래의 값으로 초기화됩니다.
*sigspec*에 유효하지 않은 시그널을 설정한 것이 아니라면 종료 스테이터스는 0입니다.

**umask**
```sh
umask [-p] [-S] [mode]
```
셸 프로세스의 파일 생성 마스크를 *mode*로 설정합니다. *mode*가 숫자로 시작하면 8진수로 처리됩니다. 그 이외의 경우에는 `chmod` 명령어가 받는 것과 유사한 심볼릭 모드 마스크로 처리됩니다. *mode*를 생략하면 현재 마스크 값이 출력됩니다. `-S` 옵션을 *mode* 인수 없이 사용하면, 심볼릭 형식으로 마스크를 출력합니다. `-p` 옵션을 사용하고 *mode*를 생략한 경우, 입력으로 재활용이 가능한 형식으로 결과를 출력합니다. 모드가 성공적으로 변경되었거나, *mode* 인수가 주어지지 않은 경우 반환 스테이터스는 0입니다. 그 이외의 경우에는 0이 아닌 값입니다.

모드가 8진수로 처리되는 경우 umask의 각 숫자는 7로부터 뺀 값이 된다는 것을 기억하세요. 그러므로 `022`의 umask는 `755` 권한을 의미합니다.

**unset**
```sh
unset [-fnv] [name]
```
각 변수 또는 함수 *name*을 제거합니다. `-v` 옵션을 넘기면 각 *name*은 셸 변수를 참조하고 해당 변수를 제거합니다. `-f` 옵션을 넘기면 *name*은 셸 함수를 참조하며 함수의 정의를 제거합니다. `-n` 옵션을 넘기는 경우 *name*은 *nameref* 속성을 가지고 있는 변수이며, *name*이 참조하고 있는 변수를 제거하기 보다는 변수 자체를 제거합니다. `-f` 옵션을 함께 사용했다면 `-n`은 무시됩니다. 아무런 옵션을 사용하지 않았다면 *name*은 변수를 참조합니다. 만약 지정한 이름의 변수가 존재하지 않고, 지정한 이름을 가지는 함수가 있다면 그 쪽을 제거합니다. 읽기 전용 변수와 함수는 제거되지 않습니다. 몇몇 셸 변수는 제거하면 특수한 행동을 하지 않게 됩니다. 이에 해당하는 행동은 각 별수의 설명에서 확인할 수 있습니다. *name*이 읽기 전용이 아니라면 종료 스테이터스는 0입니다.

## 4.2 Bash Builtin Commands
이 섹션에서는 Bash에서만 제공하거나 Bash에서 확장된 빌트인 명령어를 설명합니다. 몇몇 명령어는 POSIX 표준에서 규정되어 있습니다.

**alias**
```sh
alias [-p] [name[=value] …]
```
넘긴 인수가 없거나 `-p` 옵션을 넘겼다면 `alias`는 입력으로 재사용 가능한 형식의 별칭 리스트를 표준 출력으로 출력합니다. 만약 인수를 넘겼다면 각 *name*과 함께 주어진 *value*를 별칭으로 정의합니다. 만약 *value*가 없다면, 해당 이름의 별칭과 그 값을 출력합니다. 별칭은 Aliases에서 자세히 설명합니다.

**bind**
```sh
bind [-m keymap] [-lpsvPSVX]
bind [-m keymap] [-q function] [-u function] [-r keyseq]
bind [-m keymap] -f filename
bind [-m keymap] -x keyseq:shell-command
bind [-m keymap] keyseq:function-name
bind [-m keymap] keyseq:readline-command
```
현재 Readline(Command Line Editing을 참조)의 키와 함수 바인딩을 출력하거나 Readline 함수나 매크로에 키 나열을 바인드하거나 Readline 변수를 설정합니다. 옵션이 아닌 각 인수는 Readline 초기화 파일(Readline Init File을 참조)에 실려있는 명령어입니다. 다만 각 바인딩이나 명령어는 별도의 인수로 넘겨야 합니다. e.g., '"\C-x\C-r:re-read-init-file"'.

옵션을 사용했다면 다음과 같은 의미입니다.
- **-m *keymap***
  뒤에 따라오는 바인딩을 *keymap*의 키맵으로 사용합니다. 사용할 수 있는 *keymap* 이름은 `emacs`, `emacs-standard`, `emacs-meta`, `emacs-ctlx`, `vi`, `vi-move`, `vi-command`, `vi-insert`입니다. `vi`는 `vi-command`와 같습니다(`vi-move` 역시 동의어입니다). `emacs`는 `emacs-standard`와 같습니다.
- **-l**
  모든 Readline 함수의 이름을 출력합니다.
- **-p**
  Readline 함수 이름과 그 바인딩을 입력이나 Readline 초기화 파일에서 사용할 수 있는 형식으로 출력합니다.
- **-P**
  현재 Readline 함수 이름과 그 바인딩을 출력합니다.
- **-v**
  Readline 변수 이름과 그 값을 입력이나 Readline 초기화 파일에서 사용할 수 있는 형식으로 출력합니다.
- **-V**
  현재 Readline 변수 이름과 그 값을 출력합니다.
- **-s**
  Readline의 매크로와 문자열에 바인드된 키 나열을 입력이나 Readline 초기화 파일에서 사용할 수 있는 형식으로 출력합니다.
- **-S**
  Readline의 매크로와 문자열에 바인드된 키 나열을 출력합니다.
- **-f *filename***
  *filename*으로부터 키 바인딩을 읽습니다.
- **-q *function***
  *function*이라는 이름을 호출하는 키가 무엇인지 질의합니다.
- **-u *function***
  *function*이라는 이름에 바인드된 모든 키를 언바인드합니다.
- **-r *keyseq***
  *keyseq*의 바인딩을 모두 제거합니다.
- **-x *keyseq*:*shell-command***
  *keyseq*가 입력될 때 *shell-command*를 실행하도록 합니다. *shell-command*가 실행되면 셸은 `READLINE_LINE` 변수에 Readline의 줄 버퍼의 내용을 저장하고, `READLINE_POINT`와 `READLINE_MARK` 변수에 각각 삽입 지점의 현재 위치와 저장된 삽입 위치(*mark*)를 저장합니다. 만약 실행된 명령어가 `READLINE_LINE`, `READLINE_POINT`, `READLINE_MARK`의 값을 변경한다면, 새 값이 편집 상태에 반영됩니다.
- **-X**
  셸 명령어에 바인드된 모든 키 나열과 연관된 명령어를 입력으로 재활용 가능한 형식으로 출력합니다.

잘못된 옵션을 넘기거나, 에러가 발생하는 경우를 제외하면 종료 스테이터스는 0입니다.

**builtin**
```sh
builtin [shell-builtin [args]]
```
*args*를 넘기고 셸 빌트인을 실행한 뒤 종료 스테이터스를 반환합니다. 이는 셸 빌트인과 동일한 이름의 셸 함수를 정의하고 함수 안에서 빌트인의 기능을 유지하고 싶을 때 유용합니다. *shell-builtin*이 셸 빌트인 명령어가 아니라면 종료 스테이터스는 0이 아닌 값입니다.

**caller**
```sh
caller [expr]
```
어떤 액티브 서브루틴 호출(셸 함수나 `.`이나 `source` 빌트인으로 실행된 스크립트)의 컨텍스트를 반환합니다.

*expr*를 넘기지 않았다면 `caller`는 줄 번호와 현재 서브루틴을 호출한 소스 파일의 이름을 출력합니다. *expr*에 음수가 아닌 정수를 넘긴다면 `caller`는 현재 실행 호출 스택의 해당 위치에 대응하는 줄 번호, 서브루틴의 이름, 소스파일 이름을 출력합니다. 이 추가 정보는 예를 들어 스택 트레이스를 출력할 때에 사용될 수 있습니다. 현재 프레임은 프레임 0입니다.

셸이 서브루틴 호출을 실행 중이 아니거나 *expr*이 호출 스택에서 유효한 위치를 참조하고 있지 않은 경우가 아니라면 반환 값은 0입니다.

**command**
```sh
command [-pVv] command [arguments …]
```
*command*라는 이름의 셸 함수가 존재한다면 이를 무시하고 *command*를 *arguments*와 함께 실행합니다. 셸 빌트인 명령어와 `PATH`에서 발견된 명령어만이 실행됩니다. 만약 `ls`라는 이름의 셸 함수가 있고 함수 내부에서 'command ls'를 실행한다면 이는 함수 자신을 재귀적으로 호출하는 대신 외부 명령어 `ls`를 실행합니다. `-p` 옵션은 `PATH`의 기본값을 사용해서 모든 표준 유틸리티를 검색할 것을 보장합니다. *command*를 찾을 수 없거나 에러가 발생했다면 반환 스테이터스는 127이 되며, 그렇지 않은 경우 *command*의 종료 스테이터스를 사용합니다.

만약 `-V`나 `-v` 옵션을 넘겼다면, *command*의 설명이 출력됩니다. `-v` 옵션은 명령어를 가리키는 한 단어나 *command*를 호출할때 사용되는 파일 이름을 출력합니다. `-V` 옵션은 좀 더 상세한 설명을 생성합니다. *command*를 발견했다면 종료 스테이터스는 0이며, 그렇지 못한 경우에는 0이 아닌 값이 됩니다.

**declare**
```sh
declare [-aAfFgiIlnrtux] [-p] [name[=value] …]
```
변수를 선언하고 속성을 부여합니다. *name*을 넘기지 않았다면, 변수의 값들을 출력합니다.

`-p` 옵션은 각 *name*의 속성과 값을 출력합니다. `-p`가 *name* 인수와 함께 사용되었다면 `-f`와 `-F`와 같은 추가 옵션을 무시합니다.

`-p` 옵션을 *name* 인수 없이 사용했다면 `declare`는 추가 옵션으로 지정된 속성을 가지는 모든 변수의 속성과 값을 출력합니다. 만약 `-p`와 함께 사용한 추가 옵션이 없다면 `declare`는 모든 셸 변수의 속성과 값을 출력합니다. `-f` 옵션은 셸 함수만 출력하도록 합니다.

`-F` 옵션은 함수의 정의를 출력하지 않도록 합니다. 함수의 이름과 속성만을 출력합니다. `shopt`(The Shopt Builtin을 참조)를 통해 `extdebug` 셸 옵션이 켜져있다면 각 *name*이 정의되어 있는 소스 파일 이름과 줄 번호도 같이 출력됩니다. `-F`는 `-f`의 동작을 포함합니다.

`-g` 옵션은 `declare`가 셸 함수에서 실행된다 하더라도 전역 스코프에서 변수를 생성하거나 전역 스코프의 값을 수정하도록 강제합니다. 그 이외의 모든 경우에는 무시됩니다.

`-I` 옵션은 지역 변수가 감싸고 있는 스코프에 같은 *name*을 가지는 변수가 있다면 속성(*nameref* 속성을 제외)과 값을 상속하도록 만듭니다. 만약 해당하는 변수가 없다면 지역 변수는 존재하지 않는 상태로 시작합니다.

다음 옵션으로 특정 속성을 가지는 변수만 출력하도록 제한하거나, 변수에 속성을 지정할 수 있습니다.

- **-a**
  각 *name*은 순차 배열 변수(Arrays를 참조)입니다.
- **-A**
  각 *name*은 연상 배열 변수(Arrays를 참조)입니다.
- **-f**
  함수명만을 사용합니다.
- **-i**
  값이 정수로 다루어져야하는 변수입니다. 변수에 값이 대입될 때 산술 평가(Shell Arithmetic을 참조)가 실행됩니다.
- **-l**
  변수에 값을 대입할 때 모든 대문자는 소문자로 변환됩니다. 대문자 속성이 무효화됩니다.
- **-n**
  각 *name*에 nameref 속성을 부여하여 다른 변수에 대한 이름 참조로 만듭니다. 참조할 변수는 *name*의 값으로 정의됩니다. *name*에 대한 모든 참조, 대입, 속성 변경은 `-n` 속성 자신을 변경하거나 사용하는 경우를 제외하면 *name*의 값이 참조하고 있는 변수에 대해서 실행됩니다. nameref 속성은 배열 변수에 적용할 수 없습니다.
- **-r**
  *name*을 읽기 전용으로 만듭니다. 이 이름은 이후의 대입문으로 값을 변경하거나 제거할 수 없습니다.
- **-t**
  각 *name*에 `trace` 속성을 부여합니다. 추적되는 함수는 호출한 셸로부터 `DEBUG`와 `RETURN` 트랩을 상속합니다. 변수의 추적 속성은 아무런 의미가 없습니다.
- **-u**
  변수에 값을 대입할 때, 모든 소문자를 대문자로 변경합니다. 소문자 속성이 무효화됩니다.
- **-x**
  각 *name*을 환경을 통해 이후의 명령어 실행시에 익스포트하도록 설정합니다.
속성을 제거하고 싶다면 '-' 대신 '+'를 사용하세요. 단 '+a'와 '+A'는 배열 변수를 삭제할 수 없으며 '+r'은 읽기 전용 속성을 제거하지 않습니다. 함수에서 사용되면 `declare`는 `-g` 옵션을 사용하지 않았다면 각 `name`을 `local` 명령어를 사용한 것처럼 해당 지역에 선언합니다. 만약 변수 이름 뒤에 =*value*가 따라온다면, 변수의 값으로 *value*가 설정됩니다.

`-a`나 `-A`를 사용하고 복합 대입 문법을 사용하여 배열 변수를 생성할 때, 추가 속성은 이후의 대입까지 적용되지 않습니다.

잘못된 옵션을 사용하거나, '-f foo=bar'를 이용해서 함수를 선언하거나, 읽기 전용 변수에 값을 할당하거나, 복합 대입 문법(Arrays를 참조)을 사용하지 않고 배열 변수에 값을 할당하거나, *name* 중 하나라도 올바르지 많은 셸 변수 이름을 사용하거나, 읽기 전용 변수의 읽기 전용 속성의 무효화를 시도하거나, 배열 변수의 배열 상태의 무효화를 시도하거나, 존재하지 않는 함수를 `-f`로 출력하려고 시도하는 경우가 아니라면 종료 스테이터스는 0입니다.

**echo**
```sh
echo [-neE] [arg …]
```
*args*를 스페이스로 구분해 출력하고 개행으로 종료합니다. 쓰기 중에 에러가 발생하지 않았다면 종료 스테이터스는 0입니다. `-n`을 넘겼다면 마지막의 개행을 출력하지 않습니다. `-e`를 넘겼다면 백슬래시로 이스케이프된 문자 처리가 유효화됩니다. `-E` 옵션은 시스템이 기본으로 처리하도록 설정되어 있다고 하더라도 이스케이프 문자 처리를 무효화합니다. `xpg_echo` 셸 옵션으로 `echo`가 이스케이프 문자를 기본으로 전개 할지 말지 지정할 수 있습니다. `echo`는 `--`를 옵션의 끝으로 인식하지 않습니다.

`echo`는 다음 이스케이프 나열을 처리할 수 있습니다.

- **\a**
  경고 (벨소리)
- **\b**
  백스페이스
- **\c**
  이후의 출력을 무시
- **\e**
- **\E**
  이스케이프
- **\f**
  폼 피드
- **\n**
  개행
- **\r**
  캐리지 리턴
- **\t**
  탭
- **\v**
  수직탭
- **\\**
  백슬래시
- **\0*nnn***
  8진수 *nnn* 으로 표현된 8비트 문자(3글자까지 허용)
- **\x*HH***
  16진수 *HH* 으로 표현된 8비트 문자(2글자까지 허용)
- **\u*HHHH***
  16진수 *HHHH* 로 표현된 유니코드(ISO/IEC 10646) 문자(16진수 4글자까지 허용)
- **\U*HHHHHHHH***
  16진수 *HHHHHHHH* 로 표현된 유니코드(ISO/IEC 10646) 문자(8진수 8글자까지 허용)

**enable**
```sh
enable [-a] [-dnps] [-f filename] [name …]
```
빌트인 셸 명령어를 유효화하거나 무효화합니다. 빌트인을 무효화하면 셸이 일반적으로 디스크 상의 명령어보다 빌트인을 우선해서 찾도록 되어있음에도 불구하고, 전체 경로를 지정하지 않더라도 셸 빌트인과 같은 이름을 가지고 있는 디스크 상의 명령어를 실행하도록 합니다. 만약 `-n`을 넘겼다면 *name*이 무효화됩니다.

이외의 경우에는 *name*을 유효화합니다. 셸 빌트인 버전 대신에 `$PATH` 상에서 찾을 수 있는 `test` 바이너리를 사용하도록 하고 싶다면 'enable -n test'라고 입력하세요.

`-p` 옵션을 넘기거나 *name* 인수를 넘기지 않았다면 셸 빌트인 명령어의 리스트가 출력됩니다. 만약 다른 인수가 없다면 리스트는 유효화되어 있는 모든 셸 빌트인입니다. `-a` 옵션은 각 빌트인을 자신이 유효한지 아닌지에 대한 정보와 함께 출력하도록 합니다.

`-f` 옵션은 다이나믹 로딩을 지원하는 시스템에서 공유 오브젝트 *filename*으로부터 새 빌트인 명령어 *name*을 로드합니다. `-f`와 함께 사용한 `-d` 옵션은 로드된 빌트인을 삭제합니다.

만약 옵션을 넘기지 않았다면 셸 빌트인의 리스트가 출력됩니다. `-s` 옵션은 `enable`이 POSIX의 특수 빌트인만을 출력하도록 제한합니다. `-f`와 함께 사용한 `-s`는 새 빌트인을 특수 빌트인으로 만듭니다(Special Builtin을 참조).

*name*이 셸 빌트인이 아니거나 공유 오브젝트로부터 새 빌트인을 로딩할 때 에러가 발생한 경우를 제외하면 종료 스테이터스는 0입니다.

**help**
```sh
help [-dms] [pattern]
```
빌트인 명령어에 대한 유용한 정보를 출력합니다. *pattern*을 지정했다면 `help`는 *pattern*에 일치하는 모든 명령어에 대한 상세한 도움말을 제공합니다. 지정이 없다면 모든 빌트인의 리스트가 출력됩니다.

옵션은 다음의 의미를 가집니다.

- **-d**
  각 *pattern*의 짧은 설명을 출력합니다.
- **-m**
  각 *pattern*의 설명을 manpage 형식으로 출력합니다.
- **-s**
  각 *pattern*의 짧은 요약을 출력합니다.

*pattern*과 일치하는 명령어가 없는 경우가 아니라면 종료 스테이터스는 0입니다.

**let**
```sh
let expression [expression …]
```
`let` 빌트인은 셸 변수에서 산술 연산을 할 수 있도록 합니다. 각 *expression*은 Shell Arithmetic의 규칙에 따라 평가됩니다. 만약 마지막 *expression*이 0으로 평가된다면 `let`은 1을 반환합니다. 그 이외의 경우 0을 반환합니다.

**local**
```sh
local [option] name[=value] …
```
각 인수에 대해서 *name*이라고 명명된 지역 변수를 생성하며, *value*를 대입합니다. *option*은 `declare`에서 사용 가능한 옵션이라면 어떤 옵션이든 사용할 수 있습니다. `local`은 함수 내부에서만 사용할 수 있습니다. `local`은 *name*이라는 변수를 해당 함수와 그 자식들에게만 보이는 스코프로 제한합니다. 만약 *name*이 '-'라면 셸 옵션의 집합을 `local`이 호출된 함수의 지역에 생성합니다. 함수 내부에서 `set` 빌트인을 사용하여 변경한 셸 옵션들은 함수가 반환될 때 원래 값으로 복원됩니다. 이 복원은 마치 함수 실행 전에 가지고 있던 값으로 복원하는 일련의 `set` 명령어가 실행되는 것처럼 동작합니다. `local`을 함수 밖에서 사용하거나, 유효하지 않은 *name*을 사용하거나 *name*이 읽기 전용인 경우가 아니라면 종료 스테이터스는 0입니다.

**logout**
```sh
logout [n]
```
로그인 셸을 종료하고 셸의 부모에게 스테이터스 *n*을 반환합니다.

**mapfile**
```sh
mapfile [-d delim] [-n count] [-O origin] [-s count]
    [-t] [-u fd] [-C callback] [-c quantum] [array]
```
표준 입력으로부터 복수의 줄을 순차 배열 변수 *array*로 읽어들입니다. `-u` 옵션을 사용하면 파일 디스크립터 *fd*로부터 읽어들입니다. 변수 `MAPFILE`이 *array*의 기본값입니다. 옵션을 넘길 수 있으며 각 옵션은 다음과 같은 의미입니다.

- **-d**
  각 입력 라인의 끝으로 개행 대신 *delim*의 첫번째 글자를 사용합니다. 만약 *delim*이 빈 문자열이라면, `mapfile`은 널 문자를 읽었을 때 한 줄을 끝낼 것입니다.
- **-n**
  최대 *count*줄을 복사합니다. *count*가 0이면 모든 줄을 복사합니다.
- **-O**
  *array*에 값을 대입할 때 *origin*번째 인덱스부터 시작하도록 합니다. 기본값은 0입니다.
- **-s**
  처음 읽어들인 *count*개의 줄을 버립니다.
- **-t**
  각 줄을 입력받을 때 마지막의 *delim*(기본값은 개행)을 제거합니다.
- **-u**
  표준 입력 대신 파일 디스크립터 *fd*로부터 줄을 읽습니다.
- **-C**
  매 *quantum* 줄을 읽을 때 마다 *callback*을 평가합니다. `-c` 옵션에 *quantum*을 지정합니다.
- **-c**
  *callback*을 호출과 다음 호출 사이에 읽을 줄 수를 지정합니다.

`-c` 없이 `-C`를 지정하는 경우, 기본 간격은 5000입니다. `callback`이 평가될 때, 다음에 대입될 배열 요소의 인덱스와 그 요소에 대입할 줄을 추가 인수로 넘겨받습니다. *callback*은 줄을 읽은 다음, 배열 요소에 대입되기 전에 평가됩니다.

명시적으로 배열 변수가 지정되지 않을 경우, `mapfile`은 대입을 시작하기 전에 `array`를 초기화합니다.

`mapfile`은 유효하지 않은 옵션 또는 옵션의 인수를 넘기거나, *array*가 유효하지 않거나 대입이 불가능하거나, 순차 배열이 아닌 경우를 제외하면 성공적으로 종료됩니다.

**printf**
```sh
printf [-v var] format [arguments]
```
*format* 서식이 적용된 *arguments*를 표준 출력에 넘깁니다. `-v` 옵션은 표준 출력에 값을 넘기는 대신 변수 *var*에 대입합니다.

*format*은 3가지의 오브젝트 타입을 포함하는 문자열입니다. 일반 문자는 표준 출력에 그대로 복사됩니다. 이스케이프 문자 나열은 적절한 변환이 이루어진 뒤에 표준 출력으로 복사됩니다. 포맷 명세는 각각 뒤따라오는 *argument*를 출력합니다. 표준 `printf(1)` 포맷에 더해, `printf`는 다음의 확장을 처리할 수 있습니다.

- **%b**
  `printf`가 각각의 대응하는 *argument*의 백슬래시 이스케이프 문자 나열을 `echo -e`(Bash Builtins를 참조)와 같은 방식으로 전개합니다.
- **%q**
  `printf`가 셸 입력으로 재활용 가능한 형식으로 각각의 대응하는 *argument*를 출력합니다.
- **%(*datefmt*)T**
  `printf`가 `strftime(3)`의 포맷 문자열 `datefmt`를 사용하여 생성된 날짜-시각 문자열을 출력합니다. 대응하는 *argument*는 유닉스 시각을 초로 나타낸 정수입니다. 2개의 특수한 인수 값을 사용할 수 있습니다. -1은 현재 시각을 나타내며, -2는 셸이 실행된 시각을 나타냅니다. 만약 인수를 넘기지 않았다면 -1을 넘긴 것처럼 변환합니다. 이는 `printf` 동작 방식의 예외입니다.

`%b`, `%q`, `%T` 디렉티브는 모두 포맷 명세의 필드 너비와 정확도 인수를 사용할 수 있으며, 전개된 인수만큼의 바이트를 출력하며(또는 그만큼의 필드 너비를 사용합니다) 이는 원래의 문자열보다 더 많은 문자를 포함할 수 있습니다.

문자열용이 아닌 포맷 식별자의 인수는 C 언어 상수인 것처럼 다루어집니다. 플러스나 마이너스 기호로 시작하는 것은 예외입니다. 첫 문자가 큰따옴표나 작은따옴표라면 뒤따라오는 값은 ASCII 값입니다.

*format*은 모든 *argument*를 소비할 때까지 재활용됩니다. *format*이 넘겨진 것보다 많은 *argument*를 필요로 하는 경우, 여분의 포맷 명세는 0이나 널 문자를 넘긴 것처럼 처리됩니다. 성공했을 때의 종료값은 0이며, 실패했을 때에는 0이 아닌 값입니다.

**read**
```sh
read [-ers] [-a aname] [-d delim] [-i text] [-n nchars]
    [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]
```
표준 입력 또는 파일 디스크립터 `-u` 옵션을 넘겼을 경우 *fd*으로부터 한 줄을 읽고 Word Splitting에서 설명한 것처럼 단어를 분리하고 첫번째 단어를 첫번째 *name*에 대입하고 두번째 단어를 두번째 *name*에 대입을 반복합니다. 넘긴 이름의 개수보다 단어의 숫자가 많다면 나머지 단어들은 구분자를 사용하여 마지막 *name*에 대입됩니다. 넘긴 이름 개수보다 입력 스트림으로부터 읽어들인 단어 수가 적을 경우, 남는 이름에는 빈 값을 대입합니다. `IFS` 변수값의 문자를 단어를 분리하기 위해서 사용합니다. 단어 분리는 셸이 전개시에 사용하는 것과 동일한 규칙으로 이루어집니다(Word Splitting을 참조). 백슬래시 문자 '\'는 다음에 오는 문자의 특수한 의미를 제거하거나 줄을 계속하기 위해서 사용할 수 있습니다.

다음의 옵션을 사용할 수 있습니다.

- **-a *aname***
  배열 변수 *aname*에 0번째 인덱스로부터 순서대로 단어를 대입합니다. *aname*의 모든 요소는 대입이 시작되기 전에 제거됩니다. *name* 인수는 무시됩니다.
- **-d *delim***
  개행 대신 *delim*의 첫번째 문자를 입력 줄의 종료로 인식합니다. *delim*이 빈 문자열이라면 `read`는 NUL 문자를 읽을 때 줄을 종료합니다.
- **-e**
  Readline(Command Line Editing을 참조)으로 줄을 읽습니다. Readline은 현재 편집 설정(또는 줄 편집을 이전에 유효화하지 않았다면 기본값)을 사용합니다만, Readline의 기본 파일 이름 완성을 사용합니다.
- **-i *text***
  줄을 읽기 위해서 Readline을 사용하는 경우, 편집이 시작되기전에 *text*를 편집 버퍼에 넣습니다.
- **-n *nchars***
  `read`가 입력의 줄을 완전히 읽는 것을 기다리지 않고 *nchars* 개의 문자만 읽고 종료합니다. 단, 구분자를 만나기 전에 *nchars*개의 문자가 이미 출현했을 경우, 구분자까지 읽습니다.
- **-N *nchars***
  `read`는 입력의 줄을 완전히 읽는 것을 기다리지 않고 정확히 *nchars*개의 문자를 읽고 종료합니다. 단, EOF를 만나거나 `read`가 타임아웃하는 경우는 예외입니다. 입력에서 구분자를 만나더라도 일반 문자인 것처럼 취급하며, *nchars*를 읽기 전까지는 `read`가 종료되지 않습니다. 읽은 결과는 `IFS`의 문자로 분리되지 않습니다. 이는 읽어들인 문자를 그대로 변수에 대입하기 위함입니다. (단 백슬래시는 예외입니다. 아래의 `-r` 옵션을 참조하세요)
- **-p *prompt***
  입력을 읽기 전에 마지막의 개행을 제거한 *prompt*를 출력합니다. 프롬프트는 입력을 터미널로부터 받을 때에만 출력됩니다.
- **-r**
  이 옵션을 사용하면 백슬래시는 이스케이프 문자인 것처럼 행동하지 않습니다. 백슬래시는 줄의 일부인 것처럼 다루어집니다. 백슬래시와 개행의 묶음은 줄을 계속한다는 의미로 사용할 수 없다는 점에 주의하세요.
- **-s**
  사일런트 모드. 입력이 터미널로부터 들어온다면 문자를 재출력하지 않습니다.
- **-t *timeout***
  `read`가 *timeout*초 이내에 입력 줄을 완전히 읽지 못한 경우(또는 특정 개수의 문자를 읽지 못한 경우) 타임아웃으로 실패하도록 합니다. *timeout*는 소숫점 이하를 포함할 수 있는 10진수입니다. 이 옵션은 `read`가 입력을 터미널, 파이프, 또는 다른 특수 파일로부터 읽을 때만 유효합니다. 일반 파일을 읽을 때에는 유효하지 않습니다. `read`가 타임아웃했다면 `read`는 읽은 입력의 일부를 *name*에 기록합니다. *timeout*이 0이라면 `read`는 데이터를 읽으려고 시도하지 않고 즉시 종료합니다. 입력이 지정된 파일 디스크립터로부터 입력을 읽을 수 있다면 종료 스테이터스는 0이며, 그렇지 않다면 0이 아닌 값입니다. 타임아웃으로 종료하는 경우, 종료 스테이터스는 128보다 큽니다.
- **-u *fd***
  입력을 파일 디스크립터 *fd*로부터 읽습니다.

*name*을 넘기지 않았다면, 줄의 끝을 표시하는 구분자를 제외한 입력 줄이 변수 `REPLY`에 대입됩니다. 파일의 종료(EOF)를 만나거나, `read`가 타임아웃으로 종료(이 경우의 스테이터스는 128보다 큽니다)하거나 변수 대입 에러(읽기 전용 변수에 대입을 시도했다든가)가 발생하거나 `-u` 옵션의 인수로 받은 파일 디스크립터가 잘못되어 있는 경우가 아니라면 종료 스테이터스는 0입니다.

**readarray**
```sh
readarray [-d delim] [-n count] [-O origin] [-s count]
    [-t] [-u fd] [-C callback] [-c quantum] [array]
```

표준 입력으로부터 복수의 줄을 순차 배열 변수 *array*로 읽어들입니다. `-u` 옵션을 사용하면 파일 디스크립터 *fd*로부터 읽어들입니다.

`mapfile`의 동의어입니다.

**source**
```sh
source filename
```
`.`의 동의어(Bourne Shell Builtins을 참조).

**type**
```sh
type [-afptP] [name …]
```
각 *name*이 명령어 이름으로 사용될 때 어떻게 처리되는지 알려줍니다.

`-t` 옵션을 사용하면 `type`는 'alias', 'function', 'builtin', 'file', 'keyword' 중 한 단어를 출력합니다. *name*은 별칭, 셸 함수, 셸 빌트인, 디스크 파일, 셸 예약어가 될 수 있습니다. *name*을 찾을 수 없다면 아무것도 출력되지 않으며, `type`은 실패 상태를 반환합니다.

`-p` 옵션을 사용하면 `type`은 실행될 디스크 파일의 이름을 반환하거나 `-t`가 'file'을 반환하지 않는 값에 대해서는 아무것도 반환하지 않습니다.

`-P` 옵션은 각 *name*의 `-t` 옵션일 때 'file'을 반환하지 않는다고 하더라도 디스크에서 찾도록 합니다.

명령어가 해싱되었다면 `-p`와 `-P`는 해싱된 값을 출력하며, 이는 `$PATH`에서 첫번째로 발견한 파일이 아닐 수 있습니다.

`-a`를 사용하면 `type`는 `file`이라는 이름을 가지는 실행 가능한 파일을 포함하는 모든 위치를 반환합니다. 이는 별칭과 함수를 포함합니다만, 단 `-p` 옵션을 사용한 경우에는 예외입니다.

`-f` 옵션을 사용하면 `type`는 `command` 빌트인처럼 셸 함수를 찾지 않습니다.

종료 스테이터스는 모든 *name*을 발견했다면 0이며, 하나라도 발견하지 못했다면 0이 아닌 값입니다.

**typeset**
```sh
typeset [-afFgrxilnrtux] [-p] [name[=value] …]
```
`typeset` 명령어는 ksh과의 호환성을 위해서 제공됩니다. 이는 `declare` 빌트인 명령어와 같습니다.

**ulimit**
```sh
ulimit [-HS] -a
ulimit [-HS] [-bcdefiklmnpqrstuvxPRT] [limit]
```
`ulimit`은 셸에서 실행되는 프로세스가 사용 가능한 리소스를 시스템 상에서 제어할 수 있게 해줍니다. 옵션은 다음과 같이 처리됩니다.

**-S**
  연관된 리소스의 소프트 리밋을 변경하고 보고합니다.
**-H**
  연관된 리소스의 하드 리밋을 변경하고 보고합니다.
**-a**
  현재의 모든 리밋을 보고합니다. 새 리밋을 설정하지 않습니다.
**-b**
  최대 소켓 버퍼 크기.
**-c**
  생성하는 코어 파일의 최대 크기.
**-d**
  프로세스의 데이터 세그먼트의 최대 크기.
**-e**
  스케줄링 우선순위의 최대값("nice" 명령어의 우선순위).
**-f**
  셸과 그 자식이 쓸 수 있는 파일의 최대 크기.
**-i**
  대기 시그널의 최대 개수.
**-k**
  할당 가능한 kqueue의 최대 개수.
**-l**
  고정 할당하는 메모리의 최대 크기.
**-m**
  레지던트 셋의 최대 크기(많은 시스템은 이 값을 참조하지 않습니다).
**-n**
  열 수 있는 파일 디스크립터의 최대 개수(많은 시스템에서는 이 값을 변경할 수 없습니다).
**-p**
  파이프 버퍼 크기.
**-q**
  POSIX 메시지 큐의 최대 바이트.
**-r**
  실시간 스케줄링 우선순위의 최대값.
**-s**
  최대 스택 크기.
**-t**
  최대 CPU 시간(초).
**-u**
  단일 유저가 사용 가능한 프로세스의 최대 개수.
**-v**
  셸과 몇몇 시스템, 그리고 그 자식에서 사용 가능한 가상 메모리의 최대값.
**-x**
  파일 잠금의 최대 개수.
**-P**
  가상 터미널의 최대 개수.
**-R**
  실시간 프로세스에 블록 당하기 전에 실행될 최대 시간(마이크로초).
**-T**
  스레드의 최대 개수.

*limit*을 넘겼고, `-a` 옵션을 사용하지 않았다면 *limit*은 지정된 리소스의 새 값이 됩니다. *limit*에 넘길 수 있는 특수한 값으로는 `hard`, `soft`, `unlimited`가 있으며 각각 현재의 하드 리밋, 현재의 소프트 리밋, 그리고 무제한을 의미합니다. 하드 리밋은 한번 설정되면 루트 권한이 없는 유저는 증가시킬 수 없습니다. 소프트 리밋은 하드 리밋의 값까지 증가시킬 수 있습니다. 그 이외에는 `-H` 옵션을 넘기지 않았다면 지정된 소프트 리밋의 현재 값이 출력됩니다. 하나 이상의 리소스를 지정한 경우, 리밋 이름과 (적당한 것이 있다면) 단위가 값 앞에 출력됩니다. 새 리밋을 설정할 때 `-H`와 `-S`를 넘기지 않았다면 하드 리밋과 소프트 리밋이 모두 설정됩니다. 만약 넘긴 옵션이 없다면 `-f`를 넘겼다고 가정합니다. 값은 일반적으로 1024바이트 단위로 증가합니다. `-t`는 단위가 초이며, `-R`은 마이크로초, `-p`는 512바이트 블록입니다. `-P`, `-T`, `-b`, `-k`, `-n`, `-u`는 스케일이 없는 값입니다. POSIX 모드(Bash POSIX Mode를 참조)에서 `-c`와 `-f`는 512바이트 단위로 증가합니다.

잘못된 옵션이나 인수를 넘기거나 새 리밋을 설정하는 동안 에러가 발생한 상황이 아니라면 종료 스테이터스는 0입니다.

**unalias**
```sh
unalias [-a] [name … ]
```
각 *name*을 별칭 리스트로부터 제거합니다. `-a`를 넘기면 모든 별칭을 제거합니다. 별칭에 대해서는 Aliases를 참조하세요.

## 4.3 Modifying Shell Behavior
- The Set Builtin : 셸 속성과 위치 매개변수의 값을 변경하기.
- The Shopt Builtin : 셸의 행동을 변경하기.

### 4.3.1 The Set Builtin
이 빌트인은 복잡하기 때문에 하나의 섹션을 전부 사용할만 합니다. `set`은 셸 옵션의 값을 변경하거나 위치 매개변수를 설정하거나 셸 변수의 이름과 값을 출력할 수 있습니다.

**set**
```sh
set [--abefhkmnptuvxBCEHPT] [-o option-name] [argument …]
set [+abefhkmnptuvxBCEHPT] [+o option-name] [argument …]
```
옵션이나 인수를 넘기지 않는다면, `set`은 모든 셸 변수와 함수의 이름과 값을 현재 로케일의 정렬순에 따라서 설정에 재사용할 수 있는, 또는 현재 설정된 변수 값을 리셋할 수 있는 형식으로 출력합니다. 읽기 전용 변수는 리셋할 수 없습니다. POSIX 모드에서는 셸 변수만 출력됩니다.

옵션을 넘긴다면 그 값이 셸 속성으로 설정되거나 제거됩니다. 각 옵션은 다음의 의미를 가집니다.

- **-a**
  각 변수나 함수를 생성하거나 수정할 때 익스포트 속성을 추가하고 이후의 명령어 환경에 익스포트하도록 표식을 남깁니다.
- **-b**
  실행이 종료된 백그라운드 잡의 스테이터스를 즉시 보고하도록 합니다. 옵션이 없는 경우, 주 프롬프트를 출력하기 직전에 보고됩니다.
- **-e**
  하나의 단순 명령어(Simple Commands를 참조), 리스트(Lists of Commands를 참조), 또는 복합 명령어(Compound Commands를 참조)로 구성된 파이프라인(Pipelines를 참조)이 0이 아닌 스테이터스를 반환하면 즉시 종료합니다. 실패한 명령어가 `while`이나 `until` 키워드의 뒤에 오는 명령어 리스트이거나 `if` 식의 테스트의 일부이거나 `&&`나 `||`의 내부에 있다면 명령어를 즉시 종료하지 않습니다. 단 `&&`와 `||`의 가장 마지막에 오는 명령어인 경우, 파이프라인의 가장 마지막 명령어인 경우, 명령어의 종료 스테이터스가 `!`로 반전되는 경우는 예외입니다. 서브셸 이외의 복합 명령어가 `-e`가 무시되는 동안 명령어가 실패해 0이 아닌 스테이터스를 반환했다면 셸은 종료되지 않습니다. `ERR`에 트랩이 설정되어 있다면 셸이 종료되기 전에 실행됩니다.

  이 옵션은 셸 환경과 각 서브셸 환경에 독립적으로 적용되며(Command Execution Environment를 참조), 이로 인해 서브셸에서 모든 명령어가 실행되기 전에 서브셸을 종료시킬 수도 있습니다.

  복합 명령어나 셸 함수가 `-e`가 무시되는 컨텍스트에서 실행된다면 복합 명령어나 함수 본체 내부에서 실행된 명령어들은 `-e`를 설정하고 명령어가 실패 스테이터스를 반환한다 하더라도 `-e` 설정의 영향을 받지 않습니다. 복합 명령어나 셸 함수가 `-e`를 무시중인 컨텍스트에서 실행중에 `-e`를 설정하더라도 복합 명령어나 함수 호출에 포함된 명령어가 완료될 때까지 이 설정은 효과를 발휘하지 않습니다.
- **-f**
  파일 이름 전개(globbing)를 무효화합니다.
- **-h**
  명령어를 실행하기 위해 검색할 때, 위치를 찾고 이를 기억합니다(`hash`). 기본 설정에서 이 옵션은 켜져 있습니다.
- **-k**
  대입문이 명령어의 앞에 위치하지 않더라도 명령어의 환경에 배치합니다.
- **-m**
  잡 컨트롤을 유효화합니다(Job Control을 참조). 모든 프로세스는 별개의 프로세스 그룹에서 실행됩니다. 백그라운드 잡이 완료되면 셸은 해당 잡의 종료 스테이터스를 포함하는 줄을 출력합니다.
- **-n**
  명령어를 읽지만 실행하지 않습니다. 이는 스크립트의 문법 에러를 검사하기 위해서 사용할 수 있습니다. 인터랙티브 셸은 이 옵션을 무시합니다.
- **-o *option-name***
  *option-name*에 대응하는 옵션을 설정합니다.
  - **allexport**
    `-a`와 같습니다.
  - **braceexpand**
    `-B`와 같습니다.
  - **emacs**
    emacs 스타일의 편집 인터페이스(Command Line Editing을 참조)를 사용합니다. 이는 `read -e`에서 사용하는 편집 인터페이스에도 적용됩니다.
  - **errexit**
    `-e`와 같습니다.
  - **errtrace**
    `-E`와 같습니다.
  - **functrace**
    `-T`와 같습니다.
  - **hashall**
    `-h`와 같습니다.
  - **histexpand**
    `-H`와 같습니다.
  - **history**
    명령어 이력을 유효화합니다. 이 기능은 Bash History Facilities에서 설명합니다. 인터랙티브 셸의 기본 설정에서 이 옵션은 켜져있습니다.
  - **ignoreeof**
    인터랙티브 셸이 EOF를 읽어도 종료하지 않습니다.
  - **keyword**
    `-k`와 같습니다.
  - **monitor**
    `-m`와 같습니다.
  - **noclobber**
    `-C`와 같습니다.
  - **noexec**
    `-n`와 같습니다.
  - **noglob**
    `-f`와 같습니다.
  - **nolog**
    현재는 무시됩니다.
  - **notify**
    `-b`와 같습니다.
  - **nounset**
    `-u`와 같습니다.
  - **onecmd**
    `-t`와 같습니다.
  - **physical**
    `-P`와 같습니다.
  - **pipefail**
    설정하면 파이프라인의 종료값은 0이 아닌 값으로 종료한 가장 마지막(또는 가장 오른쪽) 명령어의 값이나 파이프라인의 모든 명령어가 성공적으로 종료했다면 0입니다. 이 옵션은 기본 설정에서 꺼져 있습니다.
  - **posix**
    POSIX 표준과 다른 Bash의 기본 동작을 표준(Bash POSIX Mode를 참조)에 준수하도록 변경합니다. 이는 Bash를 표준의 엄밀한 상위 집합으로 동작시키기 위함입니다.
  - **privileged**
    `-p`와 같습니다.
  - **verbose**
    `-v`와 같습니다.
  - **vi**
    vi 스타일의 편집 인터페이스를 사용합니다. 이는 `read -e`에서 사용하는 편집 인터페이스에도 적용됩니다.
  - **xtrace**
    `-x`와 같습니다.
- **-p**
  특권 모드를 켭니다. 이 모드에서는 `$BASH_ENV`와 `$ENV`를 처리하지 않으며, 셸 함수를 환경으로부터 상속하지 않습니다. 그리고 `SHELLOPTS`, `BASHOPTS`, `CDPATH`, `GLOBIGNORE` 변수가 존재하더라도 무시합니다. 셸이 실제 유저(그룹) id와 다른 유효한 유저(그룹) id로 기동하고 `-p` 옵션을 넘기지 않을 경우, 이 동작은 유효한 유저 id를 실제 유저 id로 설정합니다. 기동시에 `-p` 옵션을 넘기면 유효한 유저 id는 초기화되지 않습니다. 이 옵션을 끄면 유효한 유저와 그룹 id는 실제 유저와 그룹 id가 됩니다.
- **-t**
  명령어 하나를 읽고 실행한 뒤 종료합니다.
- **-u**
  매개변수 전개중에 특수한 매개변수 '@'와 '*'를 제외한 설정되지 않은 변수와 매개변수를 사용하려고 하면 에러가 됩니다. 에러 메시지는 표준 에러에 출력되며 논-인터랙티브 셸이라면 종료합니다.
- **-v**
  셸 입력 줄이 읽은 내용을 출력합니다.
- **-x**
  단순 명령어, `for` 명령어, `case` 명령어, `select` 명령어, 산술 `for` 명령어와 그 인수 또는 연관된 단어 리스트를 전개된 뒤, 실행되기 전에 트레이스를 출력합니다. `PS4` 변수의 값을 전개한 결과를 각 명령어와 전개된 인수 앞에 출력합니다.
- **-B**
  셸이 중괄호 전개(Brace Expansion을 참조)를 수행합니다. 기본 설정에서 이 옵션은 켜져 있습니다.
- **-C**
  '>', '>&', '<>'를 사용한 출력 리다이렉션이 이미 존재하는 파일을 덮어쓸 수 없도록 합니다.
- **-E**
  설정되어 있다면 `ERR` 트랩은 셸 함수, 명령어 치환, 서브셸에서 실행되는 명령어에 상속됩니다. `ERR` 트랩은 일반적으로 이러한 경우에 상속되지 않습니다.
- **-H**
  '!' 스타일의 이력 치환(History Interaction을 참조)을 유효화합니다. 인터랙티브 셸의 기본 설정에서 이 옵션은 켜져있습니다.
- **-P**
  설정되어 있다면, 현재 디렉터리를 변경하는 `cd` 등의 명령어를 실행할 때 심볼릭 링크를 해결하지 않습니다. 그 대신 실제 디렉터리가 사용됩니다. Bash의 기본 설정에서는 현재 디렉터리를 변경하는 명령어를 실행할 때 디렉터리의 가상 연결을 따라갑니다.
  예를 들어, `/usr/sys`가 `/usr/local/sys`를 가리키는 심볼릭 링크라고 가정해봅시다.
  ```sh
  $ cd /usr/sys; echo $PWD
  /usr/sys
  $ cd ..; pwd
  /usr
  ```
  만약 `set -P`가 켜져있다면 다음처럼 동작합니다.
  ```sh
  $ cd /usr/sys; echo $PWD
  /usr/local/sys
  $ cd ..; pwd
  /usr/local
  ```
- **-T**
  설정되어 있다면, `DEBUG`와 `RETURN`의 트랩은 셸 함수, 명령어 치환, 서브셸 환경에서 실행되는 명령어에 계승됩니다. `DEBUG`와 `RETURN` 트랩은 일반적으로 이러한 경우에 계승되지 않습니다.
- **--**
  이 옵션 뒤에 인수가 존재하지 않는다면 위치 매개변수가 제거됩니다. 그렇지 않으면, 몇몇 변수가 '-'로 시작하더라도 위치 매개변수를 *argument*로 설정합니다.
- **-**
  옵션의 끝을 알리며, 나머지 모든 *argument*는 위치 매개변수에 설정됩니다. `-x`와 `-v` 옵션이 꺼집니다. 인수가 없다면, 위치 매개변수는 변경되지 않습니다.

옵션을 끄고 싶은 경우 '-' 대신 '+'를 사용하세요. 이 옵션들은 셸을 호출할 때에도 사용할 수 있습니다. 현재 셸의 옵션은 `$-`에서 확인할 수 있습니다.

나머지 N *argument*는 위치 매개변수가 되며 `$1`, `$2`, ... `$N` 순서로 대입됩니다. 특수 매개변수 `#`에는 N이 설정됩니다.

잘못된 옵션을 넘기지 않는 이상 종료 스테이터스는 언제나 0입니다.

### 4.3.2 The Shopt Builtin
이 빌트인으로 셸의 추가 행동 옵션을 변경할 수 있습니다.

**shopt**
```sh
shopt [-pqsu] [-o] [optname …]
```
셸의 추가 행동 옵션을 켜고 끌 수 있습니다. 사용 가능한 설정은 아래에서 볼 수 있습니다. `-o` 옵션을 사용하는 경우, 빌트인 명령어 `set`(The Set Builtin을 참조)의 `-o` 옵션과 동일합니다. 옵션을 넘기지 않거나, `-p` 옵션을 넘긴다면 설정 가능한 모든 옵션과 해당 옵션의 설정 값의 리스트를 출력합니다. *optname*을 넘긴 경우, 해당 옵션들만 출력합니다. `-p` 옵션은 입력으로 재사용 가능한 형식으로 출력합니다. 이외의 옵션은 다음의 의미를 가집니다.

- **-s**
  각 *optname*을 켭니다(set).
- **-u**
  각 *optname*을 끕니다(unset).
- **-q**
  일반 출력을 억제합니다. 종료 스테이터스는 *optname*이 켜졌는지 꺼졌는지 알려줍니다. 만약 여러 개의 *optname* 인수를 `-q` 와 함게 넘겼다면 모든 *optname*이 켜진다면 종료 스테이터스는 0입니다. 그 이외는 0이 아닌 값입니다.
- **-o**
  *optname*의 값으로 `set` 빌트인의 `-o` 옵션에서 정의된 것만 받습니다(The Set Builtin을 참조).

`optname` 인수 없이 `-s`나 `-u`를 사용하면, `shopt`는 켜진 옵션 또는 꺼진 옵션만을 각각 보여줍니다.

따로 언급하지 않으면 `shopt`로 지정하는 옵션의 기본 설정은 꺼짐입니다.

옵션 리스트를 출력할 때 모든 `optname`이 켜져있으면 종료 스테이터스는 0입니다. 그 이외의 경우는 0이 아닌 값입니다. 값을 변경하는 경우, `optname`이 잘못된 옵션이 아니라면 종료 스테이터스는 0입니다.

다음은 `shopt`의 옵션 리스트입니다.

- **assoc_expand_once**
  설정했다면, 셸은 산술 표현식 평가할 때와 변수 대입이 발생할 수 있는 빌트인 명령어를 실행할 때, 배열을 역참조하는 빌트인 명령어를 실행할 때 연상 배열의 첨자를 다중 평가하지 않습니다.
- **autocd**
  설정했다면 디렉터리 이름을 명령어 이름으로 실행하면 마치 `cd` 명령어에 인수로 넘겨진 것처럼 행동합니다. 이는 인터랙티브 셸에서만 사용할 수 있습니다
- **cdable_vars**
  설정했다면 `cd` 빌트인 명령어에 디렉터리가 아닌 인수를 넘기면 값에 이동하고 싶은 디렉터리 이름이 들어있는 변수의 이름이라고 인식합니다.
- **cdspell**
  설정했다면 `cd` 명령어에 넘긴 디렉터리 이름의 간단한 철자 미스를 자동으로 수정합니다. 검사하는 에러는 순서가 뒤바뀐 문자, 빠진 문자, 불필요한 문자입니다. 만약 실수가 발견되면, 수정된 경로가 출력되고 명령어가 실행됩니다. 이 옵션은 인터랙티브 셸에서만 사용할 수 있습니다.
- **checkhash**
  설정했다면 Bash는 명령어를 실행하기 전에 해당 명령어가 해시 테이블에 들어있는지 검사합니다. 만약 테이블에 명령어가 존재하지 않는다면, 통상의 경로 검색을 수행합니다.
- **checkjobs**
  설정했다면 Bash는 모든 멈춘, 실행중인 잡의 상태를 인터랙티브 셸이 종료되기 전에 출력합니다. 만약 실행중인 잡이 있다면 별 다른 명령어 실행 없이 한 번 더 종료를 시도했을 때 실제로 종료합니다(Job Control을 참조). 멈춰둔 잡이 있다면 셸은 항상 종료를 연기합니다.
- **checkwinsize**
  설정했다면 Bash는 빌트인이 아닌 각 외부 명령어를 실행하고 윈도우 크기를 검사합니다. 그리고 필요하다면 `LINES`와 `COLUMNS`의 값을 갱신합니다. 이 옵션의 기본 설정은 켜짐입니다.
- **cmdhist**
  설정했다면 Bash는 여러줄로 구성된 명령어의 줄 전체를 하나의 이력으로 저장합니다. 이는 여러줄로 구성된 명령어의 재편집을 간단하게 만들기 위함입니다. 이 옵션의 기본 설정은 켜짐이지만 명령어 이력 기능이 켜져있을 때에만 유효합니다(Bash History Facilites를 참조).
- **compat31**
- **compat32**
- **compat40**
- **compat41**
- **compat42**
- **compat43**
- **compat44**
  이 옵션들은 셸의 호환성 모드(Shell Compatibility Mode를 참조)를 제어합니다.
- **complete_fullquote**
  설정했다면 Bash는 완성 기능을 실행할 때 파일 이름과 디렉터리 이름에 포함되어있는 모든 메타 문자를 따옴표로 감쌉니다. 설정하지 않았다면, Bash는 문자 집합으로부터 달러 기호처럼 완성해야할 단어 목록이 들어있는 셸 변수 참조에 들어있는 메타 문자가 있을 때, 완성하면서 따옴표로 감싸야 하는 메타 문자를 제거합니다. 이는 디렉터리 이름으로 전개될 변수 이름의 달러 기호를 따옴표로 감싸지 않는다는 의미입니다. 그러나 파일 이름 중에 존재하는 달러 기호 역시 따옴표로 감싸지 않습니다. 이는 Bash가 완성된 파일 이름을 감싸기 위해서 백슬래시를 사용하는 경우에만 유효합니다. 이 변수의 기본 설정은 켜짐이며, 이는 Bash 4.2까지의 기본 동작이기도 합니다.
- **direxpand**
  설정했다면 Bash는 디렉터리 이름을 파일명 완성을 실행할 때 단어 전개한 결과로 대체합니다. 이는 Readline 편집 버퍼의 내용도 변경합니다. 설정하지 않았다면 Bash는 유저가 입력한 내용을 그대로 유지합니다.
- **dirspell**
  설정했다면 Bash는 단어 완성 처리 중에 주어진 디렉터리 이름을 찾지 못할 경우, 철자 교정을 시도합니다.
- **dotglob**
  설정했다면 Bash는 파일명 전개의 결과에 '.'로 시작하는 파일명을 포함합니다. `dotglob`이 켜져있더라도 파일명 '.'와 '..'은 언제나 명시적으로 일치해야 합니다.
- **execfail**
  설정했다면 논-인터랙티브 셸은 `exec` 빌트인 명령어의 인수로 지정된 파일을 실행하지 못하더라도 종료하지 않습니다. 인터랙티브 셸은 `exec`가 실패하더라도 종료하지 않습니다.
- **expand_aliases**
  설정했다면 별칭은 다음 Aliases에서 설명되는 규칙대로 전개됩니다. 인터랙티브 셸에서 이 옵션의 기본값은 켜짐입니다.
- **extdebug**
  셸을 실행할 때나 셸 기동 파일에서 설정했다면 셸을 시작하기 전에 디버거 프로파일을 실행합니다. 이는 `--debugger` 옵션과 동일합니다. 셸이 실행된 이후에 설정하면 디버거를 사용을 위한 동작이 활성화되며 이는 다음과 같습니다.
  1. `declare` 빌트인(Bash Builtins를 참조)의 `-F` 옵션은 인수로 넘긴 소스 파일명과 각 함수 이름에 대응하는 줄 번호를 출력합니다.
  2. `DEBUG` 트랩으로 실행된 명령어가 0이 아닌 값을 반환하면 다음 명령어는 생략되어 실행되지 않습니다.
  3. `DEBUG` 트랩으로 실행된 명령어가 2고 셸이 서브루틴(셸 함수나 `.`나 `source` 빌트인으로 실행된 셸 스크립트)을 실행중이라면, 셸은 `return`을 호출한 것처럼 동작합니다.
  4. `BASH_ARGC`와 `BASH_ARGV`가 설명에 기술된 대로 갱신됩니다(Bash Variables를 참조).
  5. 함수 추적이 유효화됩니다. 명령어 치환, 셸 함수, ( *command* )로 호출된 서브셸은 `DEBUG`와 `RETURN` 트랩을 상속합니다.
  6. 에러 추적이 유효화됩니다. 명령어 치환, 셸 함수, ( *command* )로 호출된 서브셸은 `ERR` 트랩을 상속합니다.
- **extglob**
  설정했다면 위에서 설명한 확장된 패턴 매칭 기능(Pattern Matching을 참조)을 켭니다.
- **extquote**
  설정했다면 큰따옴표로 감싼 `${parameter}` 전개 내부의 `$'string'`과 `$"string"`의 감싸기가 실행됩니다. 이 옵션의 기본 설정은 켜짐입니다.
- **failglob**
  설정했다면 파일명 전개중에 패턴 일치에 실패하면 전개 에러를 발생시킵니다.
- **force_fignore**
  설정했다면 `FIGNORE` 셸 변수로 지정한 접미사를 사용하는 단어는 단어 완성을 실행할 때 유일한 완성 후보라고 하더라도 무시합니다. `FIGNORE`의 설명은 Bash Variables를 참조하세요. 이 옵션의 기본값은 켜짐입니다.
- **globasciiranges**
  설정했다면 패턴 매칭의 대괄호에서 사용된 범위 표현식(Pattern Matching을 참조)이 값을 비교할 때 전형적인 C 로케일인 것처럼 동작합니다. 현재 로케일의 대조 순서는 고려되지 않으므로 'b'는 'A'와 'B'의 사이에 있지 않으며, ASCII 대문자와 소문자가 따로따로 모입니다.
- **globstar**
  설정했다면, 파일명 전개 컨텍스트에서 사용된 패턴 '\*\*'은 모든 파일과 0개 이상의 디렉터리, 자식 디렉터리와 일치합니다. 만약 패턴 뒤에 '/'가 온다면 디렉터리와 자식 디렉터리만 일치합니다.
- **gnu_errfmt**
  설정했다면 셸의 에러 메시지는 표준 GNU 에러 메시지 형식으로 생성됩니다.
- **histappend**
  설정했다면, 셸이 종료할 때 이력 리스트는 `HISTFILE` 변수에 들어있는 값을 이름으로 하는 파일을 덮어쓰지 않고 말미에 추가됩니다.
- **histreedit**
  Readline을 사용하는 중에 설정했다면 사용자는 실패한 이력 치환을 재수정할 수 있는 기회를 얻을 수 있습니다.
- **histverify**
  Readline을 사용하는 중에 설정했다면 이력 치환의 결과는 즉시 셸 파서로 넘겨지지 않습니다. 그 대신 추가로 수정할 수 있도록 Readline 편집 버퍼로 로딩됩니다.
- **hostcomplete**
  Readline을 사용하는 중에 설정했다면 Bash는 '@'을 포함하는 단어를 완성(Commands For Completion을 참조)하는 경우, 호스트명 완성을 시도합니다. 이 옵션의 기본 설정은 켜짐입니다.
- **huponexit**
  설정했다면 Bash는 인터랙티브 로그인 셸이 종료할 때 `SIGHUP`을 모든 잡에 전송합니다(Signals를 참조).
- **inherit_errexit**
  설정했다면, 명령어 치환은 서브셸의 환경에서 `errexit` 옵션을 제거하지 않고 값을 상속합니다. 이 옵션은 POSIX 모드라면 켜집니다.
- **interactive_comments**
  인터랙티브 셸에서 '#'으로 시작하는 단어와 해당 줄의 나머지 모든 문자를 무시합니다. 이 옵션의 기본 설정은 켜짐입니다.
- **lastpipe**
  잡 컨트롤이 활성화되지 않은 상태에서 이 옵션을 설정했다면, 셸은 백그라운드에서 실행되지 않은 파이프라인의 마지막 명령어를 현재 셸 환경에서 실행합니다.
- **lithist**
  `cmdhist` 옵션이 켜져있고, 이 옵션을 설정했다면 여러 줄로 구성된 명령어는 가능하다면 세미콜론 구분자 대신에 개행을 사용하여 이력에 저장합니다.
- **localvar_inherit**
  설정했다면, 지역 변수는 새 값을 대입하기 전까지는 이전 스코프에서 같은 이름을 가진 변수의 값과 속성을 상속합니다. 단, *nameref* 속성은 상속하지 않습니다.
- **localvar_unset**
  설정했다면, 이전 함수 스코프에 존재하던 지역 변수에 `unset`을 호출하면 값을 제거한 것으로 표식을 남기고 이후의 검색에서는 해당 함수가 반환될 때까지 제거된 것으로 취급합니다. 이는 현재 함수 스코프에 있는 지역 변수를 제거하는 동작과 동일합니다.
- **login_shell**
  셸이 로그인 셸로서 기동했을 때(Invoking Bash를 참조) 이 옵션을 켭니다. 값은 변경되지 않습니다.
- **mailwarn**
  Bash가 메일을 확인하기 위한 파일에 마지막으로 확인한 이후로 파일에 접근이 있었다면 "the mail in mailfile has been read"를 출력합니다.
- **no_empty_cmd_completion**
  Readline이 사용중이고 이 옵션을 설정했다면 빈 줄에서 완성을 시도할 때, Bash는 가능한 완성을 확인하기 위해 `PATH`를 탐색하지 않습니다.
- **nocaseglob**
  설정했다면 Bash는 일치하는 파일명 전개를 수행할 때 파일명의 대소문자를 구분하지 않습니다.
- **nocasematch**
  설정했다면 Bash는 `case`나 `[[` 조건 명령어, 단어 전개에서의 패턴 치환 중, 프로그래밍 가능한 완성의 일부로 완성의 후보군을 찾을 때의 대소문자를 구분하지 않고 패턴을 검사합니다.
- **nullglob**
  설정했다면 Bash는 어떤 파일에도 일치하지 않는 파일명 패턴을 그대로 두지 않고 널 문자열로 전개합니다.
- **progcomp**
  설정했다면 프로그래밍 가능한 완성 기능(Programmable Completion을 참조)을 유효화합니다. 이 옵션의 기본 설정은 켜짐입니다.
- **progcomp_alias**
  프로그래밍 가능한 완성 기능이 켜져있고, 이 옵션을 설정했다면 Bash는 어떤 완성 후보도 없는 명령어의 이름을 별칭으로 판단하고 별칭 전개를 시도합니다. 별칭을 가지고 있다면 Bash는 별칭을 전개한 결과로 얻은 단어를 사용해 프로그래밍 가능한 완성을 시도합니다.
- **promptvars**
  설정했다면, 프롬프트 문자열에 아래에서 설명하는 전개(Controlling the Prompt를 참조) 이후에 매개변수 전개, 명령어 치환, 산술 전개, 따옴표 제거가 적용됩니다. 이 옵션의 기본 설정은 켜짐입니다.
- **restricted_shell**
  셸을 한정 모드(The Restricted Shell을 참조)로 실행했을 때 셸은 이 옵션을 설정합니다. 값은 변경되지 않습니다. 기동 파일을 실행하더라도 이 값은 리셋되지 않으며, 기동 파일은 셸이 한정 모드인지 아닌지 확인할 수 있습니다.
- **shift_verbose**
  설정했다면, `shift` 빌트인은 위치 매개변수의 개수보다 옮겨야하는 개수가 클 경우 에러 메시지를 출력합니다.
- **sourcepath**
  설정했다면 `source` 빌트인은 인수로 넘긴 파일을 가지고 있는 디렉터리를 찾기 위해서 `PATH` 값을 사용합니다. 이 옵션의 기본 설정은 켜짐입니다.
- **xpg_echo**
  설정했다면 `echo` 빌트인은 백슬래시 이스케이프 문자열을 전개합니다.

## 4.4 Special Builtins
역사적인 이유로 POSIX 표준은 몇몇 빌트인 명령어를 특수한 명령어로 분류했습니다. Bash는 POSIX 모드로 동작할 때, 이 특수 빌트인은 다른 빌트인 명령어들과 3가지 측면에서 다릅니다.

1. 특수 빌트인은 명령어 탐색 중에 셸 함수보다 먼저 검색됩니다.
2. 논-인터랙티브 셸은 특수 빌트인이 에러 스테이터스를 반환하면 종료됩니다.
3. 명령어 앞의 대입문이 명령어가 실행된 이후에도 셸 환경에 남아서 영향을 줍니다.

Bash가 POSIX 모드로 동작하고 있는 중이 아니라면, 이 빌트인들은 다른 Bash 빌트인 명령어들과 동일하게 동작합니다. Bash POSIX 모드는 Bash POSIX Mode에서 설명합니다.

다음은 POSIX 특수 빌트인입니다.

```
break : . continue eval exec exit export readonly return set
shift trap unset
```

# 5. Shell Variables
- Bourne Shell Variables : Bash가 Bourne Shell와 동일하게 사용하는 변수.
- Bash Variables : Bash에 존재하는 변수.

이 장에서는 Bash가 사용하는 셸 변수에 대해서 설명합니다. Bash는 많은 변수에 자동으로 기본값을 대입합니다.
## 5.1 Bourne Shell Variables
Bash는 몇몇 변수를 Bourne 셸과 동일한 방식으로 사용합니다. Bash는 몇몇 상황에서 변수에 기본 값을 대입합니다.

**CDPATH**
콜론으로 구분된 디렉터리의 리스트입니다. 이는 `cd` 빌트인 명령어의 경로 탐색에 사용됩니다.

**HOME**
현재 사용자의 홈 디렉터리입니다. `cd` 빌트인 명령어의 기본값입니다. 이 변수의 값은 물결줄표 전개(Tilde Expansion을 참조)에서도 사용합니다.

**IFS**
필드를 구분하는 문자 리스트입니다. 이는 셸이 전개의 일부로 단어를 분리할 때 사용합니다.

**MAIL**
이 매개변수에 파일명이나 디렉터리가 설정되어있고, `MAILPATH` 변수가 설정되어 있지 않다면, Bash는 지정된 파일이나 Maildir 형식의 디렉터리에 메일의 도착을 유저에게 알려줍니다.

**MAILPATH**
콜론으로 구분된 파일명 리스트입니다. 셸이 새 메일이 도착했는지 이를 주기적으로 확인합니다. 각 파일명은 새 메일이 메일 파일에 도착했을 때 출력되는 메시지에서 '?'로 나눠서 확인할 수 있습니다. 메시지의 본문에서 사용하는 경우, `$_`는 현재 메일 파일의 이름으로 전개됩니다.

**OPTARG**
`getopts` 빌트인이 처리한 마지막 옵션 인수의 값입니다.

**OPTIND**
`getopts` 빌트인이 처리한 마지막 옵션 인수의 인덱스입니다.

**PATH**
콜론으로 구분된 디렉터리 리스트입니다. 이 리스트는 셸이 명령어를 찾기 위해서 사용합니다. `PATH`에서 길이가 0(널)인 디렉터리 이름은 현재 디렉터리를 가리킵니다. 널 디렉터리 이름은 2개의 인접한 콜론이나 처음이나 마지막의 콜론으로 나타납니다.

**PS1**
주 프롬프트 문자열입니다. 기본 값은 '\s-\v\$ '입니다. `PS1`을 출력하기 전에 전개되는 이스케이프 나열의 전체 리스트에 대해서는 Controlling the Prompt를 참조하세요.

**PS2**
부 프롬프트 문자열입니다. 기본 값은 '>'입니다. `PS2`는 출력되기 전에 `PS1`과 동일한 방식으로 전개됩니다.
## 5.2 Bash Variables
다음 변수는 Bash가 설정하거나 사용하며, 다른 셸에서는 보통 특별하게 다루지 않습니다.

Bash에서 잡 컨트롤 기능에서 사용하는 몇몇 변수들은 다른 장(Job Control Variables를 참조)에서 설명합니다.

**_**
(`$_`, 언더스코어.) 셸이 시작할 때, 셸 또는 실행시에 환경이나 인수 리스트에 넘긴 셸 스크립트가 호출될 때 사용된 경로로 설정됩니다. 그 후에는 포어그라운드에서 실행된 이전 단순 명령어의 마지막 인수로 전개됩니다. 또한 해당 명령어의 익스포트된 환경에 각 명령어가 실행할 때 호출된 전체 경로를 설정합니다. 메일을 확인할 때, 이 매개변수는 메일 파일의 이름이 됩니다.

**BASH**
현재 Bash 인스턴스를 실행할 때 사용된 전체 경로.

**BASHOPTS**
콜론으로 구분되어 있는 유효화된 셸 옵션 리스트. 리스트의 각 단어는 `shopt` 빌트인 명령어(The Shopt Builtin을 참조)에 `-s` 옵션과 함께 넘길 수 있는 유효한 인수입니다. `BASHOPTS`에서 확인할 수 있는 옵션은 `shopt`에서 켜짐으로 표시되어 있습니다. Bash가 기동할 때 환경에 이 변수가 있다면 기동 파일을 읽기 전에 리스트에 있는 옵션을 켭니다. 이 변수는 읽기 전용입니다.

**BASHPID**
현재 Bash 프로세스의 프로세스 ID로 전개됩니다. 이는 Bash의 재초기화를 요구하지 않는 서브셸과 같은 특정 환경에서 `$$`와 다른 값을 가집니다. `BASHPID`에 대한 대입은 무의미합니다. `BASHPID`가 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**BASH_ALIASES**
`alias` 빌트인 명령어(Bourne Shell Builtin을 참조)가 관리하고 있는 내부의 별칭 리스트에 대응하는 연상 배열 변수. 이 배열에 추가된 요소는 별칭 리스트에도 추가됩니다. 그러나 현재 배열 요소를 제거하는 것은 별칭을 별칭 리스트로부터 제거하지 않습니다. 만약 `BASH_ALIASES`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**BASH_ARGC**
현재 Bash 실행 콜 스택의 각 프레임에 있는 매개변수의 개수를 저장한 배열 변수. 현재 서브루틴(셸 함수나 `.`나 `source`로 실행된 스크립트)의 매개변수의 개수는 스택의 가장 위에 있습니다. 서브루틴이 실행될 때, 매개변수의 개수가 `BASH_ARGC`에 푸시됩니다. 셸은 확장된 디버깅 모드(Shopt Builtin에서 `shopt` 빌트인의 `extdebug` 옵션을 참조)에서만 `BASH_ARGC`를 설정합니다. 셸이 스크립트를 실행하기 시작한 이후나 `extdebug`를 켜지 않은 동안 이 변수에 접근하면 일관성이 없는 값을 반환할 수 있습니다.

**BASH_ARGV**
현재 Bash 실행 콜 스택의 각 프레임에 있는 매개변수를 저장한 배열 변수. 현재 서브루틴(셸 함수나 `.`나 `source`로 실행된 스크립트)의 마지막 매개변수는 스택의 가장 위에 있습니다. 첫번째 호출의 첫번째 매개변수는 가장 밑에 있습니다. 서브루틴이 실행될 때, 넘긴 매개변수가 `BASH_ARGV`에 푸시됩니다. 셸은 확장된 디버깅 모드(Shopt Builtin에서 `shopt` 빌트인의 `extdebug` 옵션을 참조)에서만 `BASH_ARGV`를 설정합니다. 셸이 스크립트를 실행하기 시작한 이후나 `extdebug`를 켜지 않은 동안 이 변수에 접근하면 일관성이 없는 값을 반환할 수 있습니다.

**BASH_ARGV0**
이 변수는 참조할 때 셸이나 셸 스크립트의 이름으로 전개(`$0`과 동일하며, `0` 특수 매개변수에 대해서는 Special Parameters를 참조)됩니다. `BASH_ARGV0`에 값을 대입하는 것은 `$0`에 대입하는 것과 같습니다. `BASH_ARGV0`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**BASH_CMDS**
`hash` 빌트인 명령어(Bourne Shell Builtin을 참조)가 관리하고 있는 내부의 해시 테이블에 대응하는 연상 배열 변수. 이 배열에 추가한 요소는 해시 테이블에서도 추가됩니다. 그러나 현재 배열 요소를 제거하더라도 해시 테이블로부터 명령어 이름을 제거하지 않습니다. `BASH_CMDS`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**BASH_COMMAND**
셸이 명령어를 트랩으로부터 실행하는 것이 아닌 경우의 현재 실행중이거나, 곧 실행할 명령어. `BASH_COMMAND`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**BASH_COMPAT**
셸의 호환 레벨을 지정하는데 쓰입니다. 다양한 호환 레벨과 그 영향에 대해서는 Shell Compatibility Mode를 참조하세요. 값은 원하는 호환 레벨에 맞는 숫자이며, 소수를 포함할 수 있습니다(e.g. 4.2, 42). `BASH_COMPAT`이 설정되어 있지 않거나 빈 문자열일 경우, 호환 레벨은 현재 버전의 기본값으로 설정됩니다. `BASH_COMPAT`의 값이 유효한 호환 레벨이 아니라면 셸은 에러 메시지를 출력하고, 현재 버전의 기본 호환 레벨 값을 설정합니다. 호환 레벨로 유효한 값은 아래에서 설명합니다(Shell Compatibility Mode를 참조). 예를 들어 4.2와 42는 `shopt` 옵션인 `compat42`에 대응하며 호환 레벨을 42로 설정합니다. 현재 버전 역시 유효한 값입니다.

**BASH_ENV**
셸 스크립트를 실행하기 위해 Bash를 호출했을 때 이 변수가 설정되어 있다면 스크립트를 실행하기 전에 읽는 기동 파일의 이름으로 전개되고 사용됩니다. Bash Startup Files를 참조하세요.

**BASH_EXECUTION_STRING**
`-c` 옵션에 넘긴 인수.

**BASH_LINENO**
*FUNCNAME*을 호출했을 때 각 요소가 그에 대응하는 소스 파일의 줄 번호인 배열 변수. `${BASH_LINENO[$i]}`는 소스 파일(`${BASH_SOURCE[$i+1]}`)의 `${FUNCNAME[$i]}`가 호출된 줄번호입니다(또는 다른 셸 함수에서 참조되었다면 `${BASH_LINENO[$i-1]}`입니다). 현재 줄번호를 얻고 싶다면 `LINENO`를 사용하세요.

**BASH_LOADABLES_PATH**
콜론으로 구분된 디렉터리 리스트입니다. 셸은 `enable` 명령어로 이 디렉터리 리스트에서 동적으로 로드 가능한 빌트인 명령어를 찾습니다.

**BASH_REMATCH**
`[[` 조건 명령어에서 '=\~' 이항 연산자를 사용하는 것으로 대입 가능한 배열 변수(Conditional Constructs를 참조). 0번 인덱스의 요소는 전체 정규 표현식에 일치한 문자열의 위치입니다. *n*번째 인덱스의 요소는 *n*번째 소괄호의 부분 표현식에 일치한 문자열의 위치입니다.

**BASH_SOURCE**
명`FUNCNAME` 배열 변수에 정의된 셸 함수 이름들에 대응하는 소스 파일 이름으로 이루어진 배열 변수. 셸 함수 `${FUNCNAME[$i]}`는 `${BASH_SOURCE[$i]}`에 정의되어 있으며, `${BASH_SOURCE[$i+1]}`로부터 호출됩니다.

**BASH_SUBSHELL**
셸이 해당 환경에서 실행될 때, 각 서브셸 또는 서브셸 환경에서 1씩 증가합니다. 초기값은 0입니다. `BASH_SUBSHELL`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**BASH_VERSINFO**
실행중인 Bash 인스턴스의 버전 정보를 가지고 있는 읽기 전용 배열 변수(Arrays를 참조). 배열 요소에 들어있는 값은 다음과 같습니다.

- **BASH_VERSINFO[0]**
  메이저 버전 번호(*release*).
- **BASH_VERSINFO[1]**
  마이너 버전 번호(*version*).
- **BASH_VERSINFO[2]**
  패치 레벨.
- **BASH_VERSINFO[3]**
  빌드 버전.
- **BASH_VERSINFO[4]**
  릴리스 정보(e.g., *beta1*).
- **BASH_VERSINFO[5]**
  `MACHTYPE`의 값.

**BASH_VERSION**
현재 Bash 인스턴스의 버전.

**BASH_XTRACEFD**
유효한 파일 디스크립터에 대응하는 정수를 설정하면, Bash는 'set -x'가 켜져있을 때 생성한 추적 정보를 파일 디스크립터에 출력합니다. 이를 통해 추적 정보를 진단 메시지, 에러 메시지와 분리할 수 있습니다. 파일 디스크립터는 `BASH_XTRACEFD`가 제거되거나 새 값이 대입되면 닫힙니다. `BASH_XTRACEFD`를 제거하거나 빈 문자열을 대입하면 추적 정보는 표준 에러 스트림으로 전송됩니다. `BASH_XTRACEFD`를 2(표준 에러 파일 디스크립터)를 설정하고 값을 제거하면 표준 에러 스트림을 닫으므로 주의하세요.

**CHILD_MAX**
셸이 기억할 종료된 자식 스테이터스 값의 개수를 지정합니다. Bash는 이 값이 POSIX 지정 최소값보다 작게 설정할 수 없으며 최대값(현재는 8192입니다)을 초과할 수 없습니다. 최소값은 시스템에 의존합니다.

**COLUMNS**
`select` 명령어에서 선택지를 출력할 때 터미널 너비를 결정하기 위해 쓰입니다. `checkwinsize` 옵션(The Shopt Builtin을 참조)이 켜져있거나 인터랙티브 셸에서 `SIGWINCH` 시그널을 수신할 때 자동으로 설정됩니다.

**COMP_CWORD**
`${COMP_WORDS}`에서 현재 커서 위치에 있는 단어의 인덱스값. 이 변수는 프로그래밍 가능한 완성 기능(Programmable Completion을 참조)에 의해 호출된 셸 함수에서만 사용 가능합니다.

**COMP_LINE**
현재 커맨드라인. 이 변수는 프로그래밍 가능한 완성 기능(Programmable Completion을 참조)에 의해 호출된 셸 함수와 외부 명령어에서만 사용 가능합니다.

**COMP_POINT**
현재 명령어의 첫머리로부터 현재 커서의 위치까지의 상대적인 인덱스. 만약 현재 커서 위치가 현재 명령어의 끝머리라면 이 변수의 값은 `${#COMP_LINE}`의 값과 동일합니다. 이 변수는 프로그래밍 가능한 완성 기능(Programmable Completion을 참조)에 의해 호출된 셸 함수와 외부 명령어에서만 사용 가능합니다.

**COMP_TYPE**
완성 함수를 호출한 완성의 종류에 대응하는 정수 값을 설정합니다. 일반 완성을 위한 *TAB*, 연속적인 탭 이후의 완성 리스트 출력을 위한 '?', 부분 단어 완성에서 대체 후보를 출력하는 '!', 단어가 수정되지 않았을 때 완성 출력하는 '@', 메뉴 완성을 위한 '%'. 이 변수는 프로그래밍 가능한 완성 기능(Programmable Completion을 참조)에 의해 호출된 셸 함수와 외부 명령어에서만 사용 가능합니다.

**COMP_KEY**
현재 완성 함수를 호출한 키(또는 키조합에서 마지막 키).

**COMP_WORDBREAKS**
Readline 라이브러리가 단어 완성을 실행할 때 단어 구분자로 취급하는 문자의 집합. 만약 `COMP_WORDBREAKS`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**COMP_WORDS**
현재 커맨드라인 상의 각각의 단어들로 구성된 배열 변수. 줄은 Readline이 위에서 설명한 `COMP_WORDBREAKS`를 사용하여 단어로 분리됩니다. 이 변수는 프로그래밍 가능한 완성 기능(Programmable Completion을 참조)에 의해 호출된 셸 함수에서만 사용 가능합니다.

**COMPREPLY**
프로그래밍 가능한 완성 기능(Programmable Completion을 참조)으로 호출된 셸 함수로 생성된 완성 후보를 Bash가 읽을 때 사용하는 배열 변수.

**COPROC**
이름 없는 코프로세스(Coprocesses를 참조)의 출력과 입력 파일 디스크립터를 보관하기 위해 생성되는 배열 변수.

**DIRSTACK**
디렉터리 스택의 현재 내용물을 가지고 있는 배열 변수. 스택에 있는 디렉터리는 `dirs` 빌트인 명령어에서 출력되는 순서대로 나타납니다. 이 배열 변수에 값을 대입하면 스택에 존재하는 디렉터리를 수정할 수 있지만, 디렉터리를 추가하거나 삭제할 때에는 반드시 `pushd`와 `popd` 빌트인을 사용해야합니다. 이 변수에 값을 대입하는 것으로는 현재 디렉터리를 변경할 수 없습니다. `DIRSTACK`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**EMACS**
셸이 시작했을 때 Bash가 환경에서 발견한 이 변수에 't'가 들어있다면, 셸이 Emacs 셸 버퍼에서 동작하고 있다고 인식하며, 줄 편집 기능을 비활성화합니다.

**ENV**
인터랙티브 셸이 POSIX 모드(Bash POSIX Mode를 참조)에서 호출되면 `BASH_ENV`와 유사한 방식으로 전개되고 실행됩니다.

**EPOCHREALTIME**
이 매개변수를 참조할 때마다 Unix Epoch(1970년 1월 1일 00:00 UTC)로부터 경과한 시간을 초 단위, 부동 소수점을 이용한 마이크로초 정밀도로 전개됩니다(Epoch의 정의는 C 라이브러리 함수 *time*의 문서를 참조하세요). `EPOCHREALTIME`에 대한 대입은 무시됩니다. `EPOCHREALTIME`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**EPOCHSECONDS**
이 매개변수를 참조할 때마다 Unix Epoch(1970년 1월 1일 00:00 UTC)로부터 경과한 시간을 초 단위로 전개합니다(Epoch의 정의는 C 라이브러리 함수 *time*의 문서를 참조하세요). `EPOCHSECONDS`에 대한 대입은 무시됩니다. `EPOCHSECONDS`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**EUID**
현재 유저의 유효한 유저 id(숫자). 이 값은 읽기 전용입니다.

**EXECIGNORE**
콜론으로 구분된 셸 패턴(Pattern Matching을 참조)의 리스트. `PATH`를 사용한 명령어 검색에서 무시해야할 파일명 리스트를 정의합니다. 파일의 전체 경로명이 이 패턴 리스트 중 하나와 일치하면 `PATH` 탐색을 통하면 완성이나 명령어 실행에서 사용 가능한 실행 파일이 아닌 것처럼 취급됩니다. 이는 `[`, `test`, `[[` 명령어의 동작에는 영향을 주지 않습니다. 명령어 해시 테이블에 있는 전체 경로는 `EXECIGNORE`의 영향을 받지 않습니다. 실행가능한 파일이 아닌 실행 가능한 비트 집합을 가지고 있는 공유 라이브러리 파일을 무시하기 위해서 이 변수를 사용하세요. 패턴 매칭은 `extglob` 셸 옵션의 값의 적용을 받습니다.

**FCEDIT**
`fc` 빌트인 명령어에 `-e` 옵션을 넘겼을 때 사용하는 에디터.

**FIGNORE**
파일명 완성 실행 시에 무시할 접미어 리스트. 콜론으로 구분합니다. `FIGNORE`에 있는 값과 일치하는 접미어를 가지는 파일명은 일치한 파일명 리스트에서 제외됩니다. 예를 들어 '.o:~' 처럼 쓸 수 있습니다.

**FUNCNAME**
현재 실행 콜 스택에 존재하는 모든 셸 함수의 이름을 가지고 있는 배열 변수. 0번째 인덱스의 요소는 현재 실행중인 셸 함수의 이름입니다. 가장 밑에 있는 요소(가장 큰 인덱스를 가지는 요소)는 "main"입니다. 이 변수는 셸 함수가 실행중인 동안만 존재합니다. `FUNCNAME`에 대입을 시도해도 아무 효과도 없습니다. `FUNCNAME`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

이 변수는 `BASH_LINENO`와 `BASH_SOURCE`와 함께 사용할 수 있습니다. `FUNCNAME`의 각 요소의 콜 스택에 대응하는 요소가 `BASH_LINENO`와 `BASH_SOURCE`에 있습니다. 예를 들어, 파일 `${BASH_SOURCE[$i+1]}`의 줄번호 `${BASH_LINENO[$i]}`에서 `${FUNCNAME[$i]}`를 호출합니다. `caller` 빌트인은 이 정보를 사용해서 현재 콜 스택을 출력합니다.

**FUNCNEST**
0보다 큰 숫자로 설정하면 함수의 최대 중첩 횟수를 정의합니다. 이 상한을 넘는 함수 호출은 명령어 전체를 중지시킵니다.

**GLOBIGNORE**
콜론으로 구분된 패턴 리스트이며, 파일명 전개에서 무시할 파일 이름의 집합을 정의합니다. 파일명 전개 패턴에서 일치한 파일 이름이 `GLOBIGNORE`에 있는 패턴과도 일치하면 일치 성공 리스트에서 제거됩니다. 패턴 매칭은 `extglob` 셸 옵션의 적용을 받습니다.

**GROUPS**
현재 유저가 멤버인 그룹 리스트를 포함하는 배열 변수. `GROUPS`에 대입을 시도해도 아무 효과도 없습니다. `GROUPS`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**histchars**
이력 전개, 빠른 치환, 토큰화(History Interaction을 참조)를 제어하기 위해 사용하는 문자를 최대 3개까지 정의합니다. 첫번째 문자는 *history expansion* 문자입니다. 이 문자는 이력 전개의 시작을 의미하며, 보통 '!'입니다. 두번째 문자는 줄의 첫번째 문자로 등장했을 때 '빠른 치환'의 시작을 의미하며 보통 '^'입니다. 지정이 임의인 세번째 문자는 단어의 첫번째로 왔을 때 해당 단어로부터 줄의 나머지를 코멘트임을 의미하며 보통 '#'입니다. 이력 코멘트 문자가 있다면 줄의 나머지 단어에서 이력 치환을 생략합니다. 단, 셸의 파서도 해당 나머지 부분을 코멘트로 취급할 지는 보장하지 않습니다.

**HISTCMD**
현재 명령어의 이력 번호, 또는 이력 리스트에서의 인덱스. `HISTCMD`에 대입을 시도해도 아무 효과도 없습니다. `HISTCMD`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**HISTCONTROL**
명령어가 어떻게 이력 리스트에 저장될 지를 제어하는 값들이 콜론으로 구분된 리스트. 이 리스트에 '`ignorespace`'가 포함되어 있다면, 스페이스 문자로 시작하는 줄은 이력 리스트에 저장되지 않습니다. '`ignoredups`'는 저장된 이력과 일치하는 줄은 저장하지 않습니다. '`ignoreboth`'는 '`ignorespace`'와 '`ignoredups`'를 둘 다 지정하는 짧은 표현입니다. '`erasedups`'는 현재 줄을 저장하기 전에 이 줄과 일치하는 과거 이력을 리스트로부터 제거합니다. 여기에서 설명한 값 이외의 값은 무시됩니다. 만약 `HISTCONTROL`이 설정되지 않았거나 올바른 값을 포함하지 않는다면 셸 파서가 읽은 모든 줄은 이력 리스트에 저장되며 `HISTIGNORE`의 적용을 받습니다. 여러 줄로 구성된 복합 명령어의 두번째 줄부터 이후는 검사하지 않으며 `HISTCONTROL`의 값에 관계없이 이력에 추가됩니다.

**HISTFILE**
명령어 이력이 저장되어 있는 파일의 이름. 기본값은 `~/.bash_history`입니다.

**HISTFILESIZE**
이력 파일이 관리하는 줄의 최대 개수. 이 변수에 값을 대입했을 때 이력 파일이 가지고 있는 줄 개수가 설정한 값보다 더 많다면 오래된 줄부터 넘친 만큼 제거합니다. 이력 파일은 셸이 종료할 때도 이 개수보다 많으면 오래된 줄을 제거합니다. 값이 0이라면 이력 파일의 크기는 0이 됩니다. 숫자가 아닌 값과 0보다 작은 값은 제거가 발생하지 않습니다. 셸은 기동 파일을 읽고 난 뒤, 기본값으로 `HISTSIZE`의 값을 설정합니다.

**HISTIGNORE**
커맨드 라인이 이력 리스트에 저장될지 결정하는 패턴 리스트. 콜론으로 구분됩니다. 각 패턴은 줄의 시작 부분부터 일치시키며, 줄 전체와 일치해야합니다(암묵적으로 뒷 부분에 '*'를 추가하지 않습니다). 각 패턴의 검사는 `HISTCONTROL`의 검사가 끝난 이후에 실행됩니다. 그리고 일반 셸 패턴 매칭 문자인 '&'는 이전의 이력 줄에 일치합니다. '&'는 백슬래시를 사용하여 이스케이프할 수 있습니다. 백슬래시는 일치 검사를 시도할 때 제거됩니다. 여러 줄로 구성된 복합 명령어의 두번째 줄부터 이후는 검사하지 않으며 `HISTIGNORE`의 값에 관계 없이 이력에 추가됩니다. 패턴 매칭은 `extglob` 셸 옵션의 적용을 받습니다.

`HISTIGNORE`는 `HISTCONTROL`의 기능을 포함합니다. '&' 패턴은 `ignoredups`와 동일하며, `[ ]*` 패턴은 `ignorespace`와 동일합니다. 두 패턴을 결합하여 콜론으로 구분하면 `ignoreboth`를 제공할 수 있습니다.

**HISTSIZE**
이력 리스트에 기억할 명령어의 최대 개수. 값이 0이면, 명령어는 이력 리스트에 저장되지 않습니다. 0보다 작은 숫자는 모든 명령어를 이력 리스트에 저장합니다(제한은 없습니다). 셸은 기동 파일을 읽은 후, 기본값으로 500을 지정합니다.

**HISTTIMEFORMAT**
이 변수가 설정되어 있고 널이 아니라면, 이 값은 `history` 빌트인이 각 이력과 연관된 타임스탬프를 출력할 때 사용하는 *strftime*의 형식 문자열로 사용됩니다. 이 변수가 설정되어 있다면 타임스탬프가 이력 파일에 추가되므로, 다른 셸 세션을 사용하더라도 값이 유지됩니다. 이는 이력 코멘트 문자를 사용하여 다른 이력 줄과 구분됩니다.

**HOSTFILE**
셸이 호스트명을 완성을 위해 필요로 할 때 읽는 `/etc/hosts`와 동일한 형식의 파일의 이름을 저장합니다. 가능한 호스트명 완성의 리스트는 셸이 실행되는 도중에 변경될 수 있습니다. 다음 호스트명 완성은 값이 변경된 이후에 시도되며, Bash는 새 파일의 내용물을 존재하고 있는 리스트에 추가합니다. `HOSTFILE`을 설정했지만 값이 없거나 읽을 수 없는 파일을 지정했다면 Bash는 `/etc/hosts`를 읽어서 호스트명 완성에 필요한 리스트를 얻습니다. `HOSTFILE`을 제거하면 호스트명 리스트가 지워집니다.

**HOSTNAME**
현재 호스트의 이름.

**HOSTTYPE**
Bash를 실행 중인 기계를 설명하는 문자열.

**IGNOREEOF**
유일한 입력으로 `EOF` 문자를 받았을 때의 셸의 동작을 제어합니다. 설정했다면 셸이 종료하기 전에 입력 줄의 첫번째 문자로 읽을 수 있는 연속된 EOF 문자의 숫자를 의미합니다. 변수가 존재하지만 숫자가 아니거나, 또는 값이 없는 경우 기본값은 10입니다. 변수가 존재하지 않는다면 EOF는 셸의 입력을 종료합니다. 이는 인터랙티브 셸에서만 유효합니다.

**INPUTRC**
Readline 초기화 파일의 이름. 기본값인 `~/.inputrc`를 덮어씁니다.

**INSIDE_EMACS**
Bash가 셸을 시작할 때 환경에서 이 변수를 발견했다면 셸이 Emacs 셸 버퍼에서 동작중이라고 인식하고 `TERM`의 값에 의존하여 줄 편집 기능을 비활성화합니다.

**LANG**
`LC_`로 시작하는 변수가 선택되지 않았을 경우, 로케일 분류를 결정하기 위해서 사용됩니다.

**LC_ALL**
이 변수는 로케일 분류를 지정하는 `LANG`과 다른 `LC_` 변수를 덮어씁니다.

**LC_COLLATE**
이 변수는 파일명 전개의 결과를 정렬할 때, 범위 표현식, 동치 클래스, 파일명 전개와 패턴 매칭 중의 나열 순서의 동작을 결정할 때, 사용될 콜레이션 순서를 결정합니다(Filename Expansion을 참조).

**LC_CTYPE**
이 변수는 파일명 전개와 패턴 매칭중의 문자의 해석과 문자 클래스의 행동을 결정합니다(Filename Expansion을 참조).

**LC_MESSAGES**
이 변수는 '$'로 시작하는 큰따옴표로 감싼 문자열을 번역할 때 사용할 로케일을 결정합니다(Locale-Specific Translation을 참조).

**LC_NUMERIC**
이 변수는 숫자 포매팅에 사용할 로케일 분류를 결정합니다.

**LC_TIME**
이 변수는 날짜와 시각 포매팅에 사용할 로케일 분류를 결정합니다.

**LINENO**
현재 실행중인 스크립트나 셸 함수의 줄 번호. 만약 `LINENO`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**LINES**
`select` 명령어에서 선택지를 출력할 때 컬럼의 길이를 결정하기 위해서 사용합니다. `checkwinsize` 옵션(The Shopt Builtin을 참조)이 켜져있거나 인터랙티브 셸이 `SIGWINCH` 시그널을 수신했을 때 자동으로 설정됩니다.

**MACHTYPE**
Bash를 실행하고 있는 시스템 타입을 표준 GNU *cpu-company-system* 형식으로 완전히 기술하는 문자열.

**MAILCHECK**
셸이 메일이 왔는지 확인하기 위해서 `MAILPATH`나 `MAIL` 변수에 지정한 파일을 얼마나 자주(초 단위) 검사할 지 설정합니다. 기본값은 60초입니다. 메일을 확인할 시각이 되면 주 프롬프트를 출력하기 전에 작업을 수행합니다. 이 변수를 제거하거나 0이상의 숫자가 아니라면 셸은 메일 확인을 하지 않습니다.

**MAPFILE**
`mapfile` 빌트인에 변수 이름을 넘기지 않고 실행해서 읽어들인 텍스트를 보관하기 위해 생성되는 배열 변수.

**OLDPWD**
`cd` 빌트인이 설정하는 이전 작업 디렉터리.

**OPTERR**
값을 1로 설정하면 Bash는 `getopts` 빌트인 명령어가 생성한 에러 메시지를 출력합니다.

**OSTYPE**
Bash가 실행중인 운영체제 이름 문자열.

**PIPESTATUS**
가장 최근에 실행된 포어그라운드의 파이프라인(하나의 단순 명령어만 포함할 수도 있습니다)의 프로세스의 종료 스테이터스 리스트를 저장한 배열 변수(Arrays를 참조).

**POSIXLY_CORRECT**
Bash가 시작할 때 이 변수가 환경에 있으면 셸이 `--posix` 옵션을 넘긴 것처럼 기동 파일을 읽기 전에 POSIX 모드(Bash POSIX Mode를 참조)에 돌입합니다. 셸이 실행중에 설정되면 Bash는 다음 명령어를 실행한 것과 동일하게 POSIX 모드를 켭니다.

```sh
set -o posix
```

셸이 POSIX 모드를 켰을 때, 이 변수가 없었다면 설정합니다.

**PPID**
셸의 부모 프로세스의 프로세스 ID. 이 변수는 읽기 전용입니다.

**PROMPT_COMMAND**
이 변수에 배열을 설정했다면 각 요소의 값은 주 프롬프트(`$PS1`)를 출력하기 전에 실행할 명령어로 해석됩니다. 만약 설정한 것이 배열 변수가 아니라면, 그 값을 실행할 명령어로 사용합니다.

**PROMPT_DIRTRIM**
0보다 큰 숫자를 설정하면, `\w`와 `\W` 프롬프트 문자열 이스케이프(Controlling the Prompt를 참조)를 전개할 때 뒤따라오는 디렉터리 컴포넌트의 갯수를 유지하기 위해서 사용됩니다. 제거된 문자는 생략 기호로 대체됩니다.

**PS0**
이 매개변수의 값은 `PS1`처럼 전개되며 명령어를 읽은 후, 명령어를 실행하기 전에 인터랙티브 셸에 의해 출력됩니다.

**PS3**
이 변수의 값은 `select` 명령어의 프롬프트로 사용됩니다. 이 변수가 설정되지 않았다면 `select` 명령어의 프롬프트는 '#? '입니다.

**PS4**
이 매개변수의 값은 `PS1`처럼 전개되며 전개된 값은 커맨드라인이 `-x` 옵션(The Set Builtin을 참조)이 켜져있을 때 명령어를 재출력하기 전에 프롬프트로서 출력됩니다. 전개된 값의 첫번째 문자는 인다이렉션 정보를 표시하기 위해서 인다이렉션의 횟수만큼 복제됩니다. 기본값은 '+ '입니다.

**PWD**
`cd` 빌트인으로 설정한 현재 작업 디렉터리.

**RANDOM**
이 매개변수가 참조될 때마다 0과 32767 사이의 임의의 정수로 전개됩니다. 이 변수에 값을 대입하면 해당 값으로 임의 숫자 생성기의 시드값을 변경합니다. `RANDOM`을 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**READLINE_LINE**
Readline 줄 버퍼의 내용. `bind -x`에서 사용합니다(Bash Builtins를 참조).

**READLINE_MARK**
Readline 줄 버퍼의 표식(저장된 삽입 위치)의 위치. `bind -x`에서 사용합니다(Bash Builtins를 참조). 삽입 위치와 표식 사이의 문자를 `region`이라고 부르기도 합니다.

**READLINE_POINT**
Readline 줄 버퍼의 삽입 위치. `bind -x`에서 사용합니다(Bash Builtins를 참조).

**REPLY**
`read` 빌트인의 기본 변수.

**SECONDS**
이 변수는 셸이 시작된 이후로 지난 시간을 초로 전개합니다. 이 변수에 대입하면 원래의 값을 초기화하며 전개된 값은 대입한 값에 대입한 이후로 지난 시간을 초로 더한 값이 됩니다. 셸 호출시에 초와 현재 시간은 언제나 시스템 시각에 질의하고 결정됩니다. `SECONDS`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**SHELL**
이 환경 변수는 셸의 전체 경로로 전개됩니다. 셸이 시작했을 때 설정되어 있지 않다면 Bash는 현재 유저의 로그인 셸의 전체 경로를 대입합니다.

**SHELLOPTS**
콜론으로 구분된 켜져있는 셸 옵션의 리스트. 리스트의 각 단어는 `set` 빌트인 명령어(The Set Builtin을 참조)의 `-o` 옵션에 넘길 수 있는 유효한 인수입니다. `SHELLOPTS`에 있는 옵션들은 '`set -o`' 실행 결과에서 '`on`'으로 보고됩니다. Bash가 시작할 때 환경에 이 변수가 있다면 기동 파일을 읽기 전에 리스트에 있는 각 셸 옵션을 켭니다. 이 변수는 읽기 전용입니다.

**SHLVL**
Bash의 새 인스턴스가 시작될 때마다 1씩 증가합니다. 이는 Bash 셸이 얼마나 깊게 중첩되었는지를 세기 위한 변수입니다.

**SRANDOM**
이 변수는 참조될 때마다 32비트 의사 난수로 전개됩니다. `/dev/urandom`이나 `arc4random`을 지원하는 시스템에서는 난수 생성기가 선형이 아니므로 반환하는 각 숫자는 직전에 반환한 숫자와 아무런 관계가 없습니다. 난수 생성기의 시드값은 변경할 수 없으므로, 이 변수에 값을 대입하는 것은 아무런 효과도 없습니다. `SRANDOM`를 제거하면 이 변수의 특수한 속성이 제거되며, 다시 설정하더라도 이 상태는 유지됩니다.

**TIMEFORMAT**
이 매개변수의 값은 `time` 예약어로 시작하는 파이프라인의 타이밍 정보를 어떻게 출력할지 지정하는 포맷 문자열로 사용됩니다. '%' 문자는 시간 값이나 다른 정보로 전개되는 이스케이프 문자로 사용됩니다. 이스케이프 나열과 그 의미는 다음과 같습니다. 대괄호로 감싼 값은 옵션입니다.

- **%%**
  '%' 문자.
- **%\[*p*]\[*l*]R**
  경과한 시간(초).
- **%\[*p*]\[*l*]U**
  유저 모드에서 사용한 CPU시간(초).
- **%\[*p*]\[*l*]S**
  시스템 모드에서 사용한 CPU시간(초).
- **%P**
  CPU 퍼센트. (%U + %S) / %R로 계산.

옵션 *p*는 정밀도를 나타내는 숫자로, 소수점 이하의 숫자의 개수를 지정합니다. 0은 정수를 출력합니다.  소수점 이하의 숫자 개수는 최대 3개까지 가능하며, 3보다 큰 *p* 값은 2으로 변경됩니다. *p*가 지정되지 않을 경우의 값은 3입니다.

옵션 *l*은 분을 포함하는 *MMmSS.FFs*라는 긴 포맷을 사용하도록 지정합니다. *p* 값은 소수점 이하를 포함할지 아닐지 결정합니다.

이 변수가 설정되어있지 않다면 Bash는 다음 값을 가진 것처럼 동작합니다.

```
$'\nreal\t%3lR\nuser\t%3lU\nsys\t%3lS'
```
값이 널이라면 타이밍 정보는 출력되지 않습니다. 포맷 문자열을 출력할 때 맨 뒤에 개행이 추가됩니다.

**TMOUT**
0보다 큰 값을 설정하면 `TMOUT`은 `read` 빌트인(Bash Builtins을 참조)의 기본 타임아웃 값이 됩니다. `select` 명령어(Conditional Constructs를 참조)는 터미널로부터 입력을 받을 때 입력이 `TMOUT`초 안에 도착하지 않을 경우 종료합니다.

인터랙티브 셸에서 이 변수의 값은 주 프롬프트가 입력줄을 요구했을 때 기다리는 초입니다. 지정된 초만큼 기다린 뒤, Bash는 입력의 전체 줄이 도착하지 않았다면 종료합니다.

**TMPDIR**
설정했다면, Bash는 이 값을 셸의 내부적으로 생성하는 임시 파일을 둘 디렉터리의 이름으로 사용합니다.

**UID**
현재 유저의 실제 유저 id(숫자). 이 변수는 읽기 전용입니다.

# 6. Bash Features
이 장에서는 Bash만 가지고 있는 기능에 대해서 설명합니다.

- Invoking Bash : Bash에 넘길 수 있는 커맨드 라인 옵션.
- Bash Startup Files : Bash가 스크립트를 실행하는 때와 방법.
- Interactive Shells : 인터랙티브 셸이란 무엇인가.
- Bash Conditional Expressions : `test` 빌트인에서 표현식을 구성할 때 사용하는 프리미티브에 대해.
- Shell Arithmetic : 셸 변수에서의 산수.
- Aliases : 한 명령어를 다른 명령어로 치환하기.
- Arrays : 배열 변수.
- The Directory Stack : 방문한 디렉터리의 이력.
- Controlling the Prompt : 다양한 프롬프트 문자열을 커스터마이즈하기.
- The Restricted Shell : 셸 실행의 모드를 세밀하게 제어하기.
- Bash POSIX Mode : Bash가 POSIX 표준에 가깝게 동작하도록 만들기.
- Shell Compatibility Mode : Bash가 이전 버전에 존재했고, 변경된 동작을 지원하는 방법.
## 6.1 Invoking Bash
```sh
bash [long-opt] [-ir] [-abefhkmnptuvxdBCDHP] [-o option]
    [-O shopt_option] [argument …]
bash [long-opt] [-abefhkmnptuvxdBCDHP] [-o option]
    [-O shopt_option] -c string [argument …]
bash [long-opt] -s [-abefhkmnptuvxdBCDHP] [-o option]
    [-O shopt_option] [argument …]
```

`set` 빌트인(The Set Builtin을 참조)에서 사용할 수 있는 모든 단일 문자 옵션을 셸을 호출할 때 사용할 수 있습니다. 추가로 여러 문자로 된 몇몇의 옵션도 사용할 수 있습니다. 이 옵션은 단일 문자 옵션보다 먼저 지정해야 합니다.

**--debugger**
셸을 실행하기 전에 디버거 프로파일을 실행하도록 준비합니다. 확장된 디버깅 모드를 켭니다(`shopt` 빌트인의 `extdebug` 옵션의 설명에 대해서는 The Shopt Builtin을 참조).

**--dump-po-strings**
'`$`'로 시작하는 모든 큰따옴표 문자열의 리스트를 표준 출력에 GNU `gettext` PO(portable object) 파일 형식으로 출력합니다. 출력 형식을 제외하면 `-D`와 동일합니다.

**--dump-strings**
`-D`와 동일합니다.

**--help**
표준 출력에 사용법을 출력하고 성공적으로 종료합니다.

**--init-file filename**
**--rcfile filename**
인터랙티브 셸에서 (`~/.bashrc` 대신)*filename*로부터 명령어를 실행합니다.

**--login**
`-l`과 동일합니다.

**--noediting**
인터랙티브 모드에서 동작 중에 커맨드라인을 읽어들일 때 GNU Readline library(Command Line Editing을 참조)를 사용하지 않습니다.

**--noprofile**
Bash가 로그인 셸로 호출될 때, 시스템 전체의 기동 파일인 `/etc/profile`이나 다른 개인용 초기화 파일인 `~/.bash_profile`, `~/.bash_login`, `~/.profile`을 로드하지 않습니다.

**--norc**
인터랙티브 셸에서 `~/.bashrc` 초기화 파일을 읽지 않습니다. 이 옵션의 기본값은 셸이 `sh`로 호출될 때에만 켜짐입니다.

**--posix**
POSIX 표준과 다른 Bash의 기본 동작을 표준에 일치하도록 변경합니다. 이는 Bash가 표준의 엄격한 슈퍼셋으로 동작하도록 만드는 것이 목적입니다. Bash의 POSIX 모드에 대한 설명은 Bash POSIX Mode를 참조하세요.

**--restricted**
셸을 한정 모드로 만듭니다(The Restricted Shell을 참조).

**--verbose**
`-v`와 동일합니다. 읽어들인 입력 줄을 출력합니다.

**--version**
Bash 인스턴스의 버전 정보를 표준 출력에 출력하고 성공적으로 종료합니다.

`set` 빌트인에서는 사용할 수 없지만 실행시에 넘길 수 있는 단일 문자 옵션이 몇 개 존재합니다.

**-c**
옵션이 아닌 첫번째 인수 *command_string*을 읽고 실행한 뒤 종료합니다. 만약 *command_string* 뒤에 인수가 존재한다면 첫번째 인수는 `$0`에 대입되고, 나머지 인수들은 위치 매개변수에 대입됩니다. `$0`에 대입된 값은 셸의 이름을 설정하며, 이는 경고, 에러 메시지에 사용됩니다.

**-i**
셸을 인터랙티브 모드에서 실행합니다. 인터랙티브 셸에 대한 설명은 Interactive Shells를 참조하세요.

**-l**
셸이 로그인에 의해 직접 호출된 것처럼 동작하게 만듭니다. 셸이 인터랙티브 모드라면 이는 '`exec -l bash`'로 로그인 셸을 시작하는 것과 동일합니다. 만약 셸이 인터랙티브 모드가 아니라면 로그인 셸의 기동 파일이 실행됩니다. '`exec bash -l`'이나 '`exec bash --login`'은 현재 셸을 Bash 로그인 셸로 대체합니다. 로그인 셸의 특수한 동작에 대한 설명은 Bash Startup Files를 참조하세요.

**-r**
셸을 한정 모드로 만듭니다(The Restricted Shell을 참조).

**-s**
이 옵션이 있거나 옵션 처리를 진행했지만 아무 옵션이 없었다면 표준 입력으로부터 명령어를 읽어옵니다. 이 옵션은 인터랙티브 셸을 호출할 때, 파이프를 통해 입력을 읽어올 때 위치 매개변수를 설정할 수 있습니다.

**-D**
'`$`'로 시작하는 모든 큰따옴표 문자열의 리스트를 표준 출력에 출력합니다. 이 문자열들은 현재 로케일이 `C`나 `POSIX`가 아니라면 번역의 적용을 받습니다(Local Translation을 참조). 이는 `-n` 옵션을 포함합니다. 그러므로 어떤 명령어도 실행되지 않습니다.

**[-+]O [*shopt_option*]**
*shopt_option*은 `shopt` 빌트인(The Shopt Builtin을 참조)이 받을 수 있는 셸 옵션 중 하나입니다. 만약 *shopt_option*이 있다면, `-O`는 해당 옵션의 값을 설정하고, `+O`는 값을 제거합니다. *shopt_option*을 넘기지 않았다면 `shopt`가 받을 수 있는 셸 옵션의 이름과 값 리스트가 표준 출력에 출력됩니다. 호출 옵션이 `+O`라면 결과는 입력으로 재활용 가능한 형식으로 출력됩니다.
**--**
`--`은 옵션의 끝을 나타내며 이후의 옵션 처리를 멈추도록 합니다. `--` 이후의 인수는 파일명과 일반 인수로 취급됩니다.

*로그인* 셸은 0번째 인수의 첫번째 문자가 '-'이거나, `--login` 옵션으로 호출합니다.

*인터랙티브*셸은 옵션 없이 호출하거나, `-s`, `-c` 옵션 없이 호출하고 입력과 출력이 모두 터미널에 연결되어 있거나(`isatty(3)`으로 판단) `-i` 옵션으로 호출합니다. 추가 설명은 Interactive Shells를 참조하세요.

옵션 처리 이후에도 인수가 남아있고 `-c`와 `-s` 옵션을 사용하지 않았다면 첫번째 인수는 셸 명령어를 포함하고 있는 파일(Shell Scripts를 참조)이라고 인식합니다. Bash는 이런 방식으로 호출할 때 `$0`을 파일 명으로 설정하고, 나머지 인수를 위치 매개변수로 설정합니다. Bash는 이 파일로부터 명령어를 읽고 실행한 뒤 종료합니다. Bash의 종료 스테이터느는 스크립트에서 마지막으로 실행된 명령어의 종료 스테이터스입니다. 만약 실행된 명령어가 없다면 종료 스테이터스는 0입니다.
## 6.2 Bash Startup Files
이 섹션에서는 Bash가 자신의 기동 파일을 어떻게 실행하는지 설명합니다. 파일이 존재하지만 읽을 수 없는 경우, Bash는 에러를 보고합니다. 파일명에 포함된 물결줄표는 물결줄표 전개에서 설명한 대로 전개됩니다(Tilde Expansion을 참조).

인터랙티브 셸에 대해서는 Interactive Shells를 참조하세요.

**Invoked as an interactive login shell, or with --login**
Bash를 인터랙티브 로그인 셸, 또는 `--login` 옵션과 함께 논-인터랙티브 셸로 실행할 때, Bash는 `/etc/profile`이 존재한다면 이 파일을 읽고 명령어를 실행합니다. 이 파일을 읽은 뒤, `~/.bash_profile`, `~/.bash_login`, `~/.profile`을 순서대로 찾은 뒤, 첫번째로 읽을 수 있는 파일을 발견하면 그것을 읽고 명령어를 실행합니다. `--noprofile` 옵션으로 셸이 시작할 때 이 동작을 하지 못하도록 만들 수 있습니다.

인터랙티브 로그인 셸이 종료할 때, 또는 논-인터랙티브 로그인 셸이 `exit` 빌트인 명령어를 실행할 때, Bash는 `~/.bash_logout` 파일이 존재하면 이 파일을 읽고 명령어를 실행합니다.

**Invoked as an interactive non-login shell**
인터랙티브 셸이 로그인 셸로 실행되지 않을 때, Bash는 `~/.bashrc`가 존재한다면 이 파일을 읽고 명령어를 실행합니다. 이 동작은 `--norc` 옵션을 사용해 금지할 수 있습니다. `--rcfile file` 옵션은 Bash에게 `~/.bashrc` 대신에 *file*을 읽고 명령어를 실행하도록 강제할 수 있습니다.

그러므로 보통 `~/.bash_profile`은 로그인 시에만 필요한 초기화 후(또는 전)에 다음의 줄을 포함합니다.

```sh
if [ -f ~/.bashrc ]; then . ~/.bashrc; fi
```

**Invoked non-interactively**
예를 들어, 셸 스크립트를 실행하기 위해 Bash를 논-인터랙티브 모드로 시작할 때, Bash는 환경에서 `BASH_ENV` 변수를 찾고, 존재한다면 해당 변수의 값을 전개하여 얻은 파일 이름을 읽고 실행합니다. Bash는 다음 명령어가 실행된 것처럼 행동합니다.

```sh
if [ -n "$BASH_ENV" ]; then . "$BASH_ENV"; fi
```

단, 파일명을 검색할 때 `PATH` 변수의 값은 사용되지 않습니다.

위에서 언급한 것처럼, 논-인터랙티브 셸이 `--login` 옵션과 함께 호출될 때, Bash는 로그인 셸 기동 파일로부터 읽은 명령어를 실행합니다.

**Invoked with name sh**
Bash를 `sh`라는 이름으로 호출하면 POSIX 표준을 준거하며 가능한 `sh`의 과거 버전의 기동 동작을 따라하려 합니다.

인터랙티브 로그인 셸로 실행될 때, 또는 `--login` 옵션으로 논-인터랙티브 셸로 실행될 때 `/etc/profile`과 `~/.profile`을 순서대로 읽으려고 시도하고, 있다면 명령어를 실행합니다. `--noprofile` 옵션으로 이 동작을 금지할 수 있습니다. 인터랙티브 셸을 `sh`라는 이름으로 실행할 때, Bash는 환경에서 `ENV` 변수를 찾고 만약 있다면 이 변수의 값을 전개해 얻은 값을 파일명으로 하는 파일을 읽고 실행합니다. `sh`로 실행된 셸은 다른 기동 파일로부터 명령어를 읽고 실행하려 시도하지 않으므로, `--rcfile` 옵션은 의미가 없습니다. `sh`라는 이름으로 실행한 논-인터랙티브 셸은 기동 파일을 읽지 않습니다.

`sh`로 실행할 때 Bash는 기동 파일을 읽고난 후 POSIX 모드로 동작합니다.

**Invoked in POSIX mode**
Bash를 `--posix` 커맨드 라인 옵션을 사용해서 POSIX 모드로 실행하면 POSIX 표준대로 기동 파일을 읽습니다. 이 모드에서는 인터랙티브 셸은 `ENV` 변수를 전개하여 얻은 값을 파일명으로 하는 파일로부터 명령어를 읽고 실행합니다. 다른 기동 파일은 읽히지 않습니다.

**Invoked by remote shell daemon**
Bash는 리모트 셸 데몬(일반적으로는 `rshd`)나 보안 셸 데몬 `sshd`로 실행되었을 때, 표준입력이 네트워크에 접속된 상태로 실행중인지 아닌지 판단하려 합니다. Bash가 만약 이 방식대로 실행중이라고 판단하고 `~/.bashrc`를 읽을 수 있다면 이 파일로부터 명령어를 읽고 실행합니다. 만약 `sh`로서 호출되었다면 이 동작은 실행되지 않습니다. `--norc` 옵션은 이 동작을 금지할 수 있으며, `--rcfile` 옵션은 다른 파일을 읽도록 강제할 수 있습니다만, `rshd`나 `sshd`는 일반적으로 이러한 옵션을 지정해서 셸을 실행할 수 없습니다.

**Invoked with unequal effective and real UID/GIDs**
Bash가 실제 유저(그룹) id와 다른 유효한 유저(그룹) id로 실행되고, `-p` 옵션을 넘기지 않았다면 기동 파일을 읽지 않으며 셸 함수는 환경으로부터 상속되지 않습니다. `SHELLOPTS`, `BASHOPTS`, `CDPATH`, `GLOBIGNORE` 변수가 환경에 있었다면 무시하며 유효한 유저 id에 실제 유저 id를 설정합니다. 만약 호출시에 `-p` 옵션을 넘겼다면 기동 동작은 동일하지만 유효한 유저 id를 초기화하지 않습니다.

## 6.3 Interactive Shells
- What is an Interactive Shell? : 인터랙티브 모드에 대해서.
- Is this Shell Interactive? : 셸이 인터랙티브 모드인지 아닌지 확인하는 법.
- Interactive Shell Behavior : 인터랙티브 셸의 차이점.
### 6.3.1 What is an Interactive Shell?
인터랙티브 셸은 옵션 없이 실행하거나, `-s`와 `-c` 옵션을 지정하지 않고 실행하고 입력과 에러 출력이 모두 터미널과 연결되어 있거나(`isatty(3)`으로 판단) `-i` 옵션으로 실행한 셸입니다.

인터랙티브 셸은 일반적으로 유저의 터미널로부터 입력을 받고, 유저의 터미널에 출력합니다.

인터랙티브 셸을 실행할 때 `-s` 옵션을 사용하면 위치 매개변수를 설정할 수 있습니다.

### 6.3.2 Is this Shell Interactive?
기동 스크립트에서 Bash가 인터랙티브 모드에서 실행중인지 아닌지 판단하고 싶을 때에는 '`-`' 특수 매개변수의 값을 검사하세요. 셸이 인터랙티브 모드라면 이 값은 `i`를 포함합니다. 다음은 예시입니다.

```sh
case "$-" in
*i*)	echo This shell is interactive ;;
*)	echo This shell is not interactive ;;
esac
```

또는 이 대신에 기동 스크립트는 `PS1` 변수를 검사할 수 있습니다. 이 변수는 논-인터랙티브 셸이라면 설정되지 않으며, 인터랙티브 셸일 때에 설정됩니다. 그러므로 다음처럼 사용할 수 있습니다.

```sh
if [ -z "$PS1" ]; then
        echo This shell is not interactive
else
        echo This shell is interactive
fi
```

### 6.3.3 Interactive Shell Behavior
셸이 인터랙티브 모드에서 동작할 때, 이는 여러 Bash의 동작을 변경합니다.

1. Bash Startup Files에서 설명한대로 기동 파일을 읽고 실행합니다.
2. 잡 컨트롤(Job Control을 참조)은 기본으로 켜져 있습니다. 잡 컨트롤이 적용 중일 때, Bash는 키보드가 생성하는 잡 컨트롤 시그널인 `SIGTTIN`, `SIGTTOU`, `SIGTSTP`를 무시합니다.
3. Bash는 명령어의 첫 줄을 읽기 전에 `PS1`를 전개하고 출력하며, 여러 줄로 구성된 명령어의 두번째 줄부터를 읽기 전에 `PS2`를 전개하고 출력합니다. Bash는 명령어를 읽은 후, 실행하기 전에 `PS0`을 전개하고 출력합니다. 프롬프트 문자열 이스케이프 나열의 완전한 리스트는 Controlling the Prompt를 참조하세요.
4. Bash는 `PROMPT_COMMAND` 배열 변수의 요소에 들어있는 명령어를 주 프롬프트인 `$PS1`을 출력하기 전에 실행합니다(Bash Variables를 참조).
5. 유저 터미널의 명령어를 읽기 위해 Readline(Command Line Editing을 참조)을 사용합니다.
6. Bash는 명령어를 읽을 때 `EOF`를 받았을 때 즉시 종료하는 대신 `set -o`의 옵션의 `ignoreeof`를 검사합니다(The Set Builtin을 참조).
7. 명령어 이력(Bash History Facilities를 참조)와 이력 전개(History Interaction을 참조)는 기본 설정으로 활성화되어 있습니다. Bash는 이력 기능이 활성화 되어 있는 상태에서 셸을 종료하면 명령어 이력을 `$HISTFILE`에 의해 지정된 파일에 저장합니다.
8. 별칭 전개(Aliases를 참조)는 기본 설정으로 활성화되어 있습니다.
9. 트랩이 설정되어 있지 않다면 Bash는 `SIGTERM`을 무시합니다(Signals를 참조).
10. 트랩이 설정되어 있지 않다면, `SIGINT`는 붙잡히고 처리됩니다(Signals를 참조). `SIGINT`는 몇몇 셸 빌트인의 처리에 끼어듭니다.
11. 인터랙티브 로그인 셸은 `huponexit` 셸 옵션이 켜져 있다면(Signals를 참조) 모든 잡에게 `SIGHUP`을 전송합니다.
12. `-n` 호출 옵션은 무시되며, '`set -n`'은 의미가 없습니다(The Set Builtin을 참조)
13. Bash는 `MAIL`, `MAILPATH`와 `MAILCHECK` 셸 변수값에 의존하여 메일을 주기적으로 확인합니다(Bash Variables를 참조).
14. '`set -u`'가 켜진 이후에 설정되지 않은 변수에 대한 참조로 인한 전개 에러는 셸을 종료시키지 않습니다(The Set Builtin을 참조).
15. 제거되거나 `${var:?word}`로 널이 설정된 *var*로 인한 전개 에러는 셸을 종료시키지 않습니다(Shell Parameter Expansion을 참조).
16. 셸 빌트인에서 발생한 리다이렉션 에러는 셸을 종료시키지 않습니다.
17. POSIX 모드에서 에러 스테이터스를 반환하는 특수 빌트인은 셸을 종료시키지 않습니다(Bash POSIX Mode를 참조).
18. 실패한 `exec`는 셸을 종료시키지 않습니다(Bourne Shell Builtins를 참조).
19. 문법 해석 에러는 셸을 종료시키지 않습니다.
20. `cd` 빌트인의 디렉터리 인수에 대한 간단한 철자 교정 기능은 기본 설정에서 켜져 있습니다(The Shopt Builtin의 `shopt` 빌트인의 `cdspell` 옵션의 설명을 참조).
21. 셸은 `$PS1`을 출력한 뒤, 특정 시간(초) 동안 입력이 없을 때에 `TMOUT` 변수의 값을 검사하고 종료합니다(Bash Variables를 참조).

## 6.4 Bash Conditional Expressions
조건 표현식은 `[[` 복합 명령어와 `test`, `[` 빌트인 명령어에서 사용됩니다. `test`와 `[` 명령어는 인수의 개수에 따라 동작을 결정합니다. 각 명령어에 대한 설명은 해당 명령어의 설명을 참조하세요.

표현식은 단항이나 이항일 수 있으며, 다음의 옵션-값 쌍으로 구성됩니다. 단항 표현식은 파일의 상태를 검사하기 위해서 사용됩니다. 문자열 연산자와 숫자 비교 연산자도 있습니다. Bash는 몇몇 파일명이 표현식에서 사용되면 특별하게 다룹니다. Bash가 실행중인 운영체제가 이 특별한 파일들을 제공한다면 Bash는 해당 파일을 사용합니다. 그렇지 않다면 다음 동작을 내부적으로 모방합니다. 옵션-값 쌍에서 *file* 인수가 `/dev/fd/N`의 형식이라면 파일 디스크립터 *N*을 확인합니다. 만약 옵션-값 쌍에서 *file* 인수가 `/dev/stdin`, `/dev/stdout`, `/dev/stderr` 중 하나라면 각각 파일 디스크립터 0, 1, 2를 확인합니다.

'<'와 '>' 연산자는 `[[`와 함께 사용할 때 현재 로케일을 사용하여 사전순으로 정렬합니다. `test` 명령어는 ASCII 순서를 사용합니다.

따로 언급하지 않는다면 파일명을 사용하는 옵션-값 쌍은 심볼릭 링크를 따라가며, 링크 자체와 동작하기 보다는 링크의 타겟과 동작합니다.

**-a *file***
*file*이 존재하면 참입니다.

**-b *file***
*file*이 존재하고 블록 특수 파일이라면 참입니다.

**-c *file***
*file*이 존재하고 문자 특수 파일이라면 참입니다.

**-d *file***
*file*이 존재하고 디렉터리라면 참입니다.

**-e *file***
*file*이 존재하면 참입니다.

**-f *file***
*file*이 존재하고 일반 파일이라면 참입니다.

**-g *file***
*file*이 존재하고 파일의 set-group-id 비트가 설정되어 있다면 참입니다.

**-h *file***
*file*이 존재하고 심볼릭 링크라면 참입니다.

**-k *file***
*file*이 존재하고 파일의 "sticky" 비트가 설정되어 있다면 참입니다.

**-p *file***
*file*이 존재하고 이름이 명명된 파이프(FIFO)라면 참입니다.

**-r *file***
*file*이 존재하고 읽을 수 있다면 참입니다.

**-s *file***
*file*이 존재하고 크기가 0보다 크다면 참입니다.

**-t *fd***
파일 디스크립터 *fd*가 열려 있고, 터미널에 연결되어 있다면 참입니다.

**-u *file***
*file*이 존재하고 파일의 set-user-id 비트가 설정되어 있다면 참입니다.

**-w *file***
*file*이 존재하고 쓸 수 있다면 참입니다.

**-x *file***
*file*이 존재하고 실행할 수 있다면 참입니다.

**-G *file***
*file*이 존재하고 유효한 그룹 id이 소유하고 있다면 참입니다.

**-L *file***
*file*이 존재하고 심볼릭 링크라면 참입니다.

**-N *file***
*file*이 존재하고 마지막으로 읽은 이후에 수정되었다면 참입니다.

**-O *file***
*file*이 존재하고 유효한 유저 id가 소유하고 있다면 참입니다.

**-S *file***
*file*이 존재하고 소켓이라면 참입니다.

***file1* -ef *file2***
*file1*과 *file2*가 같은 디바이스와 inode 번호를 가리키고 있다면 참입니다.

***file1* -nt *file2***
*file1*이 *file2*보다 새로운 파일(수정 날짜로 판단)이거나 *file1*이 존재하고 *file2*가 존재하지 않는다면 참입니다.

***file1* -ot *file2***
*file1*이 *file2*보다 오래된 파일이거나 *file2*가 존재하고 *file1*이 존재하지 않는다면 참입니다.

**-o *optname***
셸 옵션 *optname*이 켜져있다면 참입니다. 옵션의 리스트는 `set` 빌트인의 `-o` 옵션의 설명에서 확인할 수 있습니다(The Set Builtin을 참조).

**-v *varname***
셸 변수 *varname*이 설정되어 있다면(값이 대입되어 있다면) 참입니다.

**-R *varname***
셸 변수 *varname*이 설정되어 있고, nameref라면 참입니다.

**-z *string***
*string*의 길이가 0이라면 참입니다.

**-n *string***
***string***
*string*의 길이가 0이 아니라면 참입니다.

**string1 == string2**
**string1 = string2**
문자열이 같다면 참입니다. `[[` 명령어와 사용했다면 이는 위에서 설명한 것처럼 패턴 매칭을 수행합니다(Conditional Constructs를 참조).
POSIX 모드에서 `test`와 쓰려면 '='를 사용해야 합니다.

**string1 != string2**
문자열이 같지 않다면 참입니다.

**string1 < string2**
*string1*이 *string2*보다 사전순이 앞이라면 참입니다.

**string1 > string2**
*string1*이 *string2*보다 사전순이 뒤라면 참입니다.

***arg1* OP *arg2***
`OP`는 '`-eq`', '`-ne`', '`-lt`', '`-le`', '`-gt`', '`-ge`' 중 하나입니다. 이 산술 이항 연산자는 각각 *arg1*이 *arg2*와 같거나, 다르거나, 작거나, 작거나 같거나, 크거나, 크거나 같을 때 참입니다. *arg1*와 *arg2*는 양의 정수와 음의 정수가 될 수 있습니다. `[[` 명령어와 사용하면 *arg1*과 *arg2*는 산술 표현식으로 평가됩니다(Shell Arithmetic을 참조).

## 6.5 Shell Arithmetic
셸은 셸 전개나 `((` 복합 명령어, `let` 빌트인, `declare` 빌트인에 `-i`옵션을 넘기는 것으로 산술 표현식을 평가할 수 있습니다.

평가는 고정된 너비의 정수로 오버플로우에 대한 검사 없이 수행되며, 0으로 나누면 트랩에 걸리고 에러로 처리됩니다. 연산자의 우선 순위, 연관성, 값은 C 언어에서의 그것과 동일합니다. 다음 연산자의 목록은 동일한 우선 순위를 가지는 연산자들끼리 모아두었습니다. 리스트의 우선순위는 내림차순입니다.

**id++ id--**
변수를 평가후에 증가/감소

**++id --id**
변수를 평가전에 증가/감소

**- +**
단항 마이너스와 플러스

**! ~**
논리/비트 부정 연산자

**\*\***
지수 계산

**\* / %**
곱셈, 나눗셈, 나머지 계산

**+ -**
덧셈, 뺄셈

**<< >>**
왼쪽, 오른쪽 비트 연산

**<= >= < >**
비교

**== !=**
일치/불일치

**&**
비트 연산자 AND

**^**
비트 연산자 XOR

**|**
비트 연산자 OR

**&&**
논리 AND

**||**
논리 OR

**expr ? expr : expr**
조건 연산자

**= \*= /= %= += -= <<= >>= &= ^= |=**
대입

**expr1 , expr2**
쉼표

셸 변수를 피연산자로 사용할 수 있습니다. 표현식을 평가하기 전에 매개변수 전개가 이루어집니다. 표현식에서는 셸 변수를 매개변수 전개 문법 없이 이름으로만 참조할 수도 있습니다. 매개변수 전개 문법을 사용하지 않고 이름을 참조하는 경우 값이 널이거나 제거된 셸 변수는 0으로 평가됩니다. 변수의 값은 참조될 때, '`declare -i`'를 사용하여 *integer* 속성이 부여된 변수에 대입될 때 산술 표현식으로 평가됩니다. 널 값은 0으로 평가됩니다. *integer* 속성을 가지지 않는 셸 변수는 표현식에서 사용할 수 있도록 해당 속성을 켭니다.

정수 상수는 접미사와 문자 상수를 제외하고 C 언어 정의를 따라갑니다. 0으로 시작하는 상수는 8진수로 처리됩니다. '0x'나 '0X'로 시작하면 16진수임을 의미합니다. 그렇지 않으면 숫자는 `[base#]n`의 형식을 받으며 임의로 지정할 수 있는 *base* 2와 64 사이의 10진수는 진법을 지정하며, *n*은 해당 진법의 숫자입니다. *base#*을 생략하면 10진법이 사용됩니다. *n*을 지정할 때 숫자가 아닌 문자가 필요하다면 9보다 큰 숫자는 소문자, 대문자, '@', '_' 순으로 표현됨을 기억하세요. *base*가 36 이하라면 10과 35 사이의 숫자를 표현하기 위해 소문자와 대문자 어느쪽이든 사용할 수 있습니다.

연산자는 우선순위대로 평가됩니다. 소괄호 내부의 표현식은 먼저 평가되며 위의 우선순위 규칙보다 우선될 수 있습니다.

## 6.6 Aliases
별칭은 문자열이 단순 명령어의 첫번째 단어로 사용되었을 때 다른 단어로 대체할 수 있도록 해줍니다. 셸은 `alias`와 `unalias` 빌트인 명령어를 사용하여 별칭 리스트를 관리합니다.

따옴표로 감싸져있지 않다면, 각 단순 명령어의 첫번째 단어가 별칭을 가지고 있는지 검사합니다. 만약 가지고 있다면 해당 단어는 별칭의 텍스트로 대체됩니다. 문자 '/', '$', '\`', '='과 위에서 나열했던 셸의 메타 문자, 또는 따옴표로 감싼 문자는 별칭 이름으로 사용할 수 없습니다. 대체 텍스트는 셸 메타 문자를 포함한 어떤 유효한 셸 입력이든 포함할 수 있습니다. 대체 텍스트의 첫번째 단어는 별칭이 있는지 검사되지만, 전개된 별칭과 동일한 단어는 두 번 전개되지 않습니다. 예를 들자면, `ls`에 "`ls -F`"라는 별칭이 있을 경우, Bash는 재귀적으로 대체 문자열을 확장하지 않을 것입니다. 별칭의 값의 마지막 문자가 공백이라면, 별칭 뒤에 오는 다음 명령어 단어 역시 별칭 전개의 대상이 됩니다.

별칭은 `alias` 명령어로 생성되거나 나열될 수 있으며, `unalias` 명령어로 제거합니다.

`csh`처럼 대체 텍스트에서 인수를 사용할 방법은 없습니다. 인수가 필요하다면 셸 함수를 사용해야 합니다(Shell Functions를 참조).

셸이 인터랙티브 모드가 아닐 때 `shopt`를 사용해서 *expand_aliases* 셸 옵션(The Shopt Builtin을 참조)을 켜지 않는다면 별칭은 전개되지 않습니다.

별칭의 정의와 사용법에 대한 규칙은 혼란스럽습니다. Bash는 한 줄에 있는 명령어 또는 복합 명령어를 실행하기 전에 언제나 적어도 하나의 완전한 줄 입력과 복합 명령어를 구성하는 모든 줄을 읽습니다. 별칭은 명령어를 읽을 때 전개됩니다만 실행될 때는 아닙니다. 그러므로 같은 줄에서 다른 명령어에 대한 별칭 정의는 다음 줄의 입력을 읽을 때까지 적용되지 않습니다. 같은 줄에서 별칭 정의 뒤에 오는 명령어에는 새 별칭이 유효하지 않습니다. 이 동작은 함수를 실행할 때도 문제가 있습니다. 별칭은 함수 정의를 읽을 때 전개되고, 함수를 실행할 때는 전개되지 않습니다. 이는 함수 정의 자체가 명령어이기 때문입니다. 그 결과로 함수에서 정의된 별칭은 해당 함수가 실행이 끝날 때까지 사용할 수 없습니다. 안전하게 사용하기 위해서 모든 별칭 정의는 다른 줄에 선언하고, `alias`를 복합 명령어에서 사용하지 마세요.

거의 모든 경우에서 셸 함수는 별칭보다 낫습니다.

## 6.7 Arrays
Bash는 1차원 순차, 연상 배열 변수를 제공합니다. 어떤 변수라도 순차 배열로 사용할 수 있습니다. `declare` 빌트인을 사용해서 명시적으로 배열을 선언할 수 있습니다. 배열의 크기에는 제한이 없으며, 요소가 순서대로 또는 인접하게 대입해야한다는 제약사항도 없습니다. 순차 배열은 정수(산술 표현식을 포함합니다. Shell Arithmetic을 참조하세요)를 사용해 참조하며 0부터 시작합니다. 연상 배열은 임의의 문자열을 사용합니다. 따로 언급하지 않는다면 순차 배열의 인덱스는 음의 정수가 아닌 정수입니다.

순차 배열은 다음 문법을 통해 대입하면 자동으로 생성됩니다.

```sh
name[subscript]=value
```

*subscript*는 반드시 숫자로 평가되어야하는 산술 표현식으로 처리됩니다. 명시적으로 배열을 선언하고 싶다면 다음을 사용하세요.

```sh
declare -a name
```

다음 문법도 사용할 수 있습니다. *subscript*는 무시됩니다.

```sh
declare -a name[subscript]
```

연상 배열은 다음 문법으로 생성할 수 있습니다.

```sh
declare -A name
```

배열 변수를 위한 속성은 `declare`와 `readonly` 빌트인을 사용해서 지정할 수 있습니다. 각 속성은 배열의 모든 요소에 적용됩니다.

배열은 다음 형식의 복합 대입으로 값을 대입합니다.

```sh
name=(value1 value2 … )
```

각 *value*는 `[subscript]=string`의 형식일 수 있습니다. 순차 배열 대입에는 *string*만 있어도 됩니다. 순차 배열에 대입할 때 임의의 첨자를 넘기면 해당 인덱스에 대입됩니다. 그렇지 않으면 해당 대입문이 대입한 마지막 인덱스 값에 1을 더한 인덱스에 요소를 대입합니다. 인덱스는 0부터 시작합니다.

리스트에 있는 각 *value*는 이전에 설명한 모든 셸 전개의 적용을 받습니다(Shell Expansions를 참조).

연상 배열에 값을 대입할 때 복합 대입에 있는 단어는 첨자를 요구하는 대입문이거나 키와 값 나열로 해석되는 단어 리스트 *name=(key1 value1 key2 value2 … )* 입니다. 이는 *name=( [key1]=value1 [key2]=value2 … )* 와 동일하게 취급됩니다. 리스트의 첫번째 단어가 나머지 단어를 어떻게 처리할지 결정합니다. 리스트의 모든 대입은 모두 같은 타입이어야 합니다. 키/값 쌍을 사용할 때 키가 존재하지 않거나 비어있을 수 없습니다. 찾지 못한 마지막 값은 빈 문자열로 처리됩니다.

이 문법은 `declare` 빌트인에서도 사용할 수 있습니다. 개별 배열 요소는 위에서 소개한 *name[subscript]=value* 문법을 사용해 대입할 수 있습니다.

순차 배열에 대입할 때 *name*에 음수 첨자를 사용했다면 해당 숫자는 *name*의 최대 인덱스보다 1 큰 값의 상대값으로 처리되므로 음수 인덱스는 배열의 뒷머리부터 셉니다. 인덱스 -1은 마지막 요소를 가리킵니다.

배열의 요소는 `${name[subscript]}`를 사용해서 참조할 수 있습니다. 셸의 파일명 전개 연산자와의 충돌을 피하기 위해서 중괄호는 필수입니다. *subscript*가 '@'나 '\*'라면, 단어는 배열 *name*의 모든 요소로 전개됩니다. 이 첨자들은 단어가 큰따옴표 사이에 나타날 경우에만 동작이 다릅니다. 만약 단어를 큰따옴표로 감쌌다면 `${name[*]}`는 각 배열 요소가 `IFS` 변수의 첫번째 문자로 구분된 단일 단어로 전개되며, `${name[@]}`는 *name*의 각 요소를 다른 단어로 전개합니다. 만약 배열에 요소가 없다면, `${name[@]}`는 아무것도 없는 상태로 전개됩니다. 큰따옴표 전개가 단어 내부에서 일어나면 첫번째 매개변수의 전개 결과가 원래 단어의 앞 부분과 연결되며 마지막 매개변수의 전개 결과가 원래 단어의 마지막 부분과 연결됩니다. 이는 특수 매개변수 '@', '*'의 전개와 유사합니다. `${#name[subscript]}`는 `${name[subscript]}`의 길이로 전개됩니다. 만약 *subscript*가 '@'나 '*'라면 전개 결과는 배열에 있는 요소의 개수입니다. 순차 배열의 요소를 참조하기 위해 사용된 *subscript*의 평가 결과가 0보다 작다면, 배열의 최대 인덱스보다 1 큰 값의 상대 값으로 처리되므로 음수 인덱스는 배열의 뒷머리부터 셉니다. 인덱스 -1은 마지막 요소를 가리킵니다.

첨자 없이 배열 변수를 참조하는 것은 0번째 요소를 가리키는 것과 같습니다. 모든 유효한 첨자를 사용하는 변수에 대한 참조는 정상이며 `bash`는 필요하다면 배열을 생성합니다.

첨자에 값을 대입했다면 배열 변수가 설정되어 있다고 판단합니다. 널 문자열은 유효한 값입니다.

배열의 키(인덱스)와 값을 얻을 수 있습니다. `${!name[@]}`와 `${!name[*]}`는 배열 변수 *name*에 대입된 인덱스로 전개됩니다. 큰따옴표 사이에 있을 때의 처리는 큰따옴표 사이의 특수 매개변수 '@', '*'의 전개와 유사합니다.

`unset` 빌트인은 배열을 제거할 때 사용합니다. `unset name[subscript]`은 인덱스 *subscript*에 있는 배열 요소를 제거합니다. 순차 배열에 음수 첨자를 넘기면 위에서 설명한 방식대로 처리됩니다. 배열 변수의 마지막 요소를 제거하더라도 배열이 제거되지 않습니다. `unset name`은 *name*이 배열이라면 전체 배열을 제거합니다. '*', '@' 첨자를 사용하면 전체 배열을 제거합니다.

예를 들어 `unset`처럼 위에서 설명한 단어 전개 문법을 사용하지 않고 명령어의 인수로 첨자와 함께 배열 이름을 사용하면 인수는 셸의 파일명 확장의 적용을 받습니다. 파일명 전개를 원하지 않는다면 인수를 따옴표로 감싸야 합니다.

`declare`, `local`, `readonly` 빌트인은 각각 순차 배열을 지정하는 `-a` 옵션, 연상 배열을 지정하는 `-A` 옵션을 받습니다. 두 옵션을 같이 넘기면 `-A`가 우선됩니다. `read` 빌트인은 `-a` 옵션을 받아 표준 입력으로부터 단어 리스트를 읽어서 배열에 대입하거나 표준 입력으로부터 값을 읽어 개별 배열 요소로 대입할 수 있습니다. `set`과 `declare` 빌트인은 입력으로 재활용 가능한 형식으로 배열의 값을 출력합니다.

## 6.8 The Directory Stack
- Directory Stack Builtins : 디렉터리 스택을 관리하는 Bash 빌트인 명령어

디렉터리 스택은 최근 방문한 디렉터리 리스트입니다. `pushd` 빌트인은 스택에 디렉터리를 추가하며 현재 디렉터리를 변경합니다. `popd` 빌트인은 지정한 디렉터리를 스택에서 제거하며 현재 디렉터리를 스택에서 제거한 디렉터리로 변경합니다. `dirs` 빌트인은 디렉터리 스택의 내용을 보여줍니다. 현재 디렉터리는 언제나 디렉터리 스택의 가장 위에 존재합니다.

디렉터리 스택의 내부는 `DIRSTACK` 셸 변수의 값으로도 볼 수 있습니다.

### 6.8.1 Directory Stack Builtins
**dirs**
```sh
dirs [-clpv] [+N | -N]
```
현재 기억중인 디렉터리 리스트를 보여줍니다. 디렉터리는 `pushd` 명령어로 리스트에 추가됩니다. `popd` 명령어는 리스트에서 디렉터리를 제거합니다. 현재 디렉터리는 언제나 스택의 첫번째에 위치합니다.

- **-c**
  모든 요소를 지워서 디렉터리 스택을 비웁니다.
- **-l**
  전체 경로명을 사용하여 목록을 생성합니다. 기본 출력 형식은 홈 디렉터리를 나타내기 위해 물결줄표를 사용합니다.
- **-p**
  `dirs`가 디렉터리 스택을 한 줄에 한 요소씩 출력합니다.
- **-v**
  `dirs`가 디렉터리 스택을 한 줄에 한 요소씩 출력하며, 각 요소는 스택에서의 인덱스를 접두어로 사용합니다.
- **+N**
  *N*번째 디렉터리(옵션 없이 `dirs`를 호출했을 때 출력되는 리스트의 왼쪽으로부터 셉니다)를 보여줍니다. 0부터 시작합니다.
- **-N**
  *N*번째 디렉터리(옵션 없이 `dirs`를 호출했을 때 출력되는 리스트의 오른쪽으로부터 셉니다)를 보여줍니다. 0부터 시작합니다.

**popd**
```sh
popd [-n] [+N | -N]
```
인수를 넘기지 않으면 `popd`는 스택의 맨 위에 있는 디렉터리를 제거하고, 새 최상위 디렉터리로 `cd`를 실행합니다. 각 요소는 `dirs`를 실행했을 때 출력되는 첫번째 디렉터리로부터 0으로 시작하는 숫자가 매겨져 있습니다. 다시 말하면, `popd`는 `popd +0`과 동일합니다.

- **-n**
  스택으로부터 디렉터리를 제거할 때 디렉터리 변경을 억제하여 스택만 변경되도록 합니다.
- **+*N***
  *N*번째 디렉터리(`dirs`로 출력되는 목록의 왼쪽으로부터 셉니다)를 제거합니다. 0부터 시작합니다.
- **-*N***
  *N*번째 디렉터리(`dirs`로 출력되는 목록의 오른쪽으로부터 셉니다)를 제거합니다. 0부터 시작합니다.

**pushd**
```sh
pushd [-n] [+N | -N | dir]
```
현재 디렉터리를 디렉터리 스택의 맨 위에 저장하고, *dir*로 `cd`를 실행합니다. 인수가 없다면 `pushd`는 최상위 디렉터리 두 개의 위치를 교환하고 현재 디렉터리를 새 최상위 디렉터리로 변경합니다.

- **-n**
  스택의 디렉터리를 순환시키거나 디렉터리를 추가할 때 디렉터리의 변경을 억제하여 스택만 변경되도록 합니다.
- **+*N***
  *N*번째 디렉터리(`dirs`로 출력되는 목록의 왼쪽으로부터 세며, 0부터 시작합니다)를 리스트의 최상위에 오도록 스택을 순환시킵니다.
- **-*N***
  *N*번째 디렉터리(`dirs`로 출력되는 목록의 오른쪽으로부터 세며, 0부터 시작합니다)를 리스트의 최상위에 오도록 스택을 순환시킵니다.
- ***dir***
  *dir*을 스택의 최상위에 추가하고 `cd` 빌트인 명령어에 해당 값을 넘긴 것처럼, 새 현재 디렉토리로 만듭니다.

## 6.9 Controlling the Prompt
Bash는 각 주 프롬프트를 출력하기 직전에 `PROMPT_COMMAND` 배열의 값을 검사합니다. `PROMPT_COMMAND`의 어떤 요소가 설정되어 있고 널이 아닌 값이라면, Bash는 각 값이 커맨드 라인에 입력된 것처럼 숫자순으로 실행합니다.

나아가 다음 표는 프롬프트 변수 `PS0`, `PS1`, `PS2, `PS4`에서 나타날 수 있는 특수 문자에 대해서 설명합니다.

- **\a**
  벨 문자.
- **\d**
  "요일 월 일" 형식의 날짜(e.g.,  "Tue May 26")
- **\D{*format*}**
  `strftime(3)`에 *format*을 넘기고 그 결과를 프롬프트 문자열에 삽입합니다. 빈 *format*은 로케일 지정 시간 표현이 됩니다. 중괄호는 필수입니다.
- **\\e**
  이스케이프 문자.
- **\\h**
  호스트명. 첫번째 '.'까지.
- **\\H**
  호스트명.
- **\\j**
  셸이 현재 관리하고 있는 잡의 개수.
- **\\l**
  셸의 터미널 디바이스명의 기본이름(basename).
- **\\n**
  개행.
- **\\r**
  캐리지 리턴.
- **\\s**
  셸의 이름 `$0`의 기본이름(마지막 슬래시의 뒷부분)
- **\\t**
  24시간 HH:MM:SS 형식의 시각.
- **\\T**
  12시간 HH:MM:SS 형식의 시각.
- **\\@**
  12시간 am/pm 형식의 시각.
- **\\A**
  24시간 HH:MM 형식의 시각.
- **\\u**
  현재 사용자의 유저명.
- **\\v**
  Bash의 버전(e.g., 2.00)
- **\\V**
  Bash의 릴리스, 버전 + 패치 레벨(e.g. 2.00.0)
- **\\w**
  현재 작업 디렉터리. `$HOME`은 물결줄표로 단축됩니다(`$PROMPT_DIRTRIM` 변수를 사용).
- **\\W**
  `$PWD`의 기본이름. `$HOME`은 물결줄표로 단축됩니다.
The basename of $PWD, with $HOME abbreviated with a tilde.
- **\\!**
  이 명령어의 이력 번호.
- **\\#**
  이 명령어의 명령어 번호.
- **\\$**
  유효한 uid가 0이라면 `#`, 아니라면 `$`.
- **\\*nnn***
  ASCII 코드의 8진수 값이 *nnn*인 문자.
- **\\\\**
  백슬래시.
- **\\\[**
  출력 불가 문자 나열의 시작을 표시. 터미널 제어 나열을 프롬프트에 끼워넣기 위해서 사용할 수 있습니다.
- **\\]**
  출력 불가 문자 나열의 끝을 표시.

명령어 번호와 이력 번호는 일반적으로 다릅니다. 명령어의 이력 번호는 이력 리스트에서 그 명령어의 위치이며, 이는 이력 파일(Bash History Facilities를 참조)로부터 복구된 명령어를 포함할 수도 있습니다. 반면 명령어 번호는 현재 셸 세션에서 실행된 명령어 리스트에서의 위치입니다.

문자열이 디코딩된 후, `promptvars` 셸 옵션(The Shopt Builtin을 참조)의 값에 따라 매개변수 전개, 명령어 치환, 산술 전개, 따옴표 제거가 이루어집니다. 문자열의 이스케이프된 부분이 명령어 치환에서 나타나거나 단어 전개에서 특별한 의미를 가지는 문자가 포함되어 있다면 이는 의도하지 않은 부작용이 발생할 가능성이 있습니다.

## 6.10 The Restricted Shell
Bash가 `rbash`라는 이름으로 실행되거나 호출시에 `--restricted`나 `-r` 옵션이 넘겨졌다면 셸은 한정 모드가 됩니다. 한정 모드의 셸은 표준 셸보다 환경을 좀 더 제어하고 싶을 때 사용합니다. 한정 모드의 셸은 다음의 동작을 금지하거나 실행되지 않는다는 점을 제외하면 `bash`와 동일하게 동작합니다.

- `cd` 빌트인 명령어로 디렉터리를 변경하기.
- `SHELL`, `PATH`, `HISTFILE`, `ENV`, `BASH_ENV` 변수의 값을 설정하거나 제거하기.
- 슬래시를 포함하는 명령어 이름을 지정하기.
- `.` 빌트인 명령어의 인수로 슬래시를 포함하는 파일명을 지정하기.
- `history` 빌트인 명령어의 인수로 슬래시를 포함하는 파일명을 지정하기.
- `hash` 빌트인 명령어의 `-p` 옵션의 인수로 슬래시를 포함하는 파일명을 지정하기.
- 기동 중에 셸 환경으로부터 함수 정의를 가져오기.
- 기동 중에 셸 환경으로부터 `SHELLOPTS`의 값을 구문 분석하기.
- 리다이렉션 연산자 '>', '>|', '<>', '>&', '&>', '>>'를 사용하여 출력을 리다이렉팅하기.
- `exec` 빌트인 명령어를 사용해서 셸을 다른 명령어로 대체하기.
- `enable` 빌트인 명령어의 `-f`, `-d` 옵션을 사용해서 빌트인 명령어를 추가하거나 제거하기.
- `enable` 빌트인 명령어로 셸 빌트인을 유효화하거나 무효화하기.
- `command` 빌트인 명령어에 `-p` 옵션 지정하기.
- 'set +r'이나 'set +o restricted'로 한정 모드를 끄기.

이 제약들은 기동 파일을 읽은 후부터 적용됩니다.

셸 스크립트(Shell Scripts를 참조)라고 판명된 명령어가 실행되면, `rbash`는 스크립트를 실행하기 위해서 생성된 셸에서는 제약을 전부 무효화합니다.

셸의 한정 모드는 유용한 한정된 환경의 구성요소중 하나에 불과합니다. 이는 `PATH`를 몇몇 검증된 명령어(셸 이스케이프를 허용하는 명령어는 매우 위험합니다)만 실행할 수 있는 값으로 설정하기, 로그인 후에 홈 디렉터리 이외의 쓰기 불가로 만들기, 한정 모드에서 셸 스크립트 실행을 금지하기, 몇몇 명령어의 동작을 변경하는 변수(e.g. `VISUAL`, `PAGER`)의 환경을 청소하는 것을 포함합니다.

현대적인 시스템은 `jails`, `zones`, `containers`와 같은 한정된 환경을 구현하는 좀 더 안전한 방식을 제공합니다.

## 6.11 Bash POSIX Mode
`--posix` 커맨드 라인 옵션과 함께 Bash를 시작하거나 Bash가 동작하는 중에 '`set -o posix`'를 실행하면 Bash는 표준과 다른 Bash의 기본 동작을 POSIX에 기술된대로 변경하여 POSIX 표준에 더 가까워지도록 합니다.

`sh`로 호출하면 Bash는 기동 파일을 읽은 뒤 POSIX 모드에 들어갑니다.

다음 목록은 'POSIX 모드'일 때 어떤 변경이 발생하는지 보여줍니다.

1. Bash는 `POSIXLY_CORRECT` 변수가 설정되어 있음을 보증합니다.
2. 해시 테이블의 명령어가 더 이상 존재하지 않을 때, Bash는 새 위치를 찾아 `$PATH`를 다시 검색합니다. 이 기능은 '`shopt -s checkhash`'로도 켤 수 있습니다.
3. Bash는 실행 가능 비트가 없는 명령어를 `$PATH` 검색의 결과로 반환되었다 하더라도 명령어 해시 테이블에 삽입하지 않습니다.
4. 0이 아닌 스테이터스로 종료했을 때 잡 컨트롤 코드와 빌트인이 출력하는 메시지는 'Done(status)'입니다.
5. 잡이 정지했을 때 잡 컨트롤 코드와 빌트인이 출력하는 메시지는 'Stopped(*signame*)'입니다. *signame*은 예를 들어, `SIGTSTP`를 말합니다.
6. 별칭 전개는 논-인터랙티브 셸이라해도 항상 켜져 있습니다.
7. 예약어가 인식되지 않는 컨텍스트에서의 예약어는 별칭 전개가 적용되지 않습니다.
8. POSIX의 `PS1`와 `PS2`의 '!'의 이력 번호에 대한 전개와 '!!'를 '!'로 전개하는 기능이 켜짐이 되며, `promptvars` 옵션의 값에 관계 없이 `PS1`과 `PS2`에서 매개변수 확장이 실행됩니다.
9. 일반 Bash 파일 대신 POSIX 기동 파일(`$ENV`)이 실행됩니다.
10. 물결줄표 전개는 줄의 모든 대입문에서 실행되지 않고 명령어 이름에 선행하는 대입에서만 실행됩니다.
11. 기본 이력 파일이 `~/.sh_history`가 됩니다(이는 `$HISTFILE`의 기본값입니다).
12. 셸이 인터랙티브 모드가 아니라면 리다이렉션 연산자는 리다이렉션에 포함된 파일명 전개를 실행하지 않습니다.
13. 리다이렉션 연산자는 리다이렉션에서 단어에서 단어 분리를 실행하지 않습니다.
14. 함수 이름은 반드시 유효한 셸 이름이어야 합니다. 다시 말해, 함수 이름은 영문자, 숫자, 밑줄만을 사용해야 하며, 숫자로 시작할 수 없습니다. 논-인터랙티브 셸에서 올바르지 않은 이름으로 함수를 선언하면 치명적인 에러가 발생합니다.
15. 함수 이름은 POSIX 특수 빌트인 명령어와 같은 이름을 사용할 수 없습니다.
16. POSIX 특수 빌트인은 명령어 탐색에서 셸 함수보다 먼저 검색됩니다.
17. 셸 함수 정의를 출력할 때(e.g., `type` 명령어), Bash는 `function` 키워드를 출력하지 않습니다.
18. `PATH`변수의 각 요소에서의 첫번째 글자로 나오는 물결줄표 문자는 Tilde Expansion에서 설명된 물결줄표 전개가 발생하지 않습니다.
19. `time` 예약어는 그 자체를 명령어로 사용할 수 있습니다. 이렇게 사용하면 셸과 셸의 완료된 자식들의 타이밍 통계를 보여줍니다. `TIMEFORMAT` 변수는 이 타이밍 정보의 형식을 제어합니다.
20. 큰따옴표 내부의 `${…}` 전개를 구문 분석하고 전개할 때, 패턴 제거를 실행하기 위해 정의된 연산자가 아니라면 작은따옴표를 특별하게 다루지 않으며, 닫는 중괄호나 다른 특수 문자를 감싸는 용도로 사용할 수 없습니다. 이 경우, 작은따옴표는 쌍으로 나타날 필요가 없습니다.
21. 파서는 `time`의 다음 토큰이 '-'로 시작할 때 `time`을 예약어로 인식하지 않습니다.
22. '!' 문자는 `histexpand` 옵션이 켜져있더라도 큰따옴표로 감싼 문자열 내부에서 이력 전개를 실행하지 않습니다.
23. POSIX 특수 빌트인이 에러 스테이터스를 반환하면, 논-인터랙티브 셸은 종료합니다. 치명적인 에러는 POSIX 표준에 나열되어 있습니다. 여기에는 잘못된 옵션 넘기기, 리다이렉션 에러, 명령어 앞에서의 변수 대입 에러 등이 포함됩니다.
24. 변수 대입문 이후에 명령어 이름이 따라오지 않을 때, 변수 대입 에러가 발생하면 논-인터랙티브 셸은 에러 스테이터스와 함께 종료합니다. 예를 들어, 읽기 전용 변수에 값을 대입하려고 시도하면 변수 대입 에러가 발생합니다.
25. 특수 빌트인의 앞에 오는 대입문에서 변수 대입 에러가 발생하면 논-인터랙티브 셸은 에러와 함께 종료합니다. 단순 명령어와 함께 동작할 때는 에러를 발생시키지 않습니다.
26. `for`문의 반복 변수나 `select`문의 선택 변수가 읽기 전용 변수라면 논-인터랙티브 셸은 에러와 함께 종료합니다.
27. '. *filename*'에서 *filename*을 찾을 수 없다면 논-인터랙티브 셸은 종료합니다.
28. 유효하지 않은 표현식의 산술 전개 결과에서 문법 에러가 발생하면 논-인터랙티브 셸은 종료합니다.
29. 매개변수 전개 에러가 발생하면 논-인터랙티브 셸은 종료합니다.
30. `.`나 `source` 빌트인으로 읽은 스크립트나 `eval` 빌트인을 처리한 문자열에 문법 에러가 있다면 논-인터랙티브 셸은 종료합니다.
31. 변수 간접 참조가 사용 가능하더라도 '#'과 '?' 특수 매개변수에는 적용할 수 없습니다.
32. 전개가 큰따옴표로 감싸진 패턴 컨텍스트에서 '*' 특수 매개변수를 전개할 때, `$*`를 큰따옴표로 감싸지 않은 것처럼 다룹니다.
33. POSIX 특수 빌트인의 앞에 오는 대입문의 영향은 빌트인이 실행 완료된 이후에도 셸 환경에 남습니다.
34. `command` 빌트인은 실행할 빌트인이 인수로 받은 대입문을 전개하는 것을 막지 못합니다. POSIX 모드가 아니라면, `command` 뒤에 오는 경우, 대입문 전개의 속성을 잃어버립니다.
35. `bg` 빌트인은 백그라운드에 위치한 각 잡을 기술하기 위해서 필요한 형식을 사용합니다만, 이 형식은 각 잡이 현재 잡인지 이전 잡인지에 대한 정보를 포함하지 않습니다.
36. '`kill -l`'은 한 줄에 모든 시그널 이름을 스페이스 구분에 '`SIG`' 접두사 없이 출력합니다.
37. `kill` 빌트인은 '`SIG`' 접두사를 사용하는 시그널 이름을 받지 않습니다.
38. `export`와 `readonly` 빌트인 명령어는 POSIX가 요구하는 형식으로 결과를 출력합니다.
39. `trap` 빌트인은 `SIG` 접두사 없이 시그널 이름을 출력합니다.
40. `trap` 빌트인은 첫번째 인수로 숫자로만 구성되고 유효한 시그널 번호가 아니라면, 첫번째 인수를 시그널에 트랩으로 설정할 수 있는지 확인하지 않으며, 시그널의 트랩이 존재했다면 시그널 처리를 원래 상태로 되돌립니다. 주어진 시그널을 원래 상태로 초기화하고 싶다면 첫번째 인수로 '-'를 사용해야 합니다.
41. `trap -p`는 트랩이 `SIG_DFL`으로 설정된 시그널만 출력하며, 이들은 셸이 시작할때 무시됩니다.
42. `.`와 `source` 빌트인은 파일명 인수를 사용하기 위해 현재 디렉터리가 `PATH`에 존재하지 않는 한 이를 탐색하지 않습니다.
43. POSIX 모드를 켜면 `inherit_errexit` 옵션이 켜는 것과 같은 효과가 있습니다. 그러므로 명령어 치환을 실행하기 위해 생성되는 서브셸은 부모 셸의 `-e` 옵션을 상속합니다. `inherit_errexit` 옵션이 켜져있지 않다면, Bash는 이러한 서브셸을 생성할 때 `-e` 옵션을 끕니다.
44. POSIX 모드를 켜면 `shift_verbose` 옵션을 켜는 것과 같은 효과가 있습니다. 그러므로 `shift`에 넘긴 숫자 인수가 위치 매개변수의 개수보다 크다면 에러를 발생시킵니다.
45. `alias` 빌트인이 별칭 정의를 보여줄 때, `-p` 옵션을 넘기지 않는 이상 각 별칭 앞에 '`alias `'를 출력하지 않습니다.
46. `set` 빌트인을 옵션 없이 호출하면 셸 함수 이름과 정의를 출력하지 않습니다.
47. `set` 빌트인을 옵션 없이 호출하면, 변수 값이 셸 메타 문자를 포함하지 않는다면, 출력 불가능한 문자를 포함하더라도 따옴표로 감싸지 않은 값을 출력합니다.
48. `cd` 빌트인을 *로지컬* 모드에서 호출했고 `$PWD`로부터 생성한 경로명과 인수로 넘겨진 디렉터리명이 존재하지 않는 디렉터리를 참조하는 경우, `cd`는 *피지컬* 모드로 넘어가는 대신 실패합니다.
49. `cd` 빌트인이 `$PWD`로부터 생성한 경로명의 길이와 인수로 넘긴 디렉터리 이름에 포함된 모든 심볼릭 링크를 전개한 길이가 *PATH_MAX*보다 커서 디렉터리를 변경하지 못할 때, `cd`는 주어진 디렉터리 이름을 사용하려고 시도하기보다는 실패합니다.
50. `pwd` 빌트인은 `-P` 옵션으로 파일 시스템을 검사하기를 요청하지 않아도 자신이 출력할 값이 현재 디렉터리와 같은지 검증합니다.
51. 이력을 나열할 때, `fc` 빌트인은 각 이력이 수정되었는지 아닌지에 대한 정보를 포함하지 않습니다.
52. `fc`의 기본 에디터는 `ed`입니다.
53. 실행할 수 없는 파일이 `$PATH`에서 발견한 유일한 이름이고, 이를 실행하려고 시도하지만, `type`와 `command` 빌트인은 이를 발견했다고 보고하지 않습니다.
54. `vi` 편집 모드는 `v` 명령어가 실행중이라면, `$VISUAL`과 `$EDITOR`를 확인하는 대신 `vi` 에디터를 직접 호출 합니다.
55. `xpg_echo` 옵션이 켜져있다면, Bash는 `echo`의 모든 인수를 옵션으로 인식하지 않습니다. 각 인수는 이스케이프 문자 변환이 이루어진 뒤 출력됩니다.
56. `ulimit` 빌트인은 `-c`와 `-f` 옵션의 블럭 사이즈 단위로 512바이트를 사용합니다.
57. `SIGCHLD`에 트랩이 설정되어 있을 때, `SIGCHLD`를 수신하더라도 `wait` 빌트인에 끼어들어서 즉시 반환하지 않습니다. 트랩 명령어는 각 자식이 종료한 후에 한번만 실행됩니다.
58. 트랩이 설정된 시그널은 `read` 빌트인에 끼어들 수 있습니다. Bash가 `read`를 실행하는 중에 트랩이 설정된 시그널을 수신하면, 트랩 핸들러가 실행되며 `read`는 128보다 큰 종료 스테이터스와 함께 반환됩니다.
59. Bash는 `wait` 빌트인이 종료된 백그라운드 프로세스의 스테이터스의 값을 얻어간 후 이러한 스테이터스의 리스트로부터 해당 값을 제거합니다.

POSIX 모드에서도 기본으로 구현하지 않는 POSIX 동작이 있습니다. 특히 다음 두 가지입니다.

1. `fc` 빌트인은 `FCEDIT`이 없다면, 기본값인 `ed`를 곧바로 사용하기 보다는 `$EDITOR`를 이력를 편집하기 위해 사용할 수 있는지 확인합니다. `fc`는 `EDITOR`가 없다면 `ed`를 사용합니다.
2. 위에서 언급했듯, Bash는 `echo` 빌트인의 완전한 호환성을 위해서 `xpg_echo` 옵션을 켜기를 요구합니다.

Bash는 빌드시에 `configure`에 `--enable-strict-posix-default`를 지정하여 기본 설정으로 POSIX 호환성을 가지도록 설정할 수 있습니다(Optional Features를 참조).

## 6.12 Shell Compatibility Mode
bash-4.0은 '셸 호환성 레벨'이라는 개념을 도입했습니다. 이는 shopt 빌트인의 옵션 집합(`compat31`, `compat32`, `compat40`, `compat41` 등)으로 지정됩니다. 한번에 하나의 호환성 레벨만 지정할 수 있습니다. 각 옵션은 상호 배타적입니다. 호환성 레벨은 사용자에게 현재 기능과 동작을 사용하도록 스크립트를 갱신하는 동안 새 버전에서는 호환되지 않는 이전 버전의 행동을 선택할 수 있도록 합니다. 이는 일시적인 해결책으로 사용하는 것을 목적으로 합니다.

이 섹션에서는 각 버전의 표준 동작(e.g., `compat32`를 설정하면 정규 표현식 일치 연산자의 오른쪽 피연산자를 따옴표로 감싸면 단어에 포함되어 있는 특수 정규 표현식 문자도 보존합니다. 이는 bash-3.2 이상일 경우의 기본 동작입니다)에 대해서는 설명하지 않습니다.

사용자가 어떤 버전, 예를 들어, `compat32`를 설정했다면, 이는 현재의 호환성 레벨을 포함해 이보다 높은 호환성 레벨의 동작에 영향을 줄 수 있습니다. 각 호환성 레벨은 해당 버전의 Bash가 변경한 동작을 제어합니다만, 변경한 동작은 이전 버전에서 사용하고 있었을 수도 있기 때문입니다. 예를 들어, bash-4.1에서 `[[` 명령어는 로케일 기반 비교를 하도록 변경되었고, 이전 버전은 ASCII 기반 비교를 합니다. 그러므로 `compat32`를 설정하면 ASCII 기반 비교도 유효화합니다. 이 단위의 변경은 모든 용도에 맞지는 않으므로 호환성 레벨은 신중하게 선택해야 합니다.

bash-4.3은 새 셸 변수 `BASH_COMPAT`을 도입했습니다. 이 변수에 대입한 값(4.2처럼 10진수로 표현된 버전 숫자, 또는 42처럼 compat*NN* 옵션에 대응하는 숫자)이 호환성 레벨을 결정합니다.

bash-4.4부터 Bash는 오래된 호환성 레벨에 대한 지원을 중단하기 시작했습니다. 최종적으로 해당 옵션들은 제거되고 `BASH_COMPAT`으로 대체될 것입니다.

bash-5.0은 이전 버전에 대한 개별 shopt 옵션을 제공하는 마지막 버전입니다. bash-5.0와 그 이후의 버전에서는 `BASH_COMPAT`을 사용해야 합니다.

다음 표는 각 호환성 레벨 설정에 의해 제어되는 동작 변경에 대해서 설명합니다. compat*NN* 태그는 다음중 하나의 방법을 사용하여 호환성 레벨을 *NN*으로 설정하는 축약어로 사용됩니다. bash-5.0 이전 버전은 각 호환성 레벨에 대응하는 compat*NN* shopt 옵션을 사용하여 설정합니다. bash-4.3과 그 이후의 버전에서는 `BASH_COMPAT` 변수를 사용하는 것이 권장되며, 이는 bash-5.1과 그 이후의 버전에서는 필수입니다.

**compat31**
- `[[` 명령어의 정규 표현식 일치 연산자(`=~`)의 오른쪽 피연산자를 따옴표로 감싸도 효과가 없습니다.

**compat32**
- "a ; b ; c"와 같은 명령어 리스트에 끼어들면, 리스트의 다음 명령어를 실행하게 됩니다(bash-4.0과 그 이후 버전에서는 끼어들기를 당한 것처럼 동작하므로, 리스트의 한 명령어에 끼어들기가 발생하면 전체 리스트의 실행을 중지합니다).

**compat40**
- `[[` 명령어에서 '<'와 '>' 연산자는 문자열을 비교할 때 현재 로케일을 고려하지 않으며, ASCII 순서를 사용합니다. bash-4.1보다 이전의 Bash 버전에서는 ASCII 대조순과 strcmp(3)을 사용합니다. bash-4.1과 그 이후의 버전에서는 현재 로케일의 대조순과 strcoll(3)을 사용합니다.

**compat41**
- POSIX 모드에서 `time`에 옵션을 넘기더라도 여전히 예약어로 취급됩니다(POSIX interpretation 267입니다).
- POSIX 모드에서 파서는 큰따옴표로 감싼 `${…}` 매개변수 전개의 단어에서 작은따옴표가 짝수개 요구하며, 작은따옴표 사이에 있는 문자를 모두 감싼 것처럼 처리합니다(이는 POSIX interpretation 221입니다).

**compat42**
- 큰따옴표 패턴 치환의 대체 문자열에는 따옴표 제거가 적용되지 않습니다. bash-4.2 이후의 버전에서는 적용됩니다.
- POSIX 모드에서 큰따옴표로 감싼 `${…}` 매개변수 전개의 단어에서 작은따옴표를 특수하게 취급하며, 이는 닫는 중괄호나 다른 특수 문자를 감쌀 때 사용할 수 있습니다(이는 POSIX interpretation 221입니다). 이후의 버전에서 작은따옴표는 큰따옴표로 감싼 단어 전개에서 특별한 취급을 받지 않습니다.

**compat43**
- 셸은 declare(declare -a foo='(1 2)')의 인수로 따옴표로 감싼 복합 대입을 사용할 때 경고 메시지를 출력하지 않습니다. 이후의 버전은 이 사용법에 대한 지원이 중단되었음을 경고합니다.
- 단어 전개 에러를 현재 명령어가 실패하는 치명적인 에러로 다루지 않습니다. 이는 POSIX 모드에서도 마찬가지입니다(기본 동작은 이들을 치명적인 에러로 처리해 셸을 종료시키는 것입니다).
- 셸 함수를 실행할 때, 반복 상태(while/until/etc.)는 초기화하지 않습니다. 그러므로 함수 내에서 `break`나 `continue`를 사용하면 호출된 컨텍스트에서 루프를 중지하거나 다음 루프를 계속합니다. bash-4.4와 그 이후 버전은 이를 방지하기 위해 반복 상태를 초기화합니다.

**compat44**
- 셸은 `BASH_ARGV`와 `BASH_ARGC`에서 사용된 값을 이용하여 확장된 디버깅 모드가 켜져있지 않더라도 이 값들이 셸의 위치 매개변수로 전개됩니다.
- 서브셸은 부모 컨텍스트로부터 루프를 상속합니다. 그러므로 `break`나 `continue`는 서브셸을 종료시킬 수 있습니다. bash-5.0과 그 이후의 버전에서는 종료를 막기 위해 반복 상태를 초기화합니다.
- `export`와 `readonly`와 같이 속성을 설정하는 빌트인 앞의 변수 대입은 POSIX 모드가 아니라고 하더라도 호출 환경에 있는 같은 이름의 변수로 계속해서 사용할 수 있습니다.

**compat50 (BASH_COMPAT으로 설정)**
- bash-5.1은 임의성을 높이기 위해 `$RANDOM`이 생성되는 방식을 변경했습니다. 셸 호환성 레벨이 50이나 이보다 작다면, bash-5.0과 그 이전 버전의 방법을 사용하도록 되돌립니다. 그러면 `RANDOM` 변수에 값을 대입하여 난수 생성기에 시드를 설정하면 bash-5.0과 동일한 난수 나열을 생성합니다.
- 명령어 해시 테이블이 비어있다면 bash-5.1 이전의 Bash 버전에서는 입력으로 재활용한 가능한 출력을 생성해야하는 경우에도 이 정보를 알려주는 메시지를 출력했습니다. bash-5.1은 `-l` 옵션을 넘긴 경우 이 메시지를 출력하지 않습니다.

# 7. Job Control
이 장에서는 잡 컨트롤이 무엇인지, 어떻게 동작하는지, Bash가 어떻게 이 기능에 접근할 수 있게 해주는지 알아봅니다.

- Job Control Basics : 잡 컨트롤은 어떻게 동작하는가.
- Job Control Builtins : 잡 컨트롤과 상호작용하기 위해서 사용하는 Bash 빌트인 명령어.
- Job Control Variables : Bash가 잡 컨트롤을 커스터마이즈하기 위해서 사용하는 변수.

## 7.1 Job Control Basics
잡 컨트롤은 선택적으로 프로새스의 실행을 일시정지하거나 나중에 실행을 재개할 수 있도록 하는 기능을 가리킵니다. 유저는 일반적으로 운영체제의 터미널 드라이버와 Bash가 함께 제공하는 인터랙티브 인터페이스를 통해 이 기능을 사용합니다.

셸은 *잡*을 각 파이프라인과 연결합니다. 이를 통해 현재 실행중인 잡들의 목록을 유지하며, 이는 `jobs` 명령어로 출력할 수 있습니다. Bash는 잡을 비동기로 시작할 수 있으며 다음과 같은 줄을 출력합니다.

```sh
[1] 25647
```

이 출력은 이 잡의 잡 번호는 1번이고, 이 잡과 연결된 파이프라인의 마지막 프로세스의 프로세스 ID는 25647임을 의미합니다. 단일 파이프라인의 모든 프로세스는 동일한 잡의 구성원입니다. Bash는 잡 컨트롤의 기반으로 *잡* 추상화를 사용합니다.

잡 컨트롤을 다루는 유저 인터페이스를 다루기 쉽게 만들기 위해 운영체제는 현재 터미널 프로세스 그룹 ID라는 개념을 관리합니다. 이 프로세스 그룹의 구성원(현재 터미널 프로세스 그룹 ID와 동일한 프로세스 그룹 ID를 가지고 있는 프로세스)은 키보드로부터 생성된 `SIGINT`와 같은 시그널을 수신합니다. 이 프로세스들을 포어그라운드라고 부릅니다. 백그라운드 프로세스는 터미널의 프로세스 그룹 ID와 다른 프로세스 그룹 ID를 가지고 있습니다. 이러한 프로세스들은 키보드로부터 생성된 시그널을 무시합니다. 포어그라운드 프로세스만이 터미널을 읽거나 (`stty tostop`을 지정했다면) 터미널로 쓸 수 있습니다. 백그라운드 프로세스가 터미널을 읽으려고 (또는 `stty tostop`을 지정했을 때 쓰려고) 시도하면 커널의 터미널 드라이버로부터 `SIGTTIN`(`SIGTTOU`)시그널이 전송됩니다. 만약 이를 처리하지 않는다면 프로세스를 중단합니다.

Bash가 동작하고 있는 운영체제가 잡 컨트롤을 지원하면 Bash는 이를 사용하기 위한 기능을 유지합니다. 프로세스를 실행하는 중에 *suspend* 문자(일반적으로 '^z', Control-Z)를 입력하면 이 프로세스를 중단하고 Bash로 제어를 반환합니다. *delayed suspend* 문자(일반적으로 '^Y', Control-Y)를 입력하면 프로세스가 터미널로부터 입력을 받으려고 시도할 때 중단되며 Bash로 제어를 반환합니다. 그러면 사용자는 이 잡의 상태를 `bg` 명령어를 사용해서 백그라운드에서 실행을 재개하거나 `fg` 명령어로 포어그라운드에서 실행을 재개하거나 `kill` 명령어로 종료하는 조작을 할 수 있습니다. '^Z'는 즉시 실행되며 출력을 중단하고 입력중인 텍스트를 버리는 추가 부작용이 있습니다.

셸에서 잡을 참조하는 방법은 여러가지가 있습니다. '%' 문자는 잡 명세(*jobspec*)를 가리킵니다.

잡 번호 *n*은 '%n'으로 참조될 수 있습니다. '%%' 와 '%+' 기호는 셸의 현재 잡을 가리키며, 이는 포어그라운드에 있는 동안 정지했거나 백그라운드에서 시작된 마지막 잡입니다. (뒤따라오는 잡 명세가 없는) 단일 '%' 역시 현재 잡을 참조합니다. 이전 잡은 '%-'로 참조될 수 있습니다. 잡이 단 하나만 존재한다면, '%+'와 '%-'는 모두 해당 잡을 참조할 때 사용할 수 있습니다. 잡에 관한 출력(e.g., `jobs` 명령어의 출력)에서 현재 잡은 언제나 '+' 플래그를 가지며, 이전 잡은 '-'를 가집니다.

잡은 시작할 때 사용한 이름의 접두사 또는 그 커맨드 라인에서 나타나는 부문 문자열을 사용해서 참조할 수도 있습니다. 예를 들어 '%ce'는 명령어 이름이 'ce'로 시작하는 중단된 잡을 참조합니다. 한편 '%?ce'를 사용하면 잡의 커맨드 라인에 문자열 'ce'를 포함하는 어떤 잡을 참조합니다. 만약 접두사 또는 접미사가 2개 이상의 잡과 일치하면 Bash는 에러를 보고합니다.

단순히 잡에 이름을 지정해서 이를 포어그라운드로 가져올 수도 있습니다. '%1'는 'fg %1'와 동의어이며, 잡 1번을 백그라운드에서 포어그라운드로 가져옵니다. 비슷하게 '%1 &'는 잡 1번을 백그라운드에서 재개하며 이는 'bg %1'과 동일합니다.

셸은 잡의 상태가 변경되면 즉시 이를 이해합니다. 일반적으로 Bash는 다른 출력을 중단하지 않도록 잡의 상태 변경을 보고하기 전에 프롬프트의 출력 직전까지 기다립니다. `set` 빌트인으로 `-b` 옵션을 켰다면 Bash는 이러한 변경을 즉시 보고합니다(The Set Builtin을 참조). `SIGCHLD`에 설정된 트랩은 각 자식 프로세스가 종료될 때 실행됩니다.

잡이 중단된 상태(또는 `checkjobs` 옵션이 켜져있다면 실행중일때. The Shopt Builtin을 참조)에서 Bash를 종료하려고 시도하면 셸은 경고 메시지를 출력하며 `checkjobs` 옵션이 켜져있다면 잡과 잡의 상태 리스트를 출력합니다. 잡의 상태를 확인하기 위해서 `jobs` 명령어를 사용할 수도 있습니다. 뒤이어서 바로 두번째 종료 시도를 하면, Bash는 다른 경고를 출력하지 않으며 중단된 잡을 모두 종료합니다.

셸이 잡이나 프로세스를 `wait` 빌트인을 사용하여 기다리고 있을 때, 잡 컨트롤이 켜져 있다면 `wait`는 잡의 상태가 변경될 때 반환됩니다. `-f` 옵션을 사용하면 `wait`가 반환되기 전에 잡이나 프로세스의 종료를 기다립니다.

## 7.2 Job Control Builtins
**bg**
```sh
bg [jobspec …]
```
중단된 잡 *jobspec*을 '&'로 실행한 것처럼 백그라운드에서 재개합니다. *jobspec*을 넘기지 않았다면, 현재 잡이 사용됩니다. 잡 컨트롤 기능이 켜져있지 않거나, 기능이 켜져 있지만 지정한 *jobspec*을 찾을 수 없거나 지정된 잡이 잡 컨트롤 기능을 사용하지 않고 시작한 경우를 제외하면 종료 스테이터스는 0입니다.

**fg**
```sh
fg [jobspec]
```
잡 *jobspec*을 포어그라운드에서 재개하고 현재 잡으로 변경합니다. *jobspec*을 넘기지 않았다면, 현재 잡이 사용됩니다. 반환 스테이터스는 포어그라운드로 가져온 명령어의 반환 스테이터스가 됩니다. 또는 잡 컨트롤 기능이 켜지 않았거나 기능이 켜져 있지만 *jobspec*이 유효한 잡을 지정하지 않거나 *jobspec*이 잡 컨트롤 기능을 사용하지 않고 시작한 경우에는 0이 아닌 값을 반환합니다.

**jobs**
```sh
jobs [-lnprs] [jobspec]
jobs -x command [arguments]
```
첫번째 형식은 살아있는 잡 리스트를 출력합니다. 옵션은 다음의 의미를 가집니다.

- **-l**
  기본 정보에 프로세스 ID를 추가로 출력합니다.
- **-n**
  유저가 상태에 대한 정보를 받은 이후로 상태가 변경된 잡에 관한 정보만 출력합니다.
- **-p**
  잡의 프로세스 그룹 리더의 프로세스 ID만을 출력합니다.
- **-r**
  실행중인 잡만 출력합니다.
- **-s**
  중단중인 잡만 출력합니다.

*jobspec*을 넘기면 대상 잡의 정보만 출력합니다. *jobspec*을 넘기지 않으면 모든 잡의 상태를 출력합니다.

`-x` 옵션을 넘기면 `jobs`는 *command*나 *arguments*로 발견한 *jobspec*을 대응하는 프로세스 그룹 ID로 대체한 뒤, *command*를 실행하고, *arguments*를 인수로 넘긴 뒤, 그 종료 스테이터스를 반환합니다.

**kill**
```sh
kill [-s sigspec] [-n signum] [-sigspec] jobspec or pid
kill -l|-L [exit_status]
```
*sigspec*이나 *signum*으로 지정한 신호를 잡 명세 *jobspec* 또는 프로세스 ID *pid*로 지정되는 프로세스로 전송합니다. *sigspec*은 `SIGINT`와 같은 대소문자를 구분하지 않는 시그널 이름(`SIG` 접두사 없이 지정할 수 있습니다) 또는 시그널 번호입니다. *signum*은 시그널 번호입니다. *sigspec*과 *signum*이 둘 다 존재하지 않는다면 `SIGTERM`이 사용됩니다. `-l` 옵션은 시그널 이름을 나열합니다. `-l` 옵션을 넘길 때 다른 인수를 넘겼다면 해당 인수에 대응되는 신호 이름 리스트를 출력하고 반환 스테이터스는 0이 됩니다. *exit_status*는 시그널 번호 또는 시그널에 의해 종료되는 프로세스의 종료 스테이터스를 지정하는 숫자입니다.`-L` 옵션은 `-l`과 동일합니다. 적어도 하나의 시그널이 성공적으로 전송되면 반환 스테이터스는 0이며, 에러가 발생하거나 잘못된 옵션을 넘겨받았다면 0이 아닌 값입니다.

**wait**
```sh
wait [-fn] [-p varname] [jobspec or pid …]
```
각 프로세스 ID *pid*나 잡 명세 *jobspec*로 지정된 자식 프로세스의 종료를 기다리고 기다린 마지막 명령어의 종료 스테이터스를 반환합니다. 잡 명를 넘겼다면 잡의 모든 프로세스가 끝나길 기다립니다. 인수를 넘기지 않았다면 `wait`은 실행중인 모든 백그라운드 잡, 그리고 자신의 프로세스 아이디가 *$!*와 같다면 마지막으로 실행된 프로세스 치환을 기다리며 반환 스테이터스는 0입니다. `-n` 옵션을 넘겼다면 `wait`은 `pid` 목록이나 `jobspec` 목록으로부터 하나의 잡 또는 인수가 없다면 어떤 잡이든 하나가 끝나기를 기다리고 그 종료 스테이터스를 반환합니다. 넘겨받은 인수가 셸의 자식이 아니거나 인수를 넘기지 않고 셸이 기다릴 수 있는 자식이 없는 경우 종료 스테이터스는 127입니다. `-p` 옵션을 넘겨받았다면 프로세스나 잡의 잡 식별자가 반환한 종료 스테이터스를 옵션 인수로 지정한 변수 *varname*에 대입합니다. 변수에 대입을 하기 전에 초기화가 발생합니다. 이는 `-n` 옵션만을 사용했을 경우 유용합니다. 잡 컨트롤 기능이 켜져있을 때 `-f` 옵션을 넘겨받았다면 `wait`는 상태가 변경되는 때에 반환되지 않고, 각 *pid*나 *jobspec*이 각자의 스테이터스를 반환하기 전에 종료하기를 기다립니다. *jobspec*과 *pid*가 모두 셸의 살아있는 자식 프로세스를 지정하지 않는다면 반환 스테이터스는 127입니다.

**disown**
```sh
disown [-ar] [-h] [jobspec … | pid … ]
```
옵션없이 사용하면 각 *jobspec*을 살아있는 잡 리스트로부터 제거합니다. `-h` 옵션을 넘겨받았다면 잡은 리스트에서 제거되지 않고, 셸이 `SIGHUP`을 받았을 때 `SIGHUP`을 전파하지 않도록 표시합니다. *jobspec*이 없고 `-a`와 `-r` 옵션을 사용하지 않았다면 현재 잡이 사용됩니다. *jobspec*을 넘기지 않는다면 `-a` 옵션은 모든 잡을 제거하거나 표시하라는 의미입니다. *jobspec*을 넘기지 않는다면 `-r` 옵션은 실행중인 잡에게 동작을 적용합니다.

**suspend**
```sh
suspend [-f]
```
`SIGCONT` 시그널을 받을 때까지 현재 셸의 실행을 중단합니다. 로그인 셸은 중단할 수 없습니다. `-f` 옵션은 이를 덮어쓰고 중단을 강제할 수 있습니다.

잡 컨트롤 기능이 켜져있지 않다면, `kill`과 `wait` 빌트인은 *jobspec* 인수를 받지 않습니다. 반드시 프로세스 ID를 넘겨야 합니다.

## 7.3 Job Control Variables
**auto_resume**
이 변수는 셸이 유저와 잡 컨트롤과 어떻게 상호작용할지 제어합니다. 이 변수가 존재한다면 리다이렉션이 없고 한 단어로 구성된 단순 명령어는 존재하고 있는 잡의 재개 후보로 취급됩니다. 여기에서는 모호함이 금지됩니다. 입력된 문자열로 시작하는 잡이 하나 이상 존재하면 가장 최근에 접근한 잡이 선택됩니다. 이 컨텍스트에서 중단된 잡의 이름이란 해당 잡을 시작하기 위해 사용한 커맨드 라인을 가리킵니다. 이 변수에 'exact'라는 값이 설정되어 있다면 넘긴 문자열은 중단된 잡의 이름과 정확히 일치해야 합니다. 'substring'이라면 넘긴 문자열은 중단된 잡의 이름의 부분 문자열과 일치해야합니다. 'substring' 값은 '%?' 잡 ID와 유사한 기능을 제공합니다(Job Control Basics를 참조). 그 이외의 값으로 설정하면 제공된 문자열은 중단된 잡의 이름의 접두사여야 합니다. 이 동작은 '%' 잡 ID와 유사한 기능을 제공합니다.

# 8. Command Line Editing
이 장에서는 GNU 커맨드 라인 편집 인터페이스의 기본적인 기능에 대해서 설명합니다. 커맨드 라인 편집은 Readline 라이브러리가 제공하며, 이는 Bash를 포함해 다른 여러 프로그램에서도 사용됩니다. 커맨드 라인 편집 기능은 인터랙티브 셸이라면 기본 설정으로 켜져있습니다. 단, 셸 호출시에 `--noediting`  옵션을 넘긴 경우는 예외입니다. `read` 빌트인 명령어(Bash Builtins를 참조)에 `-e` 옵션을 넘겼을 때에도 줄 편집이 사용됩니다. 기본 설정으로, 줄 편집 명령어는 Emacs의 그것과 유사합니다. vi 스타일의 줄 편집 인터페이스도 사용 가능합니다. 줄 편집 기능은 `set` 빌트인 명령어 `-o emacs`나 `-o vi` 옵션을 넘기면(The Set Builtin을 참조) 언제든지 켤 수 있습니다. 또는 끄기 위해서 `set`에 `+o emacs`나 `+o vi` 옵션을 넘길 수 있습니다.

- Introduction and Notation : 이 텍스트에서 사용되는 표기법.
- Readline Interaction : 줄 편집에서 사용되는 최소한의 명령어 집합.
- Readline Init File : 유저의 시점에서 Readline을 커스터마이즈하기.
- Bindable Readline Commands : Readline 명령어에서 바인딩에 사용가능한 거의 모든 설명.
- Readline vi Mode : Readline을 vi 에디터처럼 동작하게 만드는 방법에 대한 간략한 설명
- Programmable Completion : 특정 명령어를 위한 완성 후보를 식별하는 방법.
- Programmable Completion Builtins : 개별 명령어의 인수를 완성하는 방법을 식별하기 위한 빌트인 명령어.
- A Programmable Completion Example : 완성 후보를 생성하는 셸 함수 예제.

## 8.1 Introduction and Notation
다음 절에서는 키 입력을 표현하기 위해 사용하는 표기법에 대해서 설명합니다.

텍스트 *C-k*는 'Control-K'로 읽으며 Control 키를 누른 상태에서 `k` 키를 눌렀을 때 생성되는 문자를 가리킵니다.

텍스트 *M-k*는 'Meta-K'로 읽으며 메타 키(만약 존재한다면)를 누른 상태에서 `k` 키를 눌렀을 때 생성되는 문자를 가리킵니다. 메타 키는 많은 키보드에서 `ALT`라는 이름이 붙어있습니다. 키보드에는 2개의 키에 `ALT`라는 이름이 붙어 있으며(보통 스페이스 바의 양 끝에 위치합니다), 일반적으로는 왼쪽의 `ALT`가 메타 키로 동작하도록 설정되어 있습니다. 오른쪽의 `ALT` 키 역시 메타 키로 동작하도록 설정되어 있거나 악센트 문자를 입력하기 위한 컴포즈 키와 같은 다른 수식키로 설정되어 있을 수 있습니다.

메타 키나 `ALT` 키, 또는 메타 키로 동작하는 다른 키가 없다면 동일한 키입력을 먼저 `ESC`를 누르고, 이후에 `k`를 누르는 것으로 생성할 수 있습니다. 이 방식을 `k` 키를 메타화한다고 말합니다(metafying the k key).

텍스트 *M-C-k*는 'Meta-Control-k'로 읽으며 *C-k*를 메타화해서 생성하는 문자입니다.

나아가, 여러 키들은 각각 자신의 이름을 가지고 있습니다. 특히 `DEL`, `ESC`, `LFD`, `SPC`, `RET`, `TAB`은 여기 설명 또는 초기화 파일(Readline Init File을 참조)에서 나왔을 때, 그 자신을 상징합니다. 키보드에 `LFD` 키가 없다면 `C-j`를 입력하면 원하는 문자를 생성할 수 있습니다. `RET` 키는 몇몇 키보드에서 `Return` 또는 `Enter`라는 이름이 붙어있습니다.

## 8.2 Readline Interaction
인터랙티브 세션에서 긴 텍스트를 입력하는 동안 줄의 첫 번째 단어가 틀렸다는 것을 발견할 때가 자주 있습니다. Readline 라이브러리는 입력중인 텍스트를 조작할 수 있는 명령어 집합을 제공하고 있으며 줄 전체를 다시 입력할 필요 없이 오탈자만 고칠 수 있도록 해줍니다. 편집 명령어를 사용해서 커서를 수정이 필요한 곳에 이동시키고 수정할 텍스트를 지우거나 추가할 수 있습니다. 그리고 문제 없음을 확인했을 때 그저 `RET`를 누르면 됩니다. 줄의 끝으로 이동해서 `RET`을 누를 필요는 없습니다. 줄 내부에 있는 커서의 위치에 관계 없이 전체 줄이 처리됩니다.

- Readline Bare Essentials : Readline에 대해서 알아야 할 최소한의 정보.
- Readline Movement Commands : 입력 줄에서 움직이기.
- Readline Killing Commands : 텍스트를 지우고 복구하는 방법.
- Readline Arguments : 명령어에 숫자 인수를 넘기기.
- Searching for Commands in the History : 이전 줄들을 통해 검색하기.

### 8.2.1 Readline Bare Essentials
문자를 줄에 입력하기 위해서는 해당 키를 누르면 됩니다. 누른 문자는 커서가 있었던 위치에 나타나며 커서는 스페이스 하나 크기만큼 오른쪽으로 이동합니다. 문자를 잘못 입력했다면 지우기 문자로 잘못 입력한 문자를 백업하고 지울 수 있습니다.

잘못 입력하고 한참 뒤에 실수를 눈치챌 때가 있습니다. 이 경우에는 *C-b*를 눌러서 커서를 왼쪽으로 이동시킨 뒤 실수를 고칠 수 있습니다. 그리고나서 *C-f*로 오른쪽으로 커서를 이동시킬 수 있습니다.

줄의 가운데에 텍스트를 추가할 때, 커서의 오른편에 있는 문자들이 새로 입력할 문자를 위해 '밀려나는' 것을 볼 수 있습니다. 마찬가지로 커서 뒤에 있는 텍스트를 지울 때 커서 오른편에 있는 문자들이 텍스트 삭제로 발생한 빈 공간을 채우듯이 '당겨집니다'. 다음은 입력 줄의 텍스트를 수정할 때 필요한 것들입니다.

***C-b***
한 문자 뒤로 이동합니다.

***C-f***
한 문자 앞으로 이동합니다.

**DEL 또는 Backspace**
커서 왼쪽의 문자를 지웁니다.

***C-d***
커서가 위치해 있는 문자를 지웁니다.

**Printing characters**
줄의 커서 위치에 문자를 추가합니다.

***C-_* 또는 *C-x* *C-u***
마지막 편집 명령어 실행 결과를 되돌립니다. 빈 줄이 될 때까지 되돌릴 수 있습니다.

(설정에 따라서 `Backspace` 키는 커서의 왼쪽에 있는 문자를 제거하고, `DEL` 키가 커서 왼쪽에 있는 문자 대신 *C-d* 처럼 커서에 위치한 문자를 제거하도록 설정되었을 수 있습니다.)

### 8.2.2 Readline Movement Commands
위에서는 입력 줄 편집에 필요한 가장 기본적인 키입력을 설명했습니다. 편리함을 위해 *C-b*, *C-f*, *C-d*, `DEL` 이외에도 다른 많은 명령어가 추가되어 있습니다. 여기에서는 줄에서 더 빠르게 움직일 수 있는 명령어를 설명합니다.

***C-a***
줄의 시작 부분으로 이동합니다.

***C-e***
줄의 끝 부분으로 이동합니다.

***M-f***
한 단어 앞으로 이동합니다. 한 단어는 영문자와 숫자로 구성됩니다.

***M-b***
한 단어 뒤로 이동합니다.

***C-l***
화면을 지우고 현재 줄을 맨 위에 표시합니다.

*M-f*는 한 단어 앞으로 이동하는 반면 *C-f*가 가 한 글자 앞으로 이동한다는 점을 주목하세요. 메타 키입력은 단어에 대해서 동작하고 컨트롤 키입력은 문자에 대해서 동작하는 약한 규칙이 있습니다.

### 8.2.3 Readline Killing Commands
텍스트를 *잘라낸다*(*kill*)는 것은 줄에서 텍스트를 지우고 나중에 사용하기 위해서 저장해두는 것을 의미합니다. 이는 보통 재삽입(*yanking*)으로 줄에 돌아옵니다. ('자르기'와 '붙여넣기'는 'kill'과 'yank'의 최신 용어입니다.)

명령어의 설명에 텍스트를 잘라낸다고 적혀있다면, 지운 텍스트를 나중에 다른 장소(또는 같은 장소)에서 가져올 수 있다고 확신할 수 있습니다.

잘라내기 명령을 사용할 때, 텍스트는 *kill-ring*에 저장됩니다. 연속되는 잘라내기는 잘라낸 텍스트를 전부 함께 저장하므로 나중에 재삽입할 때 전부를 얻을 수 있습니다. 킬 링은 줄에 제한되지 않습니다. 이전 입력한 줄에서 잘라낸 텍스트는 다른 라인을 타이핑 할 때에도 재삽입할 수 있습니다.

다음은 텍스트를 잘라내는 명령어 일람입니다.

***C-k***
현재 커서 위치부터 줄 끝까지의 텍스트를 잘라냅니다.

***M-d***
커서 위치부터 현재 단어의 끝까지 또는 커서가 단어 사이에 있다면 다음 단어의 끝까지 잘라냅니다. 단어 경계는 *M-f*에서 사용된 규칙과 동일합니다.

***M-DEL***
커서 위치부터 현재 단어의 시작부분까지 또는 커서가 단어 사이에 있다면 직전 단어의 시작 부분까지 잘라냅니다. 단어 경계는 *M-b*에서 사용된 규칙과 동일합니다.

***C-w***
커서 위치부터 이전 공백까지 잘라냅니다. 이는 단어 경계가 다르기 때문에 *M-DEL*과 다르게 동작합니다.

다음은 줄에 텍스트를 재삽입하는 방법입니다. 재삽입은 킬 버퍼로부터 가장 최근에 잘라낸 텍스트를 복사하는 동작을 의미합니다.

***C-y***
버퍼에 들어있는 가장 최근에 잘라낸 텍스트를 커서 위치에 재삽입합니다.

***M-y***
킬 링을 순환시키고 새 최상위 값을 재삽입합니다. 직전 명령어가 *C-y* 또는 *M-y*일때만 실행할 수 있습니다.

### 8.2.4 Readline Arguments
Readline 명령어에 숫자 인수를 넘길 수도 있습니다. 인수는 반복 횟수로 동작하거나 인수의 *부호*로 동작할 때도 있습니다. 일반적으로 순방향으로 동작하는 명령어에 음의 인수를 넘기면 명령어는 역방향으로 동작합니다. 예를 들어, 커서로부터 텍스트의 시작 부분까지를 잘라내고 싶다면 'M-- C-k'를 타이핑합니다.

명령어에 숫자 인수를 넘기는 일반적인 방법은 명령어 전에 메타 숫자를 타이핑하는 것입니다. 첫번째로 입력할 숫자가 마이너스 기호('-')라면, 인수의 부호는 마이너스가 됩니다. 인수를 시작할 때 메타 숫자를 한번 입력하면 숫자의 나머지를 입력할 수 있고, 그 후에 명령어를 입력할 수 있습니다. 예를 들어 *C-d* 명령어의 인수로 10을 넘기고 싶다면 'M-1 0 C-d'를 타이핑하세요. 이는 입력 줄에서 다음 문자 10개를 지웁니다.

### 8.2.5 Searching for Commands in the History
Readline은 줄에 포함되어 있는 어떤 문자열로 명령어 이력(Bash History Facilities를 참조)을 검색할 수 있는 명령어를 제공합니다. 두 가지 검색 모드가 있습니다. 증분 검색과 비-증분 검색.

증분 검색은 유저가 검색 문자열을 타이핑 완료하기 전부터 검색을 시작합니다. 검색 문자열의 각 문자가 타이핑 될 때마다 Readline은 이력으로부터 타이핑된 문자열에 일치하는 다음 이력을 보여줍니다. 증분 검색은 원하는 이력을 발견하는데 필요한 만큼의 문자 수를 요구합니다. 이력에서 특정 문자열을 후방 검색하기 위해서는 *C-r*을 입력하세요. *C-s*를 입력하면 이력을 전방 검색합니다. `isearch-terminators` 변수의 값에 포함된 문자는 증분 검색을 종료할 때 사용합니다. 해당 변수에 값이 대입되어 있지 않다면, `ESC`와 *C-J* 문자로 증분 검색을 종료합니다. *C-g*는 증분 검색을 취소하고 원래 줄을 복구합니다. 검색이 종료될 때 검색 문자열을 포함하는 이력은 현재 줄이 됩니다.

이력 리스트로부터 다른 일치하는 이력을 찾으려면 *C-r*이나 *C-s* 중 적절한 것을 타이핑하세요. 이는 입력한 검색 문자열과 그 다음으로 일치하는 이력을 후방 검색 또는 전방 검색으로 찾습니다. Readline 명령어에 바인딩한 다른 키 나열들은 검색을 종료하고 명령어를 실행합니다. 예를 들어 `RET`는 검색을 종료하고 줄을 처리하므로, 이력 리스트로부터 명령어를 실행합니다. 이동 명령어는 검색을 종료하고 발견한 마지막 줄을 현재 줄으로 변경한 뒤 편집을 시작합니다.

비-증분 검색은 일치하는 이력 줄을 검색하기 전에 전체 검색 문자열을 읽습니다. 검색 문자열은 유저가 입력하거나 현재 줄의 일부일 수 있습니다.

## 8.3 Readline Init File
Readline 라이브러리는 기본으로 설치되는 Emacs와 유사한 키 바인딩 집합과 동작함에도 불고하고 다른 키 바인딩 집합을 사용할 수도 있습니다. 유저는 명령어를 (관습적으로 홈 디렉터리에 존재하는) *inputrc* 파일에 추가하는 것으로 프로그램이 Readline을 사용하도록 커스터마이징할 수 있습니다. 이 파일의 이름은 셸 변수 `INPUTRC`로부터 얻습니다. 해당 변수가 설정되어있지 않다면, 기본값은 `~/.inputrc`입니다. 파일이 존재하지 않거나 읽을 수 없다면 최종 기본값은 `/etc/inputrc`입니다. `bind` 빌트인 명령어로 Readline 키 바인딩과 변수를 설정할 수 있습니다. Bash Builtins를 참조하세요.

Readline 라이브러리를 사용하는 프로그램이 시작할 때, 초기화 파일을 읽고 키 바인딩이 설정됩니다.

그리고 `C-x C-r` 명령어로 이 초기화 파일을 다시 읽을 수 있으므로, 변경을 바로 반영할 수 있습니다.

- Readline Init File Syntax : inputrc 파일에서의 명령어 문법.
- Conditional Init Constructs : inputrc 파일에서의 조건부 키 바인딩.
- Sample Init File : inputrc 파일 예제.

### 8.3.1 Readline Init File Syntax
Readline 초기화 파일에서는 몇몇 기본적인 구조만 사용할 수 있습니다. 빈 줄은 무시합니다. '#'로 시작하는 줄은 코멘트입니다. '$'로 시작하는 줄은 조건부 구조(Conditional Init Constructs를 참조)를 나타냅니다. 나머지 줄은 변수 설정과 키 바인딩입니다.

**변수 설정**

초기화 파일에서 `set` 명령어를 사용해 Readline의 변수 값을 변경하여 Readline의 런타임 동작을 변경할 수 있습니다. 문법은 단순합니다.

```sh
set variable value
```

다음은 기본 Emacs 키 바인딩 대신 `vi` 줄 편집 명령어를 사용하도록 변경하는 예제입니다.

```sh
set editing-mode vi
```

변수의 이름과 값은 올바르다면 대소문자 관계 없이 인식됩니다. 인식하지 못한 변수 이름은 무시됩니다.

불린 변수(켜거나 끌 수 있는 변수)는 값이 널, 비어있거나, *on*(대소문자 구별 없음), 1일 때 켜짐입니다. 그 이외의 값은 모두 변수를 꺼짐으로 취급합니다.

`bind -V` 명령어는 현재 Readline 변수 이름과 값을 나열합니다. Bash Builtins를 참조하세요.

런타임 동작의 많은 부분은 다음 변수로 변경할 수 있습니다.
- **bell-style**
  Readline이 터미널 벨을 울리고 싶을 때의 동작을 제어합니다. '`none`'라면 Readline은 벨을 울리지 않습니다. '`visible`'이라면 보이는 벨이 사용 가능하다면, Readline은 이를 사용합니다. '`audible`'(기본값)이라면 Readline은 터미널 벨을 울리려고 시도합니다.
- **bind-tty-special-chars**
  'on'(기본값)이라면 Readline은 커널의 터미널 드라이버에 의해서 특별취급되는 제어 문자를 Readline에서 동등한 문자로 바인딩하려 합니다.
- **blink-matching-paren**
  'on'이라면 Readline은 닫는 소괄호를 삽입했을 때 여는 괄호가 있는 위치로 커서를 이동시키려 합니다. 기본값은 'off'입니다.
- **colored-completion-prefix**
  'on'이라면 완성을 나열할 때, Readline은 완성 후보 집합의 공통 접두사를 다른 색으로 출력합니다. 색 정의는 `LS_COLORS` 환경 변수의 값을 참조합니다. 기본값은 'off'입니다.
- **colored-stats**
  'on'이라면, Readline은 완성 후보를 출력할 때 각각의 파일 타입에 따라 다른 색을 사용합니다. 색 정의는 `LS_COLORS` 환경 변수의값을 참조합니다. 기본값은 'off'입니다.
- **comment-begin**
  `insert-comment` 명령어가 실행되었을 때 줄의 첫 머리에 추가할 문자열. 기본값은 "#"입니다.
- **completion-display-width**
  완성을 실행할 때 일치 후보를 출력할 때 사용할 화면의 열(column) 개수. 0보다 작은 값이나 터미널 화면 너비보다 큰 값은 무시됩니다. 0은 일치 결과를 한 줄 전체를 써서 보여줍니다. 기본값은 -1입니다.
- **completion-ignore-case**
  'on'이라면 Readline은 파일명 일치와 완성을 실행할 때 대소문자를 구분하지 않습니다. 기본값은 'off'입니다.
- **completion-map-case**
  'on'이고 *completion-ignore-case*가 켜져있다면 Readline은 대소문자를 구분하지 않는 파일명 일치와 완성에서 하이픈('-')과 밑줄('_')을 같은 것으로 취급합니다. 기본값은 'off'입니다.
- **completion-prefix-display-length**
  수정 없이 보여줄 완성 후보 리스트의 공통 접두어의 길이. 0보다 큰 값을 지정하면 완성 후보를 보여줄 때 이 값보다 큰 공통 접두사는 생략 부호로 대체됩니다.
- **completion-query-items**
  유저가 완성 후보를 보여달라고 요구할 때 이를 보여줄지 말지 결정할 완성 후보 개수의 상한. 완성 후보의 개수가 이 값보다 크거나 같으면 Readline은 리스트를 보고 싶은지 묻습니다. 이 값보다 적은 경우 단순히 출력됩니다. 이 변수는 0이상의 정수 값을 설정해야 합니다. 음수는 Readline이 묻지 않도록 만듭니다. 기본 제한은 100입니다.
- **convert-meta**
  'on'이라면 Readline은 8비트 집합으로 된 문자들을 8번째 비트를 제거하고 `ESC` 문자를 앞에 끼워 넣어 메타 키로 시작하는 키 나열로 변환합니다. 기본값은 'on'이지만 로케일이 8비트 문자를 포함한다면 'off'가 됩니다.
- **disable-completion**
  'on'이라면 Readline은 단어 완성을 금지합니다. 완성 문자는 `self-insert`에 매핑된 것처럼 줄에 삽입됩니다. 기본값은 'off'입니다.
- **echo-control-characters**
  'on'으로 설정할 때, 운영체제가 지원한다면 Readline은 키보드가 생성한 시그널에 대응하는 문자를 출력합니다. 기본값은 'on'입니다.
- **editing-mode**
  `editing-mode` 변수는 어떤 키 바인딩 집합을 사용할지 제어합니다. 기본 설정에서 Readline은 Emacs와 사용법이 매우 유사한 Emacs 편집 모드로 시작합니다. 이 변수에는 'emacs'나 'vi'를 설정할 수 있습니다.
- **emacs-mode-string**
  *show-mode-in-prompt* 변수가 켜져있다면 emacs 편집 모드가 활성화되어 있을 때 주 프롬프트의 마지막 줄 앞에 이 문자열이 출력됩니다. 값은 키 바인딩처럼 전개되므로 메타 키, Control 키로 시작하는 표준 집합과 백슬래시 이스케이프 나열을 사용할 수 있습니다. '\\1'과 '\\2'로 출력 불가 문자 나열의 시작과 끝을 이스케이프할 수 있으며, 이는 터미널 제어 나열을 모드 문자열에 끼워넣을 때에도 사용할 수 있습니다. 기본값은 '@'입니다.
- **enable-bracketed-paste**
  'on'으로 설정할 때, Readline은 터미널에서 편집 버퍼에 문자열을 붙여넣을 때 키보드로부터 각 문자를 입력한 것처럼 취급하는 대신, 하나의 문자열로써 다루도록 만듭니다. 이는 붙여넣은 문자들이 편집 명령어로 해석되는 것을 방지합니다. 기본값은 'on'입니다.
- **enable-keypad**
  'on'으로 설정할 때, Readline은 애플리케이션 키패드를 호출할 때 이를 활성화하려고 시도합니다. 몇몇 시스템은 화살표 키를 활성화하기 위해서 이 기능이 필요합니다. 기본값은 'off'입니다. 
- **enable-meta-key**
  'on'으로 설정할 때, Readline이 호출되었을 때 터미널이 지원하고 있다고 주장하는 메타 수식 키를 유효화하려고 시도합니다. 많은 터미널에서 메타 키는 8비트 문자를 전송할 때 사용합니다. 기본값은 'on'입니다.
- **expand-tilde**
  'on'이라면 Readline이 단어 완성을 시도할 때 물결줄표 전개가 실행됩니다. 기본값은 'off'입니다.
- **history-preserve-point**
  'on'이라면 이력 코드는 점(현재 커서 위치)을 `previous-history`나 `next-history`로 가져온 각 이력 줄의 같은 위치에 옮기려고 시도합니다. 기본값은 'off'입니다.
- **history-size**
  이력 리스트에 저장하고 있는 이력의 최대 개수를 설정합니다. 0을 설정하면 존재하는 모든 이력이 제거되고 새 이력은 저장되지 않습니다. 0보다 작은 값을 설정하면 무제한으로 저장합니다. 이력 리스트에 저장할 최대 개수의 기본 설정은 무제한입니다. *history-size*에 숫자가 아닌 값을 설정하려고 시도하면 500이 설정됩니다.
- **horizontal-scroll-mode**
  이 변수는 'on' 또는 'off'를 설정할 수 있습니다. 'on'은 편집중인 줄의 텍스트가 화면의 너비보다 길어졌을 때 이를 새 줄로 감싸기보다 한 줄로 두고 수직 스크롤을 사용할 수 있도록 합니다. 이 변수는 터미널 높이가 1일 때 자동으로 'on'으로 변경됩니다. 이 변수의 기본값은 'off'입니다.
- **input-meta**
  'on'이라면, Readline은 터미널이 이를 지원하는지 아닌지 관계없이 8비트 입력(문자를 읽을 때 8비트째를 지우지 않습니다)을 활성화합니다. 기본값은 'off'이지만 로케일이 8비트 문자를 포함한다면 Readline은 'on'으로 설정합니다. `meta-flag`는 이 변수와 동의어입니다.
- **isearch-terminators**
  증분 검색을 종료하고 문자열을 명령어로 실행하지 않는 문자들의 나열(Searching을 참조). 이 변수에 값이 설정되어있지 않다면 `ESC`와 `C-J`로 증분 검색을 종료할 수 있습니다.
- **keymap**
  Readline의 명령어 키 바인딩의 키맵을 설정합니다. 내장된 `keymap` 이름은 `emacs`, `emacs-standard`, `emacs-meta`, `emacs-ctlx`, `vi`, `vi-move`, `vi-command`, `vi-insert`입니다. `vi`는 `vi-command`와 동일합니다(`vi-move`도 동의어입니다). `emacs`는 `emacs-standard`와 동일합니다. 애플리케이션은 이름을 추가할 수 있습니다. 기본값은 `emacs`입니다. `editing-mode` 변수의 값은 기본 키맵에 영향을 줍니다.
- **keyseq-timeout**
  Readline이 여러 가능성을 가지는 키 나열(지금까지 읽은 입력으로 완전한 키 나열을 만들거나 더 긴 키 나열을 완성하기 위해서 추가 입력을 받거나)을 읽을 때 다음 문자를 기다리는 시간을 지정합니다. 지정된 시간안에 입력을 받지 못했다면, Readline은 짧지만 완전한 키 나열을 사용합니다. Readline은 현재 입력 소스(기본값은 `rl_instream`)에서 새 입력을 얻을 수 있는지 없는지 판단하기 위해서 이 값을 사용합니다. 값은 밀리초로 지정되므로, 1000을 지정하면 Readline은 추가 입력을 1초간 기다린다는 의미가 됩니다. 이 변수가 0 또는 0보다 작은 값, 숫자가 아닌 값이라면 Readline은 다른 키 입력을 기다려서 키 나열을 완전한지 아닌지 판단합니다. 기본값은 500입니다.
- **mark-directories**
  'on'이라면 완성된 디렉터리 이름에 슬래시가 추가됩니다. 기본값은 'on'입니다.
- **mark-modified-lines**
  이 변수가 'on'이라면 Readline은 수정된 이력 줄의 첫머리에 별표('*')를 출력합니다. 이 변수의 기본값은 'off'입니다.
- **mark-symlinked-directories**
  'on'이라면, 이름 완성에서 디렉터리를 가리키는 심볼릭 링크를 얻었을 때 슬래시를 추가합니다(*mark-directories*의 값이 적용됩니다). 기본값은 'off'입니다.
- **match-hidden-files**
  이 변수가 'on'이라면 Readline에서는 파일명 완성을 실행할 때 '.'으로 시작하는 이름(숨긴 파일)에도 일치합니다. 'off'라면 유저가 파일명을 완성하기 위해서는 '.'를 입력해야 합니다. 이 변수의 기본값은 'on'입니다.
- **menu-complete-display-prefix**
  'on'이라면 메뉴 완성은 리스트를 한바퀴 돌기 전에 완성 후보 리스트(비어있을 수도 있습니다)의 공통 접두사를 보여줍니다. 기본값은 'off'입니다.
- **output-meta**
  'on'이라면 Readline은 8비트 집합인 문자를 메타 키를 앞에 끼워넣고 이스케이프한 나열을 출력하는 대신 직접 출력합니다. 기본값은 'off'입니다만 로케일이 8비트 문자를 포함하고 있다면 Readline은 'on'을 설정합니다.
- **page-completions**
  'on'이라면 Readline은 내부의 'more-like' 페이저를 사용해서 완성 후보를 단번에 화면 전체에 보여줍니다. 이 변수의 기본값은 'on'입니다.
- **print-completions-horizontally**
  'on'이라면 Readline은 일치한 완성 후보를 화면 아래 대신에 알파벳 순으로 정렬해 수평으로 보여줍니다. 기본값은 'off'입니다.
- **revert-all-at-newline**
  'on'이라면 Readline은 `accept-line`이 실행되었을 때 반환하기 전에 이력 줄에 대한 변경을 모두 되돌립니다. 기본 설정에서 이력 줄에 대한 변경은 개별적으로 되돌리기가 가능하도록 유지하며 이는 `readline` 호출간에서도 호환됩니다. 기본값은 `off`입니다.
- **show-all-if-ambiguous**
  이는 완성 함수의 기본 동작을 변경합니다. 'on'이라면 하나 이상의 완성 후보가 있는 단어는 벨을 울리지 않고 즉시 나열됩니다. 기본값은 `off`입니다.
- **show-all-if-unmodified**
  이는 완성 함수의 기본 동작을 *show-all-if-ambiguous*와 비슷한 방식으로 변경합니다. 'on'일때 하나 이상의 완성 후보가 있고 가능한 부분 완성(공통 접두사를 공유하지 않는 완성 후보)이 없다면 밸을 울리지 않고 즉시 나열됩니다. 기본값은 'off'입니다.
- **show-mode-in-prompt**
  'on'이라면 프롬프트의 첫머리에 편집 모드를 알려주는 문자열을 추가합니다. emacs, vi command, vi insertion. 모드 문자열은 유저가 변경할 수 있습니다(e.g., *emacs-mode-string*). 기본값은 'off'입니다.
- **skip-completed-text**
  'on'이라면, 이는 줄에 일치한 문자열을 삽입하는 기본 완성 동작을 변경합니다. 단어의 중간에서 완성을 실행했을 때에만 유효합니다. 켜져있다면 Readline은 단어를 완성한 뒤 커서가 있는 위치에 일치한 문자를 삽입하지 않습니다. 그러므로 커서 뒤에 오는 단어의 일부가 중복되지 않습니다. 예를 들어 이 설정이 켜져있다면 'Makefile'의 'e'에 커서가 있는 상태에서 완성을 시도하면 완성 후보는 하나뿐이라고 가정하고 'Makefilefile'이 되지 않고 'Makefile'로 대체합니다. 기본값은 'off'입니다.
- **vi-cmd-mode-string**
  *show-mode-in-prompt* 변수가 켜져있다면, vi 편집 모드가 활성화되어 있고 명령어 모드인 경우 주 프롬프트의 마지막 문자열 앞에 이 문자열이 즉시 출력됩니다. 값은 키 바인딩처럼 전개되므로 메타 키, Control 키로 시작하는 표준 집합과 백슬래시 이스케이프 나열을 사용할 수 있습니다. '\\1'과 '\\2'로 출력 불가 문자 나열의 시작과 끝을 이스케이프할 수 있으며, 이는 터미널 제어 나열을 모드 문자열에 끼워넣을 때에도 사용할 수 있습니다. 기본값은 '(cmd)'입니다.
- **vi-ins-mode-string**
  *show-mode-in-prompt* 변수가 켜져있다면, vi 편집 모드가 활성화되어 있고 삽입 모드인 경우 주 프롬프트의 마지막 문자열 앞에 이 문자열이 즉시 출력됩니다. 값은 키 바인딩처럼 전개되므로 메타 키, Control 키로 시작하는 표준 집합과 백슬래시 이스케이프 나열을 사용할 수 있습니다. '\\1'과 '\\2'로 출력 불가 문자 나열의 시작과 끝을 이스케이프할 수 있으며, 이는 터미널 제어 나열을 모드 문자열에 끼워넣을 때에도 사용할 수 있습니다. 기본값은 '(ins)'입니다.
- **visible-stats**
  'on'이라면 완성 후보를 나열할 때 파일 타입을 나타내는 문자가 추가됩니다. 기본값은 'off'입니다.

**키 바인딩**
초기화 파일에서 키 바인딩을 제어하는 문법은 간단합니다. 첫번째로 변경하고 싶은 명령어의 이름을 찾으세요. 다음 섹션에 명령어 이름과 기본 키 바인딩이 있는 경우에는 그 값, 그리고 각 명령어가 무엇을 하는지 간략한 설명이 포함된 리스트가 있습니다.

명령어의 이름을 확인했다면, 초기화 파일에 바인딩하고 싶은 키의 이름을 적고 콜론을 적은 뒤 명령어의 이름을 적으세요. 키 이름과 콜론 사이에 공백을 넣어서는 안됩니다. 콜론이 키 이름의 일부로 해석되기 때문입니다. 키의 이름은 여러 방법으로 표현할 수 있으며 가장 편한 방식을 사용하세요.

Readline은 명령어 이름 뿐만 아니라, 키를 입력했을 때 삽입할 문자열과 바인딩할 수도 있습니다(*매크로*).

`bind -p` 명령어는 Readline 함수 이름과 바인딩을 초기화 파일에서 사용할 수 있는 형식으로 출력합니다. Bash Builtins를 참조하세요.

***keyname*: *function-name* 또는 *macro***
*keyname*은 영어로 된 키의 이름입니다. 다음은 예시입니다.

```sh
Control-u: universal-argument
Meta-Rubout: backward-kill-word
Control-o: "> output"
```

이 예제에서 *C-u*는 *universal-argument* 함수에 바인딩되어 있으며, *M-DEL*은 `backward-kill-word` 함수에 바인딩 되어있고, *C-o*는 우측항('> output'이라는 텍스트를 줄에 삽입합니다.)과 바인딩되어 있습니다.

다음 심볼릭 문자 이름은 키 바인딩 문법을 처리하는 중에 인식됩니다. *DEL*, *ESC*, *ESCAPE*, *LFD*, *NEWLINE*, *RET*, *RETURN*, *REBOUT*, *SPACE*, *SPC*, *TAB*.

**"*keyseq*": *function-name* 또는 *macro***
*keyseq*은 위에서 설명한 *keyname*과 다르게 키 나열을 큰따옴표로 감싸서 키 나열 전체를 지정할 수 있습니다. 다음 예제처럼 몇몇 GNU Emacs 스타일의 키 이스케이프를 사용할 수 있습니다만, 특수 문자 이름은 인식되지 않습니다.

```sh
"\C-u": universal-argument
"\C-x\C-r": re-read-init-file
"\e[11~": "Function Key 1"
```

이 예제에서 *C-u*는 (첫번째 예제처럼) *universal-argument* 함수에 바인딩되어 있으며, '*C-x C-r*'은 `re-read-init-file` 함수에 바인딩 되어있고, '`ESC [ 1 1 ~`'는 '`Function Key 1`'이라는 문자열을 삽입하도록 바인딩되어 있습니다.

키 나열을 지정할 때 다음 GNU Emacs 스타일의 이스케이프 나열을 사용할 수 있습니다.

- **\C-**
  Control 접두사
- **\M-**
  메타 접두사
- **\e**
  이스케이프 문자
- **\\\\**
  백슬래시
- **\\"**
  ", 큰따옴표
- **\\'**
  ', 작은 따옴표

GNU Emacs 스타일의 이스케이프 나열뿐 아니라 다음의 백슬래시 이스케이프 집합도 사용할 수 있습니다.

- **\\a**
  경고(벨)
- **\\b**
  백스페이스
- **\\d**
  삭제
- **\\f**
  폼 피드
- **\\n**
  개행
- **\\r**
  캐리지 리턴
- **\\t**
  수평 탭
- **\\v**
  수직 탭
- **\\*nnn***
  8진수 *nnn*(3문자까지 가능)으로 표현한 8비트 문자
- **\\x*HH***
  16진수 *HH*(2문자까지 가능)으로 표현한 8비트 문자

매크로의 텍스트에 들어갈 때, 작은따옴표나 큰따옴표는 반드시 매크로 정의를 가리켜야 합니다. 따옴표를 벗긴 텍스트는 함수 이름이라고 가정됩니다. 매크로 본체에서는 위에서 설명된 백슬래시 이스케이프가 전개됩니다. 백슬래시는 매크로 텍스트에서 '"'와 '''를 포함한 다른 문자를 감쌀 수 있습니다. 예를 들어 다음 바인딩은 '*C-x* \'로 '\' 하나를 줄에 삽입합니다.

```sh
"\C-x\\": "\\"
```

### 8.3.2 Conditional Init Constructs
Readline은 C의 전처리기의 조건부 컴파일 기능과 유사한 기능이 구현되어있어서 테스트의 결과로 키 바인딩이나 변수를 설정할 수 있습니다. 사용하는 파서 디렉티브는 4개가 있습니다.

**$if**
`$if` 구조를 사용해서 편집 모드, 사용중인 터미널, Readline을 사용하는 애플리케이션에 기초해 바인딩할 수 있습니다. 비교 연산자 뒤에 오는 테스트의 텍스트는 줄의 끝까지 전개됩니다. 따로 언급하지 않는다면 테스트를 구분하기 위한 문자는 필요 없습니다.

- **mode**
  `$if` 디렉티브의 `mode=` 형식은 Readline이 `emacs` 모드인지 `vi` 모드인지 검사할 때 사용합니다. 이는 '`set keymap`' 명령어와 함께 사용하여, 예를 들면 Readline이 `emacs` 모드로 시작한 경우에만 `emacs-standard`와 `emacs-ctls` 키 맵 바인딩을 설정할 수 있습니다.
- **term**
  `term=` 형식은 터미널 고유의 키 바인딩을 포함하기 위해서 사용합니다. 예를 들어 터미널의 펑선 키에 의해서 출력되는 키 나열을 바인딩할 수 있습니다. '='의 오른쪽 피연산자의 단어는 터미널의 완전한 이름과 첫 '-' 앞에 오는 터미널 이름, 둘 모두에 대해 검사됩니다. 이를 통해 `sun`은 `sun`과 `sun-cmd` 모두와 일치합니다.
- **version**
  `version` 테스트는 특정 Readline 버번에 대해서 비교를 실행할 때 사용합니다. `version`은 현재 Readline 버전으로 전개됩니다. 비교 연산자의 집합은 '='(그리고 '=='), '!=', '<=', '>=', '<', '>'를 포함합니다. 오른쪽 피연산자에 사용하는 버전 번호는 메이저 버전 번호(소수를 사용할 수 있습니다), 선택적인 마이너 버전으로 구성됩니다(e.g., '7.1'). 마이너 버전을 생략하면 '0'이라고 간주합니다. 연산자는 문자열 `version`, 버전 번호 인수와 공백으로 구분할 수 있습니다. 다음 예제는 Readline 버전이 7.0 이상일 때 변수를 설정합니다.
  ```sh
  $if version >= 7.0
  set show-mode-in-prompt on
  $endif
  ```
- **application**
  *application* 구조는 애플리케이션 고유의 설정을 포함하기 위해서 사용합니다. Readline 라이브러리를 사용하는 각 프로그램은 *application name*을 설정하므로 이 값을 검사할 수 있습니다. 이는 특정 프로그램에서 유용한 함수에 키 나열을 바인딩할 수 있도록 해줍니다. 예를 들어 다음 명령어는 Bash에서 현재 또는 이전 단어를 감싸는 키 나열을 추가합니다.
  ```sh
  $if Bash
  # Quote the current or previous word
  "\C-xq": "\eb\"\ef\""
  $endif
  ```
- **variable**
  *variable* 구조는 Readline 변수와 값에 대한 간단한 등치 검사를 제공합니다. 사용할 수 있는 비교 연산자는 '=', '==', '!='입니다. 변수 이름은 반드시 비교 연산자와 공백으로 구분되어야 합니다. 연산자는 오른쪽 피연산자와 공백으로 구분될 수 있습니다. 문자열과 불린 변수 모두 검사할 수 있습니다. 불린 변수는 *on*, *off*와 비교되어야 합니다. 다음 예제는 위에서 설명한 `mode=emacs` 검사와 동일합니다.
  ```sh
  $if editing-mode == emacs
  set show-mode-in-prompt on
  $endif
  ```

**$endif**
이 명령어는 위에서 보았듯이 `$if` 명령어를 종료합니다.

**$else**
`$if` 디렉티브의 이 분기에 있는 명령어는 테스트에 실패할 때 실행됩니다.

**$include**
이 디렉티브는 단일 파일명을 인수로 받고 이 파일로 부터 명령어와 바인딩을 읽습니다. 예를 들어 다음 디렉티브는 `/etc/inputrc`를 읽습니다.

```sh
$include /etc/inputrc
```

### 8.3.3 Sample Init File
다음은 *inputrc* 파일 예제입니다. 이는 키 바인딩, 변수 대입, 조건부 문법의 사용법을 보여줍니다.

```sh
# 이 파일은 GNU Readline 라이브러리를 사용하는 프로그램의 줄 입력 편집의 동작을
# 제어합니다. 프로그램은 FTP, Bash, GDB를 포함합니다.
#
# C-x C-r로 inputrc 파일을 다시 읽을 수 있습니다.
# '#'로 시작하는 줄은 코멘트입니다.
#
# 첫번째로 /etc/inputrc로부터 시스템 전체에 영향을 미치는 바인딩과
# 변수 대입을 가져옵니다.
$include /etc/inputrc

#
# emacs 모드 바인딩을 설정합니다.

set editing-mode emacs 

$if mode=emacs

Meta-Control-h:	backward-kill-word 함수명 뒤에 오는 텍스트는 무시됩니다

#
# 키패드 모드의 방향키
#
#"\M-OD":        backward-char
#"\M-OC":        forward-char
#"\M-OA":        previous-history
#"\M-OB":        next-history
#
# ANSI 모드의 방향키
#
"\M-[D":        backward-char
"\M-[C":        forward-char
"\M-[A":        previous-history
"\M-[B":        next-history
#
# 8비트 키패드 모드의 방향키
#
#"\M-\C-OD":       backward-char
#"\M-\C-OC":       forward-char
#"\M-\C-OA":       previous-history
#"\M-\C-OB":       next-history
#
# 8비트 ANSI 모드의 방향키
#
#"\M-\C-[D":       backward-char
#"\M-\C-[C":       forward-char
#"\M-\C-[A":       previous-history
#"\M-\C-[B":       next-history

C-q: quoted-insert

$endif

# 구식 바인딩. 이는 우연한 기본 설정입니다.
TAB: complete

# 셸 상호작용에 편리한 매크로들
$if Bash
# 경로 수정하기
"\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
# 따옴표로 감싼 단어를 입력 준비하기 --
# 여는 큰따옴표와 닫는 큰따옴표를 삽입하고
# 여는 따옴표 뒤로 이동시킵니다
"\C-x\"": "\"\"\C-b"
# 백슬래시를 삽입합니다(키 나열과 매크로의 백슬래시 이스케이프를 테스트합니다)
"\C-x\\": "\\"
# 현재 또는 직전 단어를 큰따옴표로 감쌉니다
"\C-xq": "\eb\"\ef\""
# 확정되지 않은 줄을 새로고침하는 바인딩을 추가합니다
"\C-xr": redraw-current-line
# 현재 줄의 변수를 편집합니다
"\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
$endif

# 사용 가능하다면 보이는 벨을 사용합니다
set bell-style visible

# 읽을 때 문자에서 8비트째를 지우지 않습니다
set input-meta on

# iso-latin1 문자를 메타 키로 시작하는 나열로 변환하는 대신
# 그대로 삽입합니다
set convert-meta off

# 8번째 비트를 포함한 문자를 메타 키로 시작하는 나열로 변환해
# 출력하는 대신 그대로 출력합니다.
set output-meta on

# 단어에 150개 이상의 완성 후보가 있다면,
# 이를 전부 출력할지 묻습니다
set completion-query-items 150

# FTP 설정
$if Ftp
"\C-xg": "get \M-?"
"\C-xt": "put \M-?"
"\M-.": yank-last-arg
$endif
```

## 8.4 Bindable Readline Commands
- Commands For Moving : 줄에서 이동하기.
- Commands For Manipulating The History : 이전 줄을 얻기.
- Commands For Changing Text : 텍스트를 변경하는 명령어.
- Killing And Yanking : 텍스트를 잘라내거나 재삽입하는 명령어.
- Specifying Numeric Arguments : 숫자 인수를 지정해서 반복하기.
- Commands For Completion : Readline이 대신 입력하게 만들기.
- Keyboard Macros : 입력한 문자를 저장하고 재실행하기.
- Miscellaneous Commands : 그 이외의 명령어들.

이 섹션에서는 키 나열을 바인딩할 수 있는 Readline 명령어에 대해서 설명합니다. 키 바인딩 리스트를 보려면 `bind -P`를 실행하거나 *inputrc* 파일에서 사용할 수 있는 간결한 형식으로 출력하는 `bind -p`를 실행하세요(Bash Builtins를 참조).

다음 설명에서 *포인트*는 현재 커서 위치를 가리키며 *마크*는 `set-mark` 명령어로 저장한 커서의 위치입니다. 포인트와 마크 사이의 텍스트는 선택 영역(*region*)이라고 부릅니다.

### 8.4.1 Commands For Moving
**beginning-of-line (C-a)**
  현재 줄의 첫 머리로 이동합니다.

**end-of-line (C-e)**
  줄의 마지막으로 이동합니다.

**forward-char (C-f)**
  한 글자 앞으로 이동합니다.

**backward-char (C-b)**
  한 글자 뒤로 이동합니다.

**forward-word (M-f)**
  다음 단어의 끝 부분으로 이동합니다. 단어는 영문자와 숫자로 구성됩니다.

**backward-word (M-b)**
  현재나 이전 단어의 시작 부분으로 이동합니다. 단어는 영문자와 숫자로 구성됩니다.

**shell-forward-word (M-C-f)**
  다음 단어의 끝 부분으로 이동합니다. 단어는 따옴표로 감싸지 않은 셸 메타 문자로 구분됩니다.

**shell-backward-word (M-C-b)**
  현재나 이전 단어의 시작 부분으로 이동합니다. 단어는 따옴표로 감싸지 않은 셸 메타 문자로 구분됩니다.

**previous-screen-line ()**
  포인트를 이전 줄의 같은 물리 화면 열로 움직입니다. 현재 Readline 줄이 2개 이상의 줄을 차지 하지 않거나 포인트가 화면 너비 더하기 프롬프트의 길이보다 크지 않다면 기대하는 동작대로 실행되지 않습니다.

**next-screen-line ()**
  포인트를 다음 줄의 같은 물리 화면 열로 움직입니다. 현재 Readline 줄이 2개 이상의 줄을 차지 하지 않거나 포인트가 화면 너비 더하기 프롬프트의 길이보다 크지 않다면 기대하는 동작대로 실행되지 않습니다.

**clear-display (M-C-l)**
  화면을 비우고, 가능하다면 터미널의 스크롤백 버퍼도 비운 뒤, 현재 줄을 다시 출력해 현재 줄만 화면 상단에 오도록 합니다.

**clear-screen (C-l)**
  화면을 비우고 현재 줄을 다시 출력해 현재 줄만 화면 상단에 오도록 합니다.

**redraw-current-line ()**
  현재 줄을 다시 출력합니다. 기본값으로 이 명령어는 바인딩되어 있지 않습니다.

### 8.4.2 Commands For Manipulating The History
**accept-line (Newline 또는 Return)**
커서가 어디에 있든 관계없이 줄의 입력을 종료합니다. 줄이 비어있지 않다면, 이를 `HISTCONTROL`과 `HISTIGNORE` 변수 설정에 따라 이력 리스트에 추가합니다. 줄이 수정된 이력 줄이라면 이력 줄을 원래 상태로 복구합니다.

**previous-history (C-p)**
이력 리스트에 들어 있는 이전 명령어를 가져옵니다.

**next-history (C-n)**
이력 리스트에 들어 있는 다음 명령어를 가져옵니다.

**beginning-of-history (M-<)**
이력 리스트의 첫번째 줄로 이동합니다.

**end-of-history (M->)**
이력 리스트의 마지막 줄로 이동합니다. i.e., 현재 입력중인 줄.

**reverse-search-history (C-r)**
필요에 따라 현재 줄부터 시작해 이력 리스트를 역순으로 검색합니다. 이 검색은 증분 검색입니다. 명령어는 일치한 텍스트에 영역을 설정하고 마크를 활성화합니다.

**forward-search-history (C-s)**
필요에 따라 현재 줄부터 시작해 이력 리스트를 순서대로 검색합니다. 이 검색은 증분 검색입니다. 명령어는 일치한 텍스트에 영역을 설정하고 마크를 활성화합니다.

**non-incremental-reverse-search-history (M-p)**
필요에 따라 현재 줄부터 시작해 유저가 넘긴 문자열을 사용해 이력 리스트로부터 역순으로 비-증분 검색을 실행합니다. 검색 문자열은 이력 줄의 어느 부분에도 일치할 수 있습니다.

**non-incremental-forward-search-history (M-n)**
필요에 따라 현재 줄부터 시작해 유저가 넘긴 문자열을 사용해 이력 리스트로부터 순서대로 비-증분 검색을 실행합니다. 검색 문자열은 이력 줄의 어느 부분에도 일치할 수 있습니다.

**history-search-forward ()**
현재 줄의 시작 위치와 커서 사이에 있는 문자열을 사용해 이력을 순서대로 검색합니다. 검색 문자열은 이력 줄의 첫머리부터 일치해야 합니다. 이는 비-증분 검색입니다. 기본 설정에서 이 명령어는 바운딩되어 있지 않습니다.

**history-search-backward ()**
현재 줄의 시작 위치와 커서 사이에 있는 문자열을 사용해 이력을 역순으로 검색합니다. 검색 문자열은 이력 줄의 첫머리부터 일치해야 합니다. 이는 비-증분 검색입니다. 기본 설정에서 이 명령어는 바운딩되어 있지 않습니다.

**history-substring-search-forward ()**
현재 줄의 시작 위치와 커서 사이에 있는 문자열을 사용해 이력을 순서대로 검색합니다. 검색 문자열은 이력 줄의 어느 부분에도 일치할 수 있습니다. 이는 비-증분 검색입니다. 기본 설정에서 이 명령어는 바운딩되어 있지 않습니다.

**history-substring-search-backward ()**
현재 줄의 시작 위치와 커서 사이에 있는 문자열을 사용해 이력을 역순으로 검색합니다. 검색 문자열은 이력 줄의 어느 부분에도 일치할 수 있습니다. 이는 비-증분 검색입니다. 기본 설정에서 이 명령어는 바운딩되어 있지 않습니다.

**yank-nth-arg (M-C-y)**
이전 명령어의 첫번째 인수(보통 이전 줄의 두 번째 단어)를 포인트에 삽입합니다. 인수 *n*을 넘기면 이전 명령어의 *n*번째 단어(이전 명령어의 단어는 0번부터 시작합니다)를 삽입합니다. 음수 인수는 이전 명령어의 뒤에서부터 *n*번째 단어를 삽입합니다. 인수 *n*이 계산된 후, '!*n*' 이력 전개가 지정된 것처럼 인수를 추출합니다.

**yank-last-arg (M-. or M-_)**
이전 명령어의 마지막 인수(이전 이력의 마지막 단어)를 삽입합니다. 숫자 인수를 넘기면 `yank-nth-arg`처럼 동작합니다. `yank-last-arg`를 연속해서 호출하면 이력 리스트를 거슬러 올라가며 각 줄의 마지막 단어(또는 첫번째 호출의 인수로 식별된 단어)를 호출될 때마다 삽입합니다. 이 연속 호출에서 숫자 인수를 넘기면 이력 리스트에서의 순회할 방향을 지정합니다. 음수는 순회 방향을 반대로 변경합니다(역순 또는 정순). 이력 전개 기능은 '!$' 이력 전개가 지정된 것처럼 마지막 인수를 추출하기 위해 사용됩니다.

**operate-and-get-next (C-o)**
현재 줄을 개행이 입력된 것처럼 받아서 호출한 원래 애플리케이션으로 되돌리고, 이력으로부터 현재 줄의 다음 줄을 편집하기 위해 꺼내옵니다. 숫자 인수를 넘기면 현재 줄 대신 사용할 이력 리스트의 줄을 지정합니다.

### 8.4.3 Commands For Changing Text
**end-of-file (일반적으로는 C-d)**
`stty` 등에서 설정되어있는 파일의 끝을 알리는 문자입니다. 줄에 아무 문자가 없고 줄의 첫 머리에 포인트가 있을 때 이 문자를 읽으면 Readline은 이를 입력 종료로 해석하고 EOF를 반환합니다.

**delete-char (C-d)**
포인트에 있는 문자를 지웁니다. 이 함수가 tty EOF 문자와 같은 문자에 바인딩 되어 있다면(보통 *C-d*가 그렇습니다) 위의 효과를 확인해두세요.

**backward-delete-char (Rubout)**
커서 뒤의 문자를 지웁니다. 숫자 인수는 문자를 단순히 지우는 대신 잘라냅니다.

**forward-backward-delete-char ()**
커서가 줄의 끝이 아니라면 커서가 올려져 있는 문자를 지웁니다. 커서가 줄의 끝에 있다면 커서 앞의 문자를 지웁니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**quoted-insert (C-q or C-v)**
다음 문자를 입력한 그대로의 문자로 추가합니다. 이 명령어를 통해 *C-q*와 같은 키 나열을 삽입할 수 있습니다.

**self-insert (a, b, A, 1, !, …)**
자기 자신을 삽입합니다.

**bracketed-paste-begin ()**
이 함수는 몇몇 터미널이 전송하는 "대괄호로 감싼 붙여넣기" 이스케이프 나열을 바인딩하는 것을 목적으로 하며, 이러한 바인딩은 기본값이 설정되어 있습니다. 이를 통해 Readline은 붙여넣은 텍스트를 각 문자를 키보드로부터 읽은 것처럼 처리하지 않고 하나의 단위로 삽입할 수 있습니다. 문자는 편집 명령어를 실행하는 대신 각각 *self-insert*로 바인딩 된 것처럼 삽입됩니다.

대괄호로 감싼 붙여넣기는 삽입한 텍스트에 선택 영역(포인트와 마크 사이의 문자열)을 설정합니다. 이는 *활성화된* 마크 개념을 사용합니다. 마크가 활성화되어 있다면 Readline의 재표시는 선택 영역을 나타내기 위해 터미널의 스탠드아웃 모드를 사용합니다.

**transpose-chars (C-t)**
커서 앞의 문자를 커서가 있는 위치로 끌어오고, 커서도 한 칸 움직입니다. 삽입 포인트가 줄의 끝이라면 명령어는 줄의 마지막 두 문자를 뒤바꿉니다. 음수 인수는 아무런 효과가 없습니다.

**transpose-words (M-t)**
포인트 앞의 단어를 포인트 뒤의 단어의 뒤로 끌어오고, 커서도 끌어온 자리로 움직입니다. 삽입 포인트가 줄의 끝이라면 명령어는 줄의 마지막 두 단어를 뒤바꿉니다.

**upcase-word (M-u)**
현재(또는 다음) 단어를 대문자로 변환합니다. 음수 인수를 넘기면 이전 단어를 대문자로 변환하지만 커서는 움직이지 않습니다.

**downcase-word (M-l)**
현재(또는 다음) 단어를 소문자로 변환합니다. 음수 인수를 넘기면 이전 단어를 소문자로 변환하지만 커서는 움직이지 않습니다.

**capitalize-word (M-c)**
현재(또는 다음) 단어의 머리글자를 대문자로 변환합니다. 음수 인수를 넘기면 이전 단어의 머리글자를 대문자로 변환하지만 커서는 움직이지 않습니다.

**overwrite-mode ()**
덮어쓰기 모드를 켜거나 끕니다. 명시적으로 양수 인수를 넘기면 덮어쓰기 모드로 변경합니다. 양수가 아닌 인수를 넘기면 삽입 모드로 변경합니다. 명령어는 `emacs` 모드에서만 동작합니다. `vi` 모드는 다른 방식으로 덮어쓰기 모드를 사용합니다. 각 `readline()` 호출은 삽입 모드에서 시작합니다.

덮어쓰기 모드에서는 `self-insert`에 바인딩된 문자는 포인트가 위치한 문자를 오른쪽으로 밀어내는 대신 자신으로 대체합니다. `backward-delete-char`에 바인딩된 문자는 포인트 앞의 문자를 스페이스로 대체합니다.

기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

### 8.4.4 Killing And Yanking
**kill-line (C-k)**
포인트부터 줄의 끝까지 잘라냅니다. 음수 인수를 넘기면 커서부터 현재 줄의 시작 부분까지를 잘라냅니다.

**backward-kill-line (C-x Rubout)**
포인트부터 현재 줄의 시작 부분까지 잘라냅니다. 음수 인수를 넘기면 커서부터 현재 줄의 끝 부분까지를 잘라냅니다.

**unix-line-discard (C-u)**
커서부터 현재 줄의 시작 부분까지 잘라냅니다.

**kill-whole-line ()**
포인트의 위치와 관계없이 현재 줄의 모든 문자열을 잘라냅니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**kill-word (M-d)**
포인트부터 현재 단어의 끝까지, 또는 포인트가 단어 사이에 있다면 다음 단어의 끝까지 잘라냅니다. 단어 경계는 `forward-word`와 동일합니다.

**backward-kill-word (M-DEL)**
포인트부터 현재 단어의 앞 부분을 잘라냅니다. 단어 경계는 `backward-word`와 동일합니다.

**shell-kill-word (M-C-d)**
포인트부터 현재 단어의 끝까지, 또는 포인트가 단어 사이에 있다면 다음 단어의 끝까지 잘라냅니다. 단어 경계는 *shell-forward-word`와 동일합니다.

**shell-backward-kill-word ()**
포인트부터 현재 단어의 앞 부분을 잘라냅니다. 단어 경계는 `shell-backward-word`와 동일합니다.

**shell-transpose-words (M-C-t)**
포인트 앞의 단어를 포인트 뒤의 단어의 뒤로 끌어오고, 커서도 끌어온 자리로 움직입니다. 삽입 포인트가 줄의 끝이라면 명령어는 줄의 마지막 두 단어를 뒤바꿉니다. 단어 경계는 `shell-forward-word`, `shell-backward-word`와 동일합니다.

**unix-word-rubout (C-w)**
단어 경계로 공백 문자를 사용해 포인트 앞의 단어를 잘라냅니다. 잘라낸 텍스트는 킬-링에 저장됩니다.

**unix-filename-rubout ()**
단어 경계로 공백 문자와 슬래시 문자를 사용해 포인트 앞의 단어를 잘라냅니다. 잘라낸 텍스트는 킬-링에 저장됩니다.

**delete-horizontal-space ()**
포인트에 인접한 모든 스페이스와 탭 문자를 지웁니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**kill-region ()**
현재 선택 영역의 텍스트를 잘라냅니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**copy-region-as-kill ()**
선택 영역의 텍스트를 킬 버퍼에 복사해 재삽입할 수 있도록 합니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**copy-backward-word ()**
포인트 앞의 단어를 킬 버퍼에 복사합니다. 단어 경계는 `backward-word`와 같습니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**copy-forward-word ()**
포인트 뒤의 단어를 킬 버퍼에 복사합니다. 단어 경계는 `forward-word`와 같습니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**yank (C-y)**
킬-링의 상단에 있는 문자열을 버퍼의 포인트 위치에 재삽입합니다.

**yank-pop (M-y)**
킬-링을 순환시켜서 얻은 새 상단의 값을 재삽입합니다. 이전 명령어가 `yank`이거나 `yank-pop`일때만 사용할 수 있습니다.

### 8.4.5 Specifying Numeric Arguments
**digit-argument (*M-0*, *M-1*, … *M--*)**
이미 축적중인 인수에 이 숫자를 추가하거나 새 인수를 시작합니다. *M--*는 음의 인수를 시작합니다.

**universal-argument ()**
인수를 지정하는 또 하나의 방법입니다. 이 명령어 뒤에 하나 이상의 숫자(마이너스 기호로 시작할 수 있습니다)가 따라오면 넘긴 숫자는 인수를 정의합니다. 명령어 뒤에 숫자가 따라오는 경우, `universal-argument`를 재실행하면 숫자 인수 입력이 종료됩니다만, 그 이외의 경우에는 무시됩니다. 특수한 경우로 명령어 직후에 숫자나 마이너스 기호가 아닌 문자가 따라오면 다음 명령어의 인수 숫자는 4배가 됩니다. 인수 개수는 처음엔 1이므로 이 함수를 처음 실행하면 인수 개수는 4가 되고, 두번째 실행하면 16이 되는 식입니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

### 8.4.6 Commands For Completion
**complete (TAB)**
포인트 앞에 오는 텍스트에 대해 완성을 시도합니다. 실제 실행되는 완성은 애플리케이션마다 다릅니다. Bash는 텍스트를 변수('$'로 시작하는 경우), 유저명('~'로 시작하는 경우), 호스트명('@'로 시작하는 경우), 명령어(별칭과 함수 포함) 순서대로 완성을 시도합니다. 어느 것에도 일치하지 않는 경우 파일명 완성을 시도합니다.

**possible-completions (M-?)**
포인트 앞에 오는 텍스트에 사용 가능한 완성 목록을 출력합니다. 완성을 보여줄 때 Readline은 `completion-display-width`의 값 또는 `COLUMNS` 환경 변수의 값 또는 화면의 너비를 순서대로 확인해 출력할 너비(열 개수)를 설정합니다.

**insert-completions (M-*)**
포인트 앞 텍스트의 `possible-completions`로 생성된 모든 완성 후보를 삽입합니다.

**menu-complete ()**
`complete`와 유사하지만 완성 대상 단어를 완성 후보 리스트에 있는 단일 일치로 대체합니다. `menu-complete`를 반복해서 실행하면 완성 후보의 리스트를 하나씩 삽입합니다. 완성 리스트의 마지막에 도달하면 벨이 울리고(`bell-style`의 적용을 받습니다) 원래 텍스트가 복구됩니다. *n*의 인수는 리스트의 *n*번째 일치로 넘어갑니다. 음수 인수는 리스트의 반대 방향으로 이동합니다. 이 명령어는 `TAB`로 바인딩해서 사용하는 것을 의도하고 있습니다만, 기본 설정에서는 바인딩되어 있지 않습니다.

**menu-complete-backward ()**
`menu-complete`와 동일하지만 완성 후보 리스트를 탐색하는 방향이 반대이며, `menu-complete`에 음수 인수를 넘긴 것처럼 동작합니다.

**delete-char-or-list ()**
커서가 줄의 처음이나 마지막이 아니라면 (`delete-char`처럼) 커서에 위치한 문자를 지웁니다. 줄의 마지막이라면 `possible-completions`와 동일하게 동작합니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**complete-filename (M-/)**
포인트 앞의 텍스트에 대해 파일명 완성을 시도합니다.

**possible-filename-completions (C-x /)**
포인트 앞의 텍스트에 대해 파일명 완성의 완성 후보 리스트를 출력합니다.

**complete-username (M-~)**
포인트 앞의 텍스트에 대해 유저명 완성을 시도합니다.

**possible-username-completions (C-x ~)**
포인트 앞의 텍스트에 대해 유저명 완성의 완성 후보 리스트를 출력합니다.

**complete-variable (M-$)**
포인트 앞의 텍스트에 대해 셸 변수 완성을 시도합니다.

**possible-variable-completions (C-x $)**
포인트 앞의 텍스트에 대해 셸 변수 완성의 완성 후보 리스트를 출력합니다.

**complete-hostname (M-@)**
포인트 앞의 텍스트에 대해 호스트명 완성을 시도합니다.

**possible-hostname-completions (C-x @)**
포인트 앞의 텍스트에 대해 호스트명 완성의 완성 후보 리스트를 출력합니다.

**complete-command (M-!)**
포인트 앞의 텍스트에 대해 명령어 이름 완성을 시도합니다. 명령어 완성은 별칭, 예약어, 셸 함수, 셸 빌트인, 마지막으로 실행 가능한 파일명에 대해서 순서대로 일치를 시도합니다.

**possible-command-completions (C-x !)**
포인트 앞의 텍스트에 대해 명령어 이름 완성의 완성 후보 리스트를 출력합니다.

**dynamic-complete-history (M-TAB)**
포인트 앞의 텍스트에 대해 완성을 시도하고, 텍스트와 이력 리스트의 줄을 비교하여 일치하는 완성 후보를 찾습니다.

**dabbrev-expand ()**
포인트 앞의 텍스트에 대해 메뉴 완성을 시도하고, 텍스트와 이력 리스트의 줄을 비교하여 일치하는 완성 후보를 찾습니다.

**complete-into-braces (M-{)**
파일명 완성을 실행하고 셸에서 사용할 수 있도록 중괄호로 감싼 완성 후보의 리스트를 삽입합니다.

### 8.4.7 Keyboard Macros
**start-kbd-macro (C-x ()**
입력한 문자들을 현재 키보드 매크로에 저장하기 시작합니다.

**end-kbd-macro (C-x ))**
입력한 문자를 현재 키보드 매크로에 저장하는 것을 멈추고 정의를 보존합니다.

**call-last-kbd-macro (C-x e)**
마지막으로 정의한 키보드 매크로를 재실행하고, 매크로의 문자들이 키보드로 입력한 것처럼 출력합니다.

**print-last-kbd-macro ()**
마지막으로 정의한 키보드 매크로를 *inputrc* 파일에서 사용 가능한 형식으로 출력합니다.

### 8.4.8 Miscellaneous Commands
**re-read-init-file (C-x C-r)**
*inputrc* 파일의 내용을 읽고 발견한 바인딩이나 변수 대입을 적용합니다.

**abort (C-g)**
현재 편집 명령어를 취소하고 터미널의 벨을 울립니다(`bell-style` 설정이 적용됩니다).

**do-lowercase-version (M-A, M-B, M-x, …)**
메타화된 문자 *x*가 대문자라면 이와 대응하는 메타화된 소문자와 바인딩된 명령어를 실행합니다. *x*가 소문자라면 이 동작은 미정의입니다.

**prefix-meta (ESC)**
다음 문자 입력을 메타화(Metafy)합니다. 메타 키가 없는 키보드를 위한 기능입니다. '`ESC f`'를 입력하는 것은 *M-f*를 입력하는 것과 같습니다.

**undo (C-_ 또는 C-x C-u)**
줄마나 개별로 보존된 증분 되돌리기.

**revert-line (M-r)**
현재 줄의 모든 변경을 되돌립니다. 이 명령어는 `undo`를 처음 상태로 되돌릴 정도로 충분히 여러번 실행한 것처럼 동작합니다.

**tilde-expand (M-&)**
현재 단어에서 물결줄표 전개를 실행합니다.

**set-mark (C-@)**
포인트에 마크를 설정합니다. 숫자 인수를 넘기면 마크는 해당 위치에 설정됩니다.

**exchange-point-and-mark (C-x C-x)**
포인트와 마크 위치를 맞바꿉니다. 현재 커서 위치는 저장된 위치로 바뀌며, 이전 커서 위치를 마크로 설정합니다.

**character-search (C-])**
문자를 읽고 같은 캐릭터가 출현하는 다음 위치로 포인트를 이동시킵니다. 음수 검색은 이전 출현을 검색합니다.

**character-search-backward (M-C-])**
문자를 읽고 같은 캐릭터가 출현하는 이전 위치로 포인트를 이동시킵니다. 음수 검색은 다음 출현을 검색합니다.

**skip-csi-sequence ()**
Home이나 End같은 키에 정의된 여러 키 나열을 소비하는데 충분한 문자를 읽습니다. 이러한 나열은 제어 나열 표시자(Control Sequence Indicator, CSI), 일반적으로 `ESC-[`로 시작합니다. 이 나열이 "\e\["로 바인딩되어 있다면 이러한 나열을 생성하는 키들은 문자를 편집 버퍼에 삽입하는 대신, 명시적으로 Readline 명령어로 바운딩되지 않았다면 아무런 효과가 없습니다. 그 대신 각 문자를 편집 버퍼에 삽입합니다. 기본 설정에서 이 명령어는 바인딩되어 있지 않습니다만 보통 `ESC-[`에 바인딩합니다.

**insert-comment (M-#)**
숫자 인수가 없다면 `comment-begin` 변수의 값이 현재 줄의 첫부분에 삽입됩니다. 숫자 인수를 넘기면 이 명령어는 토글처럼 동작합니다. 줄의 첫부분에 `comment-begin`의 값과 일치하는 문자가 없다면 값을 삽입하고, 그렇지 않다면 `comment-begin`의 문자를 줄의 첫부분으로부터 제거합니다. 두 경우 모두 개행을 입력된 것처럼 동작합니다. 명령어는 `comment-begin`의 기본값을 사용하면 현재 줄을 셸 코멘트로 만듭니다. 숫자 인수를 넘겼을 때 코멘트 문자를 제거한다면, 셸은 해당 줄을 실행할 것입니다.

**dump-functions ()**
모든 함수와 그에 대응하는 키 바인딩을 Readline의 출력 스트림으로 출력합니다. 숫자 인수를 넘기면 결과는 *inputrc* 파일의 일부로 사용할 수 있는 형식으로 출력됩니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**dump-variables ()**
모든 설정 가능한 변수와 그에 대응하는 키 바인딩을 Readline의 출력 스트림으로 출력합니다. 숫자 인수를 넘기면 결과는 *inputrc* 파일의 일부로 사용할 수 있는 형식으로 출력됩니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**dump-macros ()**
모든 매크로, 문자열과 그에 대응하는 키 바인딩을 출력합니다. 숫자 인수를 넘기면 결과는 *inputrc* 파일의 일부로 사용할 수 있는 형식으로 출력됩니다. 기본 설정에서 이 명령어에 바인딩된 키는 없습니다.

**glob-complete-word (M-g)**
포인트 앞의 단어에 암묵적으로 별표를 덧붙인 뒤 이를 패턴으로 하는 경로명 전개를 실행합니다. 이 패턴은 완성 후보로 일치하는 파일 이름 리스트를 생성할 때 사용됩니다.

**glob-expand-word (C-x *)**
포인트 앞의 단어를 경로명 전개의 패턴으로 하는 경로명 전개를 실행하고, 원래 단어를 일치한 파일명 리스트로 대체합니다. 숫자 인수를 넘겼다면 파일명 전개 전에 '*'를 덧붙입니다.

**glob-list-expansions (C-x g)**
`glob-expand-word`로 생성된 전개의 리스트를 출력하며 줄을 새로고침합니다. 숫자 인수를 넘기면 파일명 전개 전에 '*'를 덧붙입니다.

**display-shell-version (C-x C-v)**
Bash의 현재 인스턴스의 버전 정보를 보여줍니다.

**shell-expand-line (M-C-e)**
셸이 하듯 줄을 전개합니다. 별칭 전개와 이력 전개, 그리고 셸 단어 전개가 실행됩니다(Shell Expansions를 참조).

**history-expand-line (M-^)**
현재 줄에서 이력 전개를 실행합니다.

**magic-space ()**
현재 줄에서 이력 전개를 실행하고 스페이스를 삽입합니다(History Interaction을 참조).

**alias-expand-line ()**
현재 줄에서 별칭 전개를 실행합니다(Aliases를 참조).

**history-and-alias-expand-line ()**
현재 줄에서 이력 전개와 별칭 전개를 실행합니다.

**insert-last-argument (M-. or M-_)**
`yank-last-arg`의 동의어입니다.

**edit-and-execute-command (C-x C-e)**
현재 커맨드 라인에서 에디터를 호출하고 그 결과를 셸 명령어로 실행합니다. Bash는 에디터를 호출할 때 `$VISUAL`, `$EDITOR`, `emacs`를 순서대로 시도합니다.

## 8.5 Readline vi Mode
Readline 라이브러리가 `vi` 편집 기능을 전부 제공해주지는 않습니다만, 간단한 줄 편집에 필요한 기능은 충분히 가지고 있습니다. Readline `vi` 모드는 POSIX 표준에 기술된 대로 동작합니다.

`emacs`와 `vi` 편집 모드를 상호간에 변경하려면 `set -o emacs`나 `set -o vi` 명령어를 사용하세요(The Set Builtin을 참조). Readline의 기본 설정은 `emacs` 모드입니다.

`vi` 모드로 줄에 들어가면 'i'를 입력한 것처럼 '삽입' 모드로 시작합니다. `ESC`를 눌러서 '명령' 모드로 들어갈 수 있습니다. 이 모드에서는 줄의 텍스트를 표준 `vi` 이동키를 사용해 편집하고 `k` 이전 이력 줄로 이동하거나 'j'로 다음 줄로 이동하는 등이 가능합니다.

## 8.6 Programmable Completion
`complete` 빌트인(Programmable Completion Builtins를 참조)을 사용해 완성 명세(*compspec*)가 정의된 명령어의 인수에 단어 완성을 시도할 때, 프로그래밍 가능한 완성 기능이 호출됩니다.

첫번째로 명령어의 이름이 식별됩니다. 명령어의 완성 명세가 정의되어 있다면, 완성 명세는 단어의 완성 후보 목록을 생성할 때 사용됩니다. 명령어 단어가 빈 문자열(빈 줄의 시작에서 완성을 시도하는 경우)이라면, `complete`에 `-E` 옵션을 넘기며 정의된 완성 명세가 사용됩니다. 명령어 단어가 완전한 경로라면, 완전한 경로에 대한 완성 명세가 존재하는지 먼저 찾습니다. 완전한 경로에 대한 완성 명세가 존재하지 않는다면, 마지막 슬래시 뒷부분을 사용하여 완성 명세를 찾으려 시도합니다. 이 검색에서도 완성 명세를 발견하지 못했다면 `complete`에 `-D` 옵션을 넘기며 정의된 완성 명세가 기본값으로 사용됩니다. 기본으로 사용할 수 있는 완성 명세가 없다면, Bash는 마지막 수단으로 명령어 단어에 대해 별칭 전개를 시도하고 성공한 전개 결과로부터 명령어의 완성 명세를 찾으려 시도합니다.

일단 완성 명세를 발견했다면 일치하는 단어 목록을 생성할 때 사용됩니다. 완성 명세를 찾지 못했다면 이전에 설명한 Bash의 기본 완성 기능(Commands For Completion을 참조)이 실행됩니다.

먼저 완성 명세에 지정된 액션이 사용됩니다. 완성 대상인 단어가 접두사로 일치하는 것만이 반환됩니다. 파일명이나 디렉터리명 완성에 `-f`나 `-d` 옵션을 사용할 때, 셸은 `FIGNORE` 변수를 사용해 일치 결과를 필터링합니다. `FIGNORE`에 대해서는 Bash Variables를 참조하세요.

`-G` 옵션에 넘긴 파일명 전개 패턴으로 식별된 완성이 다음으로 생성됩니다. 패턴에 의해 생성된 단어는 완성 대상 단어와 일치할 필요가 없습니다. `GLOBIGNORE` 셸 변수는 일치 결과를 필터링할 때 사용되지 않습니다만, `FIGNORE` 셸 변수는 사용됩니다.

그 다음으로 `-W` 옵션에 넘긴 인수 문자열을 검토합니다. 먼저, `IFS` 특수 변수의 문자들을 구분자로 사용해 문자열을 분할합니다. 셸의 메타 문자나 `IFS`의 값이 포함된 문자열을 사용 할 수 있도록 셸의 따옴표 감싸기가 적용됩니다. 각 단어는 이전에 설명했던 중괄호 전개, 물결줄표 전개, 매개변수와 변수 전개. 명령어 치환, 산술 전개를 사용해 전개됩니다(Shell Expansions를 참조). 전개된 결과는 이전에 설명한 규칙(Word Splitting을 참조)을 사용해 분할됩니다. 전개의 결과는 완성 대상 단어와 앞 부분이 일치하며 일치한 단어는 완성 후보가 됩니다.

일치 리스트가 생성된 후, `-F`와 `-C` 옵션으로 지정한 셸 함수나 명령어가 호출됩니다. 명령어나 함수가 호출될 때 이전에 설명했던 것처럼 `COMP_LINE`, `COMP_POINT`, `COMP_KEY`, `COMP_TYPE` 변수에 값이 대입됩니다(Bash Variables를 참조). 셸 함수가 호출되었다면 `COMP_WORDS`와 `COMP_CWORD`도 설정됩니다. 함수나 명령어가 호출되었다면 첫번째 인수(`$1`)는 인수를 완성하고 싶은 명령어의 이름이며, 두번째 인수(`$2`)는 완성 대상인 단어이고 세번째 인수(`$3`)는 현재 커맨드 라인에서 완성을 시도하고 있는 단어의 앞 단어입니다. 완성 대상에 대해서 생성된 완성 후보에는 어떤 필터링도 적용되지 않습니다. 함수나 명령어는 완전히 자유롭게 일치 리스트를 생성할 수 있습니다.

`-F` 옵션으로 지정한 함수가 먼저 호출됩니다. 함수는 아래에서 설명할 `compgen`과 `compopt` 빌트인(Programmable Completion Builtins를 참조)을 포함하는 셸의 기능을 사용해 일치 리스트를 생성할 수 있습니다. 함수는 `COMPREPLY` 배열 변수에 완성 후보를 한 인덱스에 한 개씩 추가해야 합니다.

다음으로, `-C` 옵션으로 지정한 명령어가 명령어 치환과 동일한 환경에서 호출됩니다. 이 명령어는 완성 리스트를 한 줄에 하나씩 표준 출력으로 출력해야 합니다. 필요하다면 백슬래시는 개행을 이스케이프하세요.

모든 완성 후보가 생성된 이후에 `-X` 옵션으로 지정한 필터가 리스트에 적용됩니다. 필터는 경로명 전개에서 사용되는 패턴과 같습니다. 패턴의 '&'는 완성 대상인 단어의 텍스트로 대체됩니다. '&' 리터럴은 백슬래시로 이스케이프할 수 있습니다. 백슬래시는 일치를 시도하기 전에 제거됩니다. 패턴에 일치하는 후보는 리스트에서 제거됩니다. 첫머리의 '!'는 부정 패턴을 의미하며, 이 경우 패턴에 일치하지 않는 후보가 제거됩니다. `nocasematch` 셸 옵션(The Shopt Builtin의 `shopt` 설명을 참조)이 켜져있다면, 일치 검사에서 알파벳의 대소문자를 고려하지 않습니다.

마지막으로 `-P`와 `-S` 옵션으로 각각 지정된 접두사와 접미사를 완성 리스트의 각 구성원에 추가한 뒤, Readline 완성 코드에게 완성 후보 리스트로 반환합니다.

이전에 적용된 액션에서 일치하는 것이 아무것도 없고, 완성 명세를 정의할 때 `complete`에 `-o dirnames` 옵션을 넘겼다면 디렉터리명 완성을 시도합니다.

완성 명새를 정의할 때 `complete`에 `-o plusdirs` 옵션을 넘겼다면, 디렉터리명 완성을 시도한 뒤, 다른 액션의 결과에 이를 추가합니다.

기본 설정에서 완성 명세를 발견하면, 명세가 무엇을 생성하든 완성 코드에게 결과를 완전한 완선 후보 집합으로 반환합니다. 기본 Bash 완성은 시도되지 않으며 Readline의 기본 파일명 완성도 비활성화됩니다. 완성 명세를 정의할 때 `complete`에 `-o bashdefault` 옵션을 넘겼다면, 완성 명세가 빈 결과를 생성할 때 기본 Bash 완성을 시도합니다. 완성 명세를 정의할 때 `complete`에 `-o default` 옵션을 넘겼다면 완성 명세가 빈 결과(기본 Bash 완성을 시도했다면 이 완성 결과도 포함)를 생성할 때 Readline의 기본 완성을 시도합니다.

완성 명세가 디렉터리명 완성이 필요하다고 지시했을 때, 완성된 이름이 디렉터리를 가리키는 심볼릭 링크라면 프로그래밍 가능한 완성 기능은 Readline를 통해 뒤에 슬래시를 추가합니다. 이 때 *mark-directories* Readline 변수의 적용을 받습니다만, *mark-symlinked-directories* Readline 변수의 설정은 무시합니다.

동적으로 완성을 수정하기 위한 기능이 있습니다. 이는 `-D`로 지정된 기본 완성과 함께 사용될 때 가장 유용합니다. 완성 핸들러로 실행된 셸 함수가 124 종료 스테이터스를 반환하여 완성을 재시도해야한다고 알릴 수 있습니다. 셸 함수가 124를 반환하고 방금 시도되었던 명령어(함수가 실행될 때 첫번째 인수로 넘겨집니다)에 연결된 완성 명세를 변경했다면, 프로그래밍 가능한 완성은 처음부터 다시 시작하여 해당 명령어의 새 완성 명세를 찾으려 시도합니다. 이는 한번에 모두 읽어들이기 보다는 완성이 시도되었을 때 완성의 집합을 동적으로 생성할 수 있도록 해줍니다.

예를 들어 완성 명세의 라이브러리가 있고, 각 파일은 그에 대응하는 명령어의 이름을 가지고 있다고 가정합시다. 다음 기본 완성 함수는 완성을 동적으로 불러옵니다.

```sh
_completion_loader()
{
    . "/etc/bash_completion.d/$1.sh" >/dev/null 2>&1 && return 124
}
complete -D -F _completion_loader -o bashdefault -o default
```

## 8.7 Programmable Completion Builtins
프로그래밍 가능한 완성 기능을 조작에는 3개의 빌트인 명령어를 사용할 수 있습니다. 하나는 특정 명령어의 인수를 어떻게 완성시킬지 지정하며, 둘은 완성이 일어났을 때 이를 편집할 때 사용합니다.

**compgen**
```sh
compgen [option] [word]
```
*option*에 따라서 *word*와 일치하는 완성 후보를 생성합니다. 옵션으로 `-p`와 `-r`을 제외한 `complete` 빌트인이 처리할 수 있는 옵션을 사용할 수 있으며, 일치 결과를 표준 출력으로 출력합니다. `-F`나 `-C` 옵션을 사용할 때 프로그래밍 가능한 완성 기능에 의해서 다양한 셸 변수가 설정됩니다만. 설정될 때까지는 유용한 값을 가지고 있지 않습니다.

일치 결과는 프로그래밍 가능한 완성 코드가 완성 명세로부터 같은 플래그를 가지고 생성한 것과 동일한 방식으로 생성됩니다. *word*를 지정했다면 *word*와 일치하는 완성만을 출력할 것입니다.

잘못된 옵션을 넘기거나 일치한 결과가 없는 경우가 아니라면 반환 값은 참입니다.

**complete**
```sh
complete [-abcdefgjksuv] [-o comp-option] [-DEI] [-A action] [-G globpat]
[-W wordlist] [-F function] [-C command] [-X filterpat]
[-P prefix] [-S suffix] name [name …]
complete -pr [-DEI] [name …]
```

각 *name*의 인수를 어떻게 완성할지 지정합니다. `-p` 옵션을 넘기거나 아무 옵션도 넘기지 않는다면, 존재하는 완성 명세를 입력으로 재활용 가능한 형식으로 출력합니다. `-r` 옵션은 각 *name*의 완성 명세를 제거하거나 *name*을 넘기지 않았다면 모든 완성 명세를 제거합니다. `-D` 옵션은 넘긴 다른 옵션과 액션을 "기본" 명령어 완성에 적용하라고 지시합니다. 다르게 말하면, 이전에 완성을 정의하지 않은 명령어에 대해서 완성을 시도합니다. `-E` 옵션은 넘긴 다른 옵션과 액션이 "빈" 명령어 완성에 적용하라고 지시합니다. 이는 빈 라인에서 완성을 시도할 때 사용됩니다. `-I` 옵션은 넘긴 다른 옵션과 액션이 줄에서 대입이 아닌 첫번째 단어, 또는 ','나 '|'와 같은 명령어 구분자 뒤의 완성에 적용하라고 지시합니다. 이는 보통 명령어 이름 완성입니다. 옵션을 여러 개 넘긴 경우, `-D` 옵션이 `-E` 보다 우선되며, 이 둘은 `-I`보다 우선됩니다. `-D`, `-E`, `-I` 중 하나가 지정되었다면 다른 *name* 인수는 무시됩니다. 일반적으로 이 완성은 명령어 이름 완성입니다.

단어 완성을 시도할 때 완성 명세를 적용하는 처리에 대해서는 위에서 설명했습니다(Programmable Completion을 참조).

그 이외의 옵션들을 넘겼다면 다음과 같은 의미를 가집니다. `-G`, `-W`, `-X` (필요하다면 `-P`와 `-S`) 옵션의 인수는 `complete` 빌트인을 호출하기 전에 전개되지 않도록 따옴표로 감싸야 합니다.

- **-o *comp-option***
  *comp-option*은 단순히 완성을 생성하는 것만 아니라 완성 명세 동작의 여러 부분을 제어합니다. *comp-option*은 다음 중 하나입니다.
  - bashdefault
    완성 명세가 일치하는 결과를 생성하지 못한다면, 기본 Bash 완성의 나머지를 실행합니다.
  - default
    완성 명세가 일치하는 결과를 생성하지 못한다면, Readline의 기본 파일명 완성을 사용합니다.
  - dirnames
    완성 명세가 일치하는 결과를 생성하지 못한다면, 디렉터리명 완성을 실행합니다.
  - filenames
    Readline에게 완성 명세가 파일명을 생성한다고 알려주고, 파일명 고유의 처리(디렉터리명 뒤에 슬래시를 추가하거나, 특수 문자를 따옴표로 감싸거나, 끝에 따라오는 스페이스를 제거하는 등의 처리)를 할 수 있도록 합니다. 이 옵션은 `-F`로 지정한 셸 함수와 사용하는 것을 상정하고 있습니다.
  - noquote
    Readline에게 완성된 단어가 파일명(파일명을 따옴표로 감싸는 것이 기본 동작입니다)이라면 따옴표로 감싸지 말라고 알려줍니다.
  - nosort
    Readline에게 완성 후보 리스트를 알파벳 순으로 정렬하지 말라고 알려줍니다.
  - nospace
    Readline에게 줄의 끝에서 완성된 단어 뒤에 스페이스를 추가하지 말라고 알려줍니다(스페이스를 추가하는 것은 기본 동작입니다).
  - plusdirs
    완성 명세로 정의된 일치가 생성된 후에 디렉터리명 완성을 시도하고 이를 다른 액션의 결과에 추가합니다.
- **-A *action***
  *action*은 다음 중 하나로, 완성 후보 리스트를 생성합니다.
  - alias
    별칭 이름. `-a`로도 지정할 수 있습니다.
  - arrayvar
    배열 변수 이름.
  - binding
    Readline 키 바인딩 이름(Bindable Readline Commands를 참조).
  - builtin
    셸 빌트인 명령어의 이름. `-b`로도 지정할 수 있습니다.
  - command
    명령어 이름. `-c`로도 지정할 수 있습니다.
  - directory
    디렉터리 이름. `-d`로도 지정할 수 있습니다.
  - disabled
    비활성화된 셸 빌트인 이름.
  - enabled
    활성화된 셸 빌트인 이름.
  - export
    익스포트한 셸 변수 이름. `-e`로도 지정할 수 있습니다.
  - file
    파일 이름. `-f`로도 지정할 수 있습니다.
  - function
    셸 함수 이름.
  - group
    그룹 이름. `-g`로도 지정할 수 있습니다.
  - helptopic
    `help` 빌트인(Bash Builtins를 참조)이 받을 수 있는 도움말 주제.
  - hostname
    `HOSTFILE` 셸 변수(Bash Variables를 참조)로 지정한 파일에서 가져온 호스트명.
  - job
    잡 컨트롤이 활성화되어 있다면, 잡 이름. `-j`로도 지정할 수 있습니다.
  - keyword
    셸 예약어. `-k`로도 지정할 수 있습니다.
  - running
    잡 컨트롤이 활성화되어 있다면, 실행중인 잡 이름.
  - service
    서비스 이름. `-s`로도 지정할 수 있습니다.
  - setopt
    `set` 빌트인의 `-o` 옵션에 넘길 수 있는 유효한 인수(The Set Builtin을 참조).
  - shopt
    `shopt` 빌트인이 받을 수 있는 셸 옵션(The Set Builtin을 참조).
  - signal
    시그널 이름.
  - stopped
    잡 컨트롤이 활성화되어 있다면, 중단된 잡 이름.
  - user
    유저명. `-u`로도 지정할 수 있습니다.
  - variable
    모든 셸 변수 이름. `-v`로도 지정할 수 있습니다.
- **-C *command***
  *command*는 서브셸 환경에서 실행되며, 그 출력이 완성 후보로 사용됩니다.
- **-F *function***
  셸 함수 *function*은 현재 셸 환경에서 실행됩니다. 위에서 설명했듯이(Programmable Completion을 참조), 실행될 때 `$1`은 완성 대상인 인수의 명령어 이름이며, `$2`는 완성 대상인 단어, `$3`은 완성 대상인 단어 앞의 단어입니다. 종료할 때, `COMPREPLY` 배열 변수의 값으로부터 완성 후보를 가져옵니다.
- **-G *globpat***
  완성 후보를 생성하기 위해 파일명 전개 패턴 *globpat*을 전개합니다.
- **-P *prefix***
  다른 옵션이 모두 적용된 뒤에 각각의 완성 후보의 첫머리에 *prefix*를 추가합니다.
- **-S *suffix***
  다른 옵션이 모두 적용된 뒤에 각각의 완성 후보의 끝머리에 *suffix*를 추가합니다.
- **-W *wordlist***
  *wordlist*는 `IFS` 특수 변수를 구분자로 사용하여 분할되며 각 단어를 전개합니다. 완성 후보는 전개 결과에서 완성 대상 단어와 일치하는 구성원이 됩니다.
- **-X *filterpat***
  *filterpat*은 파일명 전개에서 사용되는 패턴입니다. 선행하는 옵션과 인수로부터 생성된 완성 후보 리스트에 적용되며, *filterpat*과 일치하는 후보를 리스트에서 제거합니다. *filterpat*의 첫머리가 '!'로 시작하면 부정 패턴이 됩니다. 이 경우 *filterpat*과 일치하지 않는 후보를 제거합니다.

잘못된 옵션을 넘기거나 `-p`나 `-r` 이외의 옵션을 *name* 인수 없이 넘기거나 명세가 존재하지 않는 *name*의 완성 명세를 제거하려는 시도나 완성 명세를 추가할 때 에러가 발생한 경우가 아니라면 반환값은 참입니다.

**compopt**
```sh
compopt [-o option] [-DEI] [+o option] [name]
```

각 *name*의 완성 옵션을 *option* 값에 따라서 변경합니다. *name*을 넘기지 않았다면 현재 실행중인 완성을 변경합니다. *option*이 주어지지 않았다면, 각 *name*의 완성 또는 현재 완성의 완성 옵션을 보여줍니다. *option*으로 사용할 수 있는 값은 `complete` 빌트인에서 설명한 옵션과 같습니다. `-D` 옵션은 넘긴 다른 옵션과 액션을 "기본" 명령어 완성에 적용하라고 지시합니다. 다르게 말하면, 이전에 완성을 정의하지 않은 명령어에 대해서 완성을 시도합니다. `-E` 옵션은 넘긴 다른 옵션과 액션이 "빈" 명령어 완성에 적용하라고 지시합니다. 이는 빈 라인에서 완성을 시도할 때 사용됩니다. `-I` 옵션은 넘긴 다른 옵션과 액션이 줄에서 대입이 아닌 첫번째 단어, 또는 ','나 '|'와 같은 명령어 구분자 뒤의 완성에 적용하라고 지시합니다. 일반적으로 이 완성은 명령어 이름 완성입니다.

옵션을 여러 개 넘긴 경우, `-D` 옵션이 `-E` 보다 우선되며, 이 둘은 `-I`보다 우선됩니다.

잘못된 옵션을 넘기거나 완성 명세가 존재하지 않는 *name*의 옵션을 변경하려는 시도나 출력 에러가 발생한 경우가 아니라면 반환값은 참입니다.

## 8.8 A Programmable Completion Example
`complete`와 `compgen`이 제공하는 기본 액션 이상의 추가 완성 기능을 얻는 가장 흔한 방법은 셸 함수를 사용하고 `complete -F`로 특정 명령어에 바인딩하는 것입니다.

다음 함수는 `cd` 빌트인의 완성을 제공합니다. 셸 함수를 완성에서 사용할 때 무엇을 해야하는지에 대한 꽤 좋은 예제입니다. 이 함수는 `$2`로 넘겨진 단어를 사용해 완성할 디렉터리 이름을 결정합니다. `COMP_WORDS` 배열 변수도 사용할 수 있습니다. 현재 단어는 COMP_CWORD 변수에 색인되어 있습니다.

이 함수는 많은 부분을 `complete`와 `compgen` 빌트인에 의존하고 있으며, Bash의 `cd`가 기본적인 디렉터리 이름을 받는 것 이상인 다음 기능을 추가합니다. 물결줄표 확장(Tilde Expansion을 참조), 이전에 설명(Bourne Shell Builtins를 참조)한 *$CDPATH*의 디렉터리를 검색하기, `cdable_vars` 셸 옵션(The Shopt Builtin을 참조)에 대한 기본적인 지원. 그리고 `_comp_cd`는 스페이스나 탭을 포함하는 파일명에 대응하기 위해 *IFS*의 값이 개행만 포함하도록 수정하며, `compgen`은 생성한 완성 후보를 한 줄에 하나씩 출력합니다.

완성 후보는 *COMPREPLY* 배열 변수에 저장되며, 각 인덱스에 하나의 완성 후보가 저장됩니다. 프로그래밍 가능한 완성 시스템은 함수가 반환될 때 이 곳에서 완성 후보를 꺼내옵니다.

```sh
# bash_completion 패키지의 cd 완성 함수에 기초한
# cd 빌트인을 위한 완성 함수
_comp_cd()
{
    local IFS=$' \t\n'    # IFS 정규
    local cur _skipdot _cdpath
    local i j k

    # 물결줄표를 전체 경로명으로 전개하는 물결줄표 전개
    case "$2" in
    \~*)    eval cur="$2" ;;
    *)      cur=$2 ;;
    esac

    # cdpath 또는 절대 경로가 없음 -- 바로 디렉터리 완성을 실행
    if [[ -z "${CDPATH:-}" ]] || [[ "$cur" == @(./*|../*|/*) ]]; then
        # compgen은 한 줄에 한 경로를 출력. while 루프를 사용할 수도 있음
        IFS=$'\n'
        COMPREPLY=( $(compgen -d -- "$cur") )
        IFS=$' \t\n'
    # CDPATH와 CDPATH에 없는 경우 현재 디렉토리의 디렉터리
    else
        IFS=$'\n'
        _skipdot=false
        # CDPATH의 널 디렉터리 이름을 .으로 변환하기 위한 전처리
        _cdpath=${CDPATH/#:/.:}
        _cdpath=${_cdpath//::/:.:}
        _cdpath=${_cdpath/%:/:.}
        for i in ${_cdpath//:/$'\n'}; do
            if [[ $i -ef . ]]; then _skipdot=true; fi
            k="${#COMPREPLY[@]}"
            for j in $( compgen -d -- "$i/$cur" ); do
                COMPREPLY[k++]=${j#$i/}        # 디렉터리를 잘라냄
            done
        done
        $_skipdot || COMPREPLY+=( $(compgen -d -- "$cur") )
        IFS=$' \t\n'
    fi

    # 적절한 셸 옵션이 설정되어 있고 완성 후보가 없다면 변수 이름
    if shopt -q cdable_vars && [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        COMPREPLY=( $(compgen -v -- "$cur") )
    fi

    return 0
}
```

이 완성 함수를 `complete`의 `-F` 옵션으로 넘겨서 설치할 수 있습니다.

```sh
# Readline에게 적절하게 따옴표로 감싸고 디렉터리 뒤에 슬래시를 붙이도록 지시합니다.
# 다른 인수에 대해서는 bash의 기본 완성을 사용합니다.
complete -o filenames -o nospace -o bashdefault -F _comp_cd cd
```

나머지 자세한 부분에 대해서는 Bash와 Readline이 처리하도록 두고싶기 때문에 다른 옵션들을 사용해서 Bash와 Readline에게 필요한 것을 전달했습니다. `-o filenames` 옵션은 Readline에게 완성 후보는 파일명으로 다루어져야 하며 적절히 따옴표로 감싸야한다고 지시합니다. 이 옵션은 Readline이 파일명이 디렉터리 이름이라고 판단했을 경우 뒤에 슬래시를 추가하도록 합니다(*CDPATH*로 발견한 디렉터리를 사용할 경우 `_comp_cd`를 확장해서 슬래시를 추가하길 원하는 이유가 될 수도 있습니다. Readline은 이 완성을 디렉터리로 판단할 수 없기 때문입니다). `-o nospace` 옵션은 유저가 스페이스 문자를 직접 추가하고 싶을 때를 대비해 Readline에게 디렉터리 명에 스페이스 문자를 추가하지 않도록 지시합니다. `-o bashdefault` 옵션은 "Bash 기본" 완성의 나머지 부분, 그러니까 Bash가 기본 Readline 집합에 추가하는 완성 후보를 가져옵니다. 여기에는 명령어 이름 완성, '$' 또는 '${'로 시작하는 단어의 변수 완성, 경로명 전개 패턴을 포함하는 완성(Filename Expansion을 참조) 등을 포함합니다.

일단 `complete`로 설치하면 `_comp_cd`는 `cd` 명령어에서 단어 완성을 시도할 때마다 호출됩니다.

더 많은 예제(GNU, Unix, Linux의 일반적인 명령어 거의 전부를 완성하는 풍부한 컬렉션)은 bash_completion 프로젝트의 일부로 사용 가능합니다. 이들은 많은 GNU/Linux 배포판에서 기본으로 설치됩니다. 본래는 Ian Macdonald가 작성했습니다만 프로젝트는 이제 https://github.com/scop/bash-completion/ 에서 관리됩니다. 여기에는 Solaris와 Mac OS X와 같은 다른 시스템에 이식한 버전도 있습니다.

bash_completion 패키지의 구버전은 Bash와 함께 `examples/complete` 서브 디렉터리에 배포됩니다.

# 9. Using History Interactively
이 장에서는 유저의 입장에서 GNU 이력 라이브러리와 상호작용하는 법을 설명합니다. 사용자 가이드라고 생각해주세요. GNU 이력 라이브러리를 다른 프로그램에서 사용하는 방법에 대해서는 GNU Readline 라이브러리 매뉴얼을 참조해주세요.

- Bash History Facilities : Bash가 명령어 이력을 생성하는 방법.
- Bash History Builtins : 명령어 이력을 다루기 위한 Bash 빌트인 명령어.
- History Interaction : 유저로서 이력을 사용할 때의 감상.

## 9.1 Bash History Facilities
`set` 빌트인에 `-o history` 옵션을 켜짐으로 설정했을 때(The Set Builtin을 참조), 셸은 이전에 입력한 명령어 리스트인 *명령어 이력*에 접근할 수 있도록 합니다. `HISTSIZE` 셸 변수의 값은 이력 리스트에 저장할 명령어의 개수를 지정합니다. 마지막 `$HISTSIZE` 명령어의 텍스트(기본값은 500)가 저장됩니다. 셸은 매개변수나 변수를 전개하기 전에 각 명령어를 이력 리스트에 저장합니다만, 이력 전개가 실행되면 셸 변수 `HISTIGNORE`와 `HISTCONTROL`의 값이 적용됩니다.

셸이 시작할 때, `HISTFILE` 변수(기본값은 `~/.bash_history`)로 지정된 파일로 이력을 초기화합니다. `HISTFILE`의 값에 지정된 파일은 필요에 따라서 저장하고 있는 이력이 `HISTFILESIZE` 변수의 값에 지정된 줄 수 이하가 되도록 여분을 잘라냅니다. 이력 기능이 활성화된 상태에서 셸을 종료할 때, 마지막 `$HISTSIZE` 개의 줄이 이력 리스트로부터 `$HISTFILE`로 지정한 파일에 복사됩니다. `histappend` 셸 옵션이 켜져있다면(Bash Builtins를 참조), 이력 파일의 마지막에 추가되며, 옵션이 꺼져 있다면 이력 파일 전체를 덮어씁니다. `HISTFILE`이 설정되어 있지 않거나 이력 파일에 쓰기 권한이 없을 때, 이력은 저장되지 않습니다. 이력을 저장한 후, 이력 파일은 `$HISTFILESIZE` 개의 줄보다 많은 줄을 포함하지 않도록 여분을 잘라냅니다. `HISTFILESIZE`가 설정되어 있지 않거나 또는 널, 숫자가 아닌 값, 0보다 작은 값이 설정되어 있다면, 이력 파일을 잘라내는 동작은 실행되지 않습니다.

`HISTTIMEFORMAT`이 설정되어 있다면, 각 이력에 대한 타임스탬프 정보가 이력 코멘트 문자와 함께 이력 파일에 기록됩니다. 이력 파일을 읽을 때, 이력 코멘트 문자 바로 뒤에 오는 숫자는 그 다음에 오는 이력의 타임 스탬프로 인식됩니다.

빌트인 명령어 `fc`는 이력 리스트의 한 부분을 출력하거나 편집하고 재실행할 수 있습니다. `history` 빌트인은 이력 리스트를 보여주거나 편집할 수 있으며 이력 파일을 편집할 수 있습니다. 커맨드 라인 편집 기능을 사용할 때 각 편집 모드는 이력 리스트에 접근하는 기능을 제공하며, 이를 통해 명령어를 검색할 수 있습니다(Commands For History를 참조).

셸은 어떤 명령어를 이력 리스트에 저장할지 제어할 수 있습니다. `HISTCONTROL`과 `HISTIGNORE` 변수를 설정하면 셸은 입력된 명령어의 일부만 저장합니다. `cmdhist` 셸 옵션이 켜져있다면, 셸이 여러줄 명령어의 각 줄을 하나의 이력으로 저장하도록 하며, 필요에 따라 세미콜론을 추가해 입력 자체를 정확하게 유지합니다. `lithist` 셸 옵션을 켜면 세미콜론 대신에 개행을 사용해 명령어를 유지합니다. 이 옵션들을 설정하려면 `shopt` 빌트인을 사용합니다. `shopt`에 대한 설명은 The Shopt Builtin을 참조하세요. 

## 9.2 Bash History Builtins
Bash는 이력 리스트와 이력 파일을 다루기 위해 두 개의 빌트인 명령어를 제공합니다.

**fc**
```sh
fc [-e ename] [-lnr] [first] [last]
fc -s [pat=rep] [command]
```

첫번째 형식은 이력 리스트에서 *first*부터 *last*까지의 명령어를 선택해 출력하거나 편집하고 재실행합니다. *first*와 *last*는 문자열(해당 문자열로 시작하는 가장 최근의 명령어를 찾습니다)이나 숫자(이력 리스트의 인덱스. 음수는 현재 명령어 번호로부터의 오프셋으로 사용됩니다)를 지정할 수 있습니다.

리스트를 나열할 때, *first*나 *last*가 0이면 -1과 동일하고, -0은 현재 명령어와 동일합니다(일반적으로 `fc` 명령어). 그 이외의 경우에는 0은 -1과 동일하며 -0은 유효하지 않습니다.

*last*를 지정하지 않았다면 *first*의 값이 사용됩니다. *first*를 지정하지 않았다면 이전에 편집한 명령어 또는 리스트를 나열하는 경우에는 -16이 설정됩니다. `-l` 플래그를 넘겼다면 명령어는 표준 출력에 리스트를 나열합니다. `-n` 플래그는 리스트를 나열할 때 명령어 번호를 출력하지 않습니다. 그 이외의 경우에는 지정된 명령어 리스트를 포함하는 파일을 `ename`으로 지정된 에디터로 엽니다. *ename*이 지정되지 않았다면 `${FCEDIT:-${EDITOR:-vi}}`의 전개한 값을 사용합니다. 이는 `FCEDIT` 변수, `EDITOR` 변수를 순서대로 확인하고, 둘 다 설정되어 있지 않다면 `vi`를 사용한다는 의미입니다. 편집이 완료되면 편집된 명령어들을 출력하고 실행합니다.

두번째 형식에서 선택된 *command*의 *pat*의 각 인스턴스를 *rep*로 대체된 이후, 명령어를 재실행합니다. *command*는 위에서 본 *first*와 동일하게 처리됩니다.

`r='fc -s'`는 '`r cc`'를 입력하면 `cc`로 시작하는 마지막 명령어를 실행하고 `r`을 입력하면 마지막 명령어를 재실행하므로 `fc` 명령어를 사용할 때 유용한 별칭입니다.

**history**
```sh
history [n]
history -c
history -d offset
history -d start-end
history [-anrw] [filename]
history -ps arg
```

옵션 지정 없이 사용하면 이력 리스트는 줄 번호와 함께 출력합니다. '*'로 시작하면 줄이 변경되었다는 의미입니다. *n* 인수는 마지막 *n*개의 줄을 출력합니다. 셸 변수 `HISTTIMEFORMAT`에 널이 아닌 값이 설정되어 있다면 각 이력과 연결된 타임스탬프를 출력할 때 *stftime*의 형식 문자열로 사용됩니다. 형식화된 타임스탬프와 이력 줄 사이에는 공백 문자가 포함되지 않습니다.

넘긴 옵션은 다음의 의미를 가집니다.

- **-c**
  이력 리스트를 비웁니다. 다른 옵션과 조합해서 이력 리스트를 완전히 대체할 수 있습니다.
- **-d *offset***
  *offset*에 위치하는 이력을 지웁니다. *offset*이 양수라면 이력을 출력할 때 보이는 순서입니다. *offset*이 음수라면 마지막 이력 위치로부터 하나 큰 위치의 상대값으로 처리되므로, 음수 인덱스는 이력의 맨 끝으로부터 셉니다. 그러므로 인덱스 '-1'은 현재 `history -d` 명령어입니다.
- **-d *start-end***
  이력 리스트의 *start*번째 이력과 *end*번째 이력 사이에 있는 이력을 포괄적으로 삭제합니다. *start*와 *end*에 넘긴 양수와 음수는 각각 위에서 설명한 것과 동일하게 처리됩니다.
- **-a**
  새 이력을 이력 파일의 마지막에 추가합니다. 대상은 현재 Bash 세션이 시작된 이후로 입력된 줄이며, 단 아직 이력 파일에 추가되지는 않은 것들입니다.
- **-n**
  이력 파일로부터 아직 읽히지 않은 이력 줄을 현재 이력 리스트에 추가합니다. 대상은 현재 Bash 세션을 시작한 이후에 이력 파일에 추가된 줄입니다.
- **-r**
  이력 파일을 읽고 그 내용을 이력 리스트에 추가합니다.
- **-w**
  현재 이력 리스트를 이력 파일로 내보냅니다.
- **-p**
  *args`에 대해 이력 치환을 실행하고 결과를 표준 출력에 보여줍니다. 이 때 결과는 이력 리스트에 저장하지 않습니다.
- **-s**
  *args*를 이력 리스트의 마지막에 하나의 이력으로 추가합니다.

`-w`, `-r`, `-a`, `-n` 옵션을 사용하고 *filename*을 넘겼다면, 넘긴 파일이 이력 파일로 사용됩니다. 넘기지 않았다면 `HISTFILE` 변수의 값이 사용됩니다.

## 9.3 History Interaction
이력 라이브러리는 `csh`가 제공하는 이력 전개와 유사한 이력 전개 기능을 제공합니다. 이 섹션에서는 이력 정보를 다루기 위한 문법에 대해서 설명합니다.

이력 전개는 명령어를 쉽게 반복해서 실행하거나 이전 명령어의 인수를 현재 입력 줄로 삽입하거나 이전 명령어의 에러를 간단하게 수정할 수 있도록 이력 리스트로부터 입력 스트림으로 단어를 가져오게 해줍니다.

이력 전개는 완전한 줄을 읽은 직후, 셸이 줄을 단어로 분리하기 전에 각 줄에 대해서 개별적으로 실행됩니다. Bash는 이전 줄로부터 따옴표로 감싼 상태가 아직 유효하다는 것을 이력 전개 기능에게 알려줍니다.

이력 전개는 두 부분으로 구성됩니다. 첫번째는 치환 중에 이력 리스트로부터 어떤 줄을 사용할 지 결정하는 것입니다. 두번째는 그 줄의 일부를 선택하여 현재 줄에 추가하는 것입니다. 이력에서 선택한 줄은 *이벤트*라고 부르며 그 줄에 있는 것들을 *단어*라고 부릅니다. 선택한 단어를 조작하는 다양한 *수식자*가 사용가능합니다. 줄은 Bash가 하는 것과 동일한 방식으로 단어로 분리되며, 그러므로 따옴표로 감싼 부분은 하나의 단어로 처리됩니다. 이력 전개는 이력 전개 문자가 출현하면 시작되며, 이 문자의 기본값은 '!'입니다.

이력 전개는 셸과 유사한 따옴표로 감싸기 규칙을 구현합니다. 백슬래시는 다음 문자의 특수성을 제거합니다. 작은따옴표로 감싼 문자열은 문자 그대로의 의미로 사용되며 이력 전개를 금지합니다. 그리고 큰따옴표로 감싼 문자열은 이력 전개 문자를 백슬래시로 이스케이프할 수 있으므로 이력 전개가 발생할 수 있습니다만, 작은따옴표는 큰따옴표 사이에서 특별한 취급을 받지 않기 때문에 이력 전개의 대상이 되지 못합니다.

셸에서는 '\\'와 '\''만 이력 전개 문자를 이스케이프할 수 있습니다만, 큰따옴표로 감싼 문자열의 닫는 큰따옴표 바로 앞에 오면 이력 전개 문자는 따옴표로 감싼 것처럼 동작합니다.

`shopt` 빌트인(The Shopt Builtin을 참조)으로 설정가능한 몇몇 셸 옵션은 이력 전개의 행동을 제어할 수 있습니다. `histvarify` 셸 옵션이 켜져있고 Readline을 사용한다면 이력 치환은 셸 파서로 바로 넘겨지지 않습니다. 그 대신 추가 편집을 위해 전개된 줄을 Readline 편집 버퍼로 불러옵니다. Readline이 사용중이고 `histreedit` 셸 옵션이 켜져있다면, 실패한 이력 전개를 수정하기 위해 이를 Readline 편집 버퍼로 불러올 것입니다. `history` 빌트인 명령어에 `-p` 옵션을 넘기면 이력 전개 내용을 확인한 후에 사용할 수 있습니다. `history` 빌트인에 `-s` 옵션을 넘기면 명령어를 실제로 실행하지 않고 이력 리스트의 마지막에 추가해 이후에 사용할 수 있도록합니다. 이는 Readline과 함께 사용하면 무척 유용합니다.

셸은 이력 전개 기능에서 사용되는 여러 문자들을 이전에 설명했듯이(Bash Variables를 참조) `histchars` 변수로 제어할 수 있습니다. 셸은 이력 파일에 기록할 때 이력의 타임 스탬프를 표시하기 위해서 이력 코멘트 문자를 사용합니다.

- Event Designators : 사용할 이력줄을 지정하는 방법.
- Word Designators : 관심있는 단어를 지정하기.
- Modifiers : 치환 결과를 수정하기.

### 9.3.1 Event Designators
이벤트 지정자는 이력 리스트의 커맨드 라인에 대한 참조입니다. 절대 참조가 아닌 이상, 이벤트는 이력 리스트의 현재 위치로부터 상대적입니다.

**!**
스페이스, 탭, 줄의 마지막, '='나 '('(`shopt` 빌트인으로 `extglob` 셸 옵션을 켰을 때만)의 직후가 아니라면 이력 치환을 시작합니다.

**!*n***
커맨드 라인 *n*을 참조.

**!-*n***
*n*개 줄 뒤의 명령어를 참조.

**!!**
이전 명령어를 참조. 이는 '!-1'의 동의어입니다.

**!*string***
이력 리스트에서 *string*으로 시작하는 이력의 앞에 있는 가장 최근의 명령어를 참조합니다.

**!?*string*\[?]**
이력 리스트에서 *string*을 포함하는 이력의 앞에 있는 가장 최근의 명령어를 참조합니다. *string* 직후에 개행이 있다면, 말미의 '?'는 생략할 수 있습니다. *string*이 없다면 가장 최근 검색에서 사용한 문자열이 사용됩니다. 이전 검색 문자열을 찾을 수 없다면 에러가 발생합니다.

**^*string1*^*string2*^**
빠른 치환. 마지막 명령어를 반복하고 *string1*을 *string2*로 대체합니다. !!:s^*string1*^*string2*^와 동일합니다.

**!#**
지금까지 입력된 커맨드 라인 전체.

### 9.3.2 Word Designators
다음은 예제입니다.

**!!**
직전 명령어를 지정합니다. 이를 입력하면 직전 명령어를 그대로 반복합니다.

**!!:$**
직전 명령어의 마지막 인수를 지정합니다. `!$`로 줄여쓸 수 있습니다.

**!fi:2**
`fi`로 시작하는 가장 최근 명령어의 두번째 인수를 지정합니다.

다음은 단어 지정자입니다.

**0 (zero)**
0번째 단어. 많은 애플리케이션에서 명령어 이름입니다.

***n***
*n*번째 단어.

**^**
첫번째 인수. 다시 말해, 1번째 단어.

**$**
마지막 인수.

**%**
검색 문자열이 단어의 일부와 일치하는 문자열로 시작한다면, 가장 최근 '?*string*?' 검색에서 일치한 첫번째 단어.

***x*-*y***
단어의 범위. '0-*y*'는 '-*y*'로 줄여쓸 수 있습니다.

**\***
0번째를 제외한 모든 단어. 이는 '1-$'와 동의어입니다. 이벤트에 단어가 하나일 때 '*'를 사용해도 에러는 발생하지 않습니다. 이 경우 빈 문자열이 반환됩니다.

***x*\***
'*x*-$'의 축약.

***x*-**
'*x*\*'와 유사한 *x*-$'의 축약. 단 마지막 단어를 생략합니다. 'x'가 없다면 기본값인 0을 사용합니다.

단어 지정자를 이벤트 명세 없이 사용하면 직전 명령어를 이벤트로 사용합니다.

### 9.3.3 Modifiers
선택적인 단어 지정자 뒤에, 다음의 수식자를 하나 이상 추가할 수 있습니다. 각각은 ':'을 앞에 붙여야 합니다. 이들은 이력 이벤트로부터 선택된 단어를 변경합니다.

**h**
뒤따라오는 경로명 부분을 제거하고 앞부분만 남깁니다.

**t**
경로명의 앞부분을 제거하고 마지막 부분만 남깁니다.

**r**
'.*suffix*' 형식의 접미사를 제거하고, 기본 이름만 남깁니다.

**e**
접미사만 남기고 모두 제거합니다.

**p**
새 명령어를 출력만 하고 실행하지 않습니다.

**q**
치환한 단어를 따옴표로 감싸서 이후 치환에서 이스케이프되도록 합니다.

**x**
'q' 처럼 치환한 단어를 따옴표로 감싸지만, 스페이스, 탭, 개행으로 단어를 나눕니다. 'q'와 'x' 수식자는 상호 
배타적이며, 나중에 넘긴 것이 사용됩니다.

**s/*old*/*new*/**
이벤트 줄에서 첫번째로 출현한 *old*를 *new*로 치환합니다. 어떤 문자든 '/' 대신에 사용할 수 있습니다. 구분자는 *old*와 *new* 사이에서 백슬래시 하나로 이스케이프할 수 있습니다. *new*에 '&'가 있다면 이는 *old*로 대체됩니다. 백슬래시는 '&'를 이스케이프할 수 있습니다. *old*가 널이라면 마지막에 치환된 *old*, 또는 이전에 이력 치환을 한 적이 없었다면 !?*string*[?] 검색의 마지막 *string*이 사용됩니다. *new*가 널이라면, 일치한 각 *old*가 삭제됩니다. 마지막 구분자가 입력 줄의 마지막 문자라면 생략 가능합니다.

**&**
이전 치환을 반복합니다.

**g**
**a**
이벤트 줄 전체에 변경을 적용합니다. gs/old/new/ 처럼 's'를 함께 사용하거나 '&'와 함께 사용됩니다.

**G**
따라오는 's'나 '&' 수식자를 이벤트의 각 단어마다 한번씩 적용합니다.
